EXPORT:2026-02-27_07-50
wFmG|S|Script
-- LocalScript inside YourBaseIndicator BillboardGui
local billboard = script.Parent
local startOffset = billboard.StudsOffset
local glowStroke = billboard.Frame:FindFirstChild("GlowStroke", true)

-- Calculate bob amount as percentage of height (10% of the Y offset)
local bobHeight = math.abs(startOffset.Y) * 0.075
local bobSpeed = 2

-- Bobbing animation
task.spawn(function()
	local time = 0
	while billboard and billboard.Parent do
		time = time + task.wait(0.03)
		local offset = math.sin(time * bobSpeed) * bobHeight
		billboard.StudsOffset = startOffset + Vector3.new(0, offset, 0)
	end
end)

-- Pulsing glow animation
if glowStroke then
	task.spawn(function()
		while glowStroke and glowStroke.Parent do
			for i = 0.3, 0.7, 0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
			for i = 0.7, 0.3, -0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
		end
	end)
end
wFmG|S|Script
local parent = script.Parent
task.spawn(function()
	while true do
		parent.Rotation += 2.5
		task.wait()
	end
end)
wFmG|S|Script
-- LocalScript inside YourBaseIndicator BillboardGui
local billboard = script.Parent
local startOffset = billboard.StudsOffset
local glowStroke = billboard.Frame:FindFirstChild("GlowStroke", true)

-- Calculate bob amount as percentage of height (10% of the Y offset)
local bobHeight = math.abs(startOffset.Y) * 0.075
local bobSpeed = 2

-- Bobbing animation
task.spawn(function()
	local time = 0
	while billboard and billboard.Parent do
		time = time + task.wait(0.03)
		local offset = math.sin(time * bobSpeed) * bobHeight
		billboard.StudsOffset = startOffset + Vector3.new(0, offset, 0)
	end
end)

-- Pulsing glow animation
if glowStroke then
	task.spawn(function()
		while glowStroke and glowStroke.Parent do
			for i = 0.3, 0.7, 0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
			for i = 0.7, 0.3, -0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
		end
	end)
end
wFmG|S|Script
local parent = script.Parent
task.spawn(function()
	while true do
		parent.Rotation += 2.5
		task.wait()
	end
end)
wFmG|S|Script
-- LocalScript inside YourBaseIndicator BillboardGui
local billboard = script.Parent
local startOffset = billboard.StudsOffset
local glowStroke = billboard.Frame:FindFirstChild("GlowStroke", true)

-- Calculate bob amount as percentage of height (10% of the Y offset)
local bobHeight = math.abs(startOffset.Y) * 0.075
local bobSpeed = 2

-- Bobbing animation
task.spawn(function()
	local time = 0
	while billboard and billboard.Parent do
		time = time + task.wait(0.03)
		local offset = math.sin(time * bobSpeed) * bobHeight
		billboard.StudsOffset = startOffset + Vector3.new(0, offset, 0)
	end
end)

-- Pulsing glow animation
if glowStroke then
	task.spawn(function()
		while glowStroke and glowStroke.Parent do
			for i = 0.3, 0.7, 0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
			for i = 0.7, 0.3, -0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
		end
	end)
end
wFmG|S|Script
local parent = script.Parent
task.spawn(function()
	while true do
		parent.Rotation += 2.5
		task.wait()
	end
end)
wFmG|S|Script
-- LocalScript inside YourBaseIndicator BillboardGui
local billboard = script.Parent
local startOffset = billboard.StudsOffset
local glowStroke = billboard.Frame:FindFirstChild("GlowStroke", true)

-- Calculate bob amount as percentage of height (10% of the Y offset)
local bobHeight = math.abs(startOffset.Y) * 0.075
local bobSpeed = 2

-- Bobbing animation
task.spawn(function()
	local time = 0
	while billboard and billboard.Parent do
		time = time + task.wait(0.03)
		local offset = math.sin(time * bobSpeed) * bobHeight
		billboard.StudsOffset = startOffset + Vector3.new(0, offset, 0)
	end
end)

-- Pulsing glow animation
if glowStroke then
	task.spawn(function()
		while glowStroke and glowStroke.Parent do
			for i = 0.3, 0.7, 0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
			for i = 0.7, 0.3, -0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
		end
	end)
end
wFmG|S|Script
local parent = script.Parent
task.spawn(function()
	while true do
		parent.Rotation += 2.5
		task.wait()
	end
end)
wFmG|S|Script
-- LocalScript inside YourBaseIndicator BillboardGui
local billboard = script.Parent
local startOffset = billboard.StudsOffset
local glowStroke = billboard.Frame:FindFirstChild("GlowStroke", true)

-- Calculate bob amount as percentage of height (10% of the Y offset)
local bobHeight = math.abs(startOffset.Y) * 0.075
local bobSpeed = 2

-- Bobbing animation
task.spawn(function()
	local time = 0
	while billboard and billboard.Parent do
		time = time + task.wait(0.03)
		local offset = math.sin(time * bobSpeed) * bobHeight
		billboard.StudsOffset = startOffset + Vector3.new(0, offset, 0)
	end
end)

-- Pulsing glow animation
if glowStroke then
	task.spawn(function()
		while glowStroke and glowStroke.Parent do
			for i = 0.3, 0.7, 0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
			for i = 0.7, 0.3, -0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
		end
	end)
end
wFmG|S|Script
local parent = script.Parent
task.spawn(function()
	while true do
		parent.Rotation += 2.5
		task.wait()
	end
end)
wFmG|S|Script
-- LocalScript inside YourBaseIndicator BillboardGui
local billboard = script.Parent
local startOffset = billboard.StudsOffset
local glowStroke = billboard.Frame:FindFirstChild("GlowStroke", true)

-- Calculate bob amount as percentage of height (10% of the Y offset)
local bobHeight = math.abs(startOffset.Y) * 0.075
local bobSpeed = 2

-- Bobbing animation
task.spawn(function()
	local time = 0
	while billboard and billboard.Parent do
		time = time + task.wait(0.03)
		local offset = math.sin(time * bobSpeed) * bobHeight
		billboard.StudsOffset = startOffset + Vector3.new(0, offset, 0)
	end
end)

-- Pulsing glow animation
if glowStroke then
	task.spawn(function()
		while glowStroke and glowStroke.Parent do
			for i = 0.3, 0.7, 0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
			for i = 0.7, 0.3, -0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
		end
	end)
end
wFmG|S|Script
local parent = script.Parent
task.spawn(function()
	while true do
		parent.Rotation += 2.5
		task.wait()
	end
end)
wmG|S|Script
-- LocalScript inside YourBaseIndicator BillboardGui
local billboard = script.Parent
local startOffset = billboard.StudsOffset
local glowStroke = billboard.Frame:FindFirstChild("GlowStroke", true)

-- Calculate bob amount as percentage of height (10% of the Y offset)
local bobHeight = math.abs(startOffset.Y) * 0.075
local bobSpeed = 2

-- Bobbing animation
task.spawn(function()
	local time = 0
	while billboard and billboard.Parent do
		time = time + task.wait(0.03)
		local offset = math.sin(time * bobSpeed) * bobHeight
		billboard.StudsOffset = startOffset + Vector3.new(0, offset, 0)
	end
end)

-- Pulsing glow animation
if glowStroke then
	task.spawn(function()
		while glowStroke and glowStroke.Parent do
			for i = 0.3, 0.7, 0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
			for i = 0.7, 0.3, -0.02 do
				if not glowStroke or not glowStroke.Parent then break end
				glowStroke.Transparency = i
				task.wait(0.03)
			end
		end
	end)
end
wmG|S|Script
local parent = script.Parent
task.spawn(function()
	while true do
		parent.Rotation += 2.5
		task.wait()
	end
end)
s|L|carryUpgradeClient
-- Put this in StarterPlayer > StarterPlayerScripts
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for the proximity prompt (adjust the path to where your proximity prompt is)
local workspace = game:GetService("Workspace")
local proximityPrompt = workspace.Environment.Shops:WaitForChild("WeaponsUpgradesShop"):WaitForChild("WeaponsStation"):WaitForChild("ProximityPrompt") -- Change this path!

-- Create the GUI
local function createUpgradeGui()
	local screenGui = playerGui:WaitForChild("BrainrotUpgradeGui")



	local mainFrame = screenGui:WaitForChild("MainFrame")

	-- Add corner radius
	local corner = mainFrame.UICorner

	-- Title
	local title = mainFrame.Title

	-- Current capacity display
	local capacityLabel = mainFrame.CapacityLabel

	-- Cost display
	local costLabel = mainFrame.CostLabel

	-- Upgrade button
	local upgradeButton = mainFrame.UpgradeButton
	

	local upgradeCorner = mainFrame.UICorner
	
	-- Close button
	local closeButton = mainFrame.CloseButton

	local closeCorner = closeButton.UICorner

	-- Status message
	local statusLabel = mainFrame.StatusLabel

	return screenGui
end

-- Get or create the GUI
local upgradeGui = playerGui:FindFirstChild("BrainrotUpgradeGui") or createUpgradeGui()

-- Update the GUI with current stats
local function updateGui()
	local currentCapacity = player:GetAttribute("BrainrotCapacity") or 1
	local upgradeCost = player:GetAttribute("NextUpgradeCost") or 100

	local capacityLabel = upgradeGui.MainFrame.CapacityLabel
	local costLabel = upgradeGui.MainFrame.CostLabel

	capacityLabel.Text = "Current Capacity: " .. currentCapacity
	costLabel.Text = "Next Upgrade Cost: $" .. upgradeCost
end

-- When proximity prompt is triggered
proximityPrompt.Triggered:Connect(function()
	upgradeGui.Enabled = not upgradeGui.Enabled

	if upgradeGui.Enabled then
		updateGui()
		upgradeGui.MainFrame.StatusLabel.Text = ""
	end
end)

-- Close button
upgradeGui.MainFrame.CloseButton.MouseButton1Click:Connect(function()
	upgradeGui.Enabled = false
end)

-- Upgrade button
upgradeGui.MainFrame.UpgradeButton.MouseButton1Click:Connect(function()
	-- Fire to server
	local upgradeEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("UpgradeBrainrotCapacity")
	upgradeEvent:FireServer()
end)

-- Listen for server response
local upgradeEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("UpgradeBrainrotCapacity")
upgradeEvent.OnClientEvent:Connect(function(success, message)
	local statusLabel = upgradeGui.MainFrame.StatusLabel

	if success then
		statusLabel.Text = "âœ“ " .. message
		statusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
		updateGui()
	else
		statusLabel.Text = "âœ• " .. message
		statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
	end

	-- Clear message after 3 seconds
	task.delay(3, function()
		if statusLabel then
			statusLabel.Text = ""
		end
	end)
end)

print("âœ… Brainrot Upgrade GUI loaded!")
s|L|SlotSystem
-- Put this in StarterPlayer > StarterPlayerScripts
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

-- Wait for RemoteEvents
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local placeBrainrotEvent = remoteEvents:WaitForChild("PlaceBrainrotEvent")
local collectIncomeEvent = remoteEvents:WaitForChild("CollectIncomeEvent")

-- Listen for place brainrot responses (just console logging now)
placeBrainrotEvent.OnClientEvent:Connect(function(success, message)
	if success then
		print("âœ… " .. message)
	else
		print("âŒ"  .. message)
	end
end)

-- Listen for collect income responses (just console logging now)
collectIncomeEvent.OnClientEvent:Connect(function(success, message, amount)
	if success then
		print("ðŸ’° " .. message)
	else
		print("âŒ " .. message)
	end
end)

print("âœ… Brainrot Slot Client System loaded!")
s|L|BrainrotPlaceTest
-- Put this in StarterPlayer > StarterPlayerScripts > TestPlaceBrainrot
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for RemoteEvent
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local placeBrainrotEvent = remoteEvents:WaitForChild("PlaceBrainrotEvent")

-- Create a simple test GUI

local gui = playerGui:WaitForChild("TestPlaceGui")
local placeButton = gui.PlaceButton

-- Function to find the nearest slot
local function findNearestSlot()
	local character = player.Character
	if not character or not character.PrimaryPart then return nil end

	local playerPos = character.PrimaryPart.Position
	local nearestSlot = nil
	local nearestDistance = 50 -- Max distance

	local basesFolder = Workspace:FindFirstChild("BrainrotBases")
	if not basesFolder then 
		warn("BrainrotBases folder not found!")
		return nil 
	end

	for _, base in pairs(basesFolder:GetChildren()) do
		if base:IsA("Model") then
			for _, slot in pairs(base:GetChildren()) do
				if slot:IsA("Model") and slot.Name:match("Slot") then
					local displayPos = slot:FindFirstChild("DisplayPosition")
					if displayPos then
						local distance = (displayPos.Position - playerPos).Magnitude
						if distance < nearestDistance then
							nearestDistance = distance
							nearestSlot = slot
						end
					end
				end
			end
		end
	end

	return nearestSlot, nearestDistance
end

-- Button click handler
placeButton.MouseButton1Click:Connect(function()
	print("ðŸ”˜ Place button clicked!")

	local nearestSlot, distance = findNearestSlot()

	if nearestSlot then
		print("ðŸ“ Nearest slot:", nearestSlot.Name, "| Distance:", math.floor(distance), "studs")
		placeButton.Text = "PLACING..."
		placeButton.BackgroundColor3 = Color3.fromRGB(255, 150, 0)

		-- Fire to server
		placeBrainrotEvent:FireServer(nearestSlot)

		task.wait(0.5)
		placeButton.Text = "PLACE BRAINROT"
		placeButton.BackgroundColor3 = Color3.fromRGB(50, 150, 255)
	else
		print("âŒ No slot nearby (must be within 50 studs)")
		placeButton.Text = "NO SLOT NEARBY!"
		placeButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)

		task.wait(1)
		placeButton.Text = "PLACE BRAINROT"
		placeButton.BackgroundColor3 = Color3.fromRGB(50, 150, 255)
	end
end)

print("âœ… Test Place Brainrot GUI loaded! Click the blue button to place.")
s|L|SellNotification
-- Put this in StarterPlayer/StarterPlayerScripts/SellNotificationHandler
-- This is a LocalScript (CLIENT-SIDE)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local NumberFormat = require(ReplicatedStorage:WaitForChild("NumberFormat"))

-- Create notification GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "SellNotifications"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Container for notifications (stacks them vertically)
local notificationContainer = Instance.new("Frame")
notificationContainer.Name = "NotificationContainer"
notificationContainer.Size = UDim2.new(0, 300, 0, 0)
notificationContainer.Position = UDim2.new(1, -320, 0, 20)
notificationContainer.BackgroundTransparency = 1
notificationContainer.Parent = screenGui

local listLayout = Instance.new("UIListLayout")
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Padding = UDim.new(0, 10)
listLayout.Parent = notificationContainer

-- Function to show sell notification
local function showSellNotification(brainrotName, amount, rarity)
	local notification = Instance.new("Frame")
	notification.Size = UDim2.new(1, 0, 0, 80)
	notification.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	notification.BorderSizePixel = 0
	notification.BackgroundTransparency = 0
	notification.Parent = notificationContainer

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = notification

	-- Sold text
	local soldLabel = Instance.new("TextLabel")
	soldLabel.Size = UDim2.new(1, -20, 0, 25)
	soldLabel.Position = UDim2.new(0, 10, 0, 5)
	soldLabel.BackgroundTransparency = 1
	soldLabel.Text = "SOLD!"
	soldLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
	soldLabel.TextSize = 18
	soldLabel.Font = Enum.Font.GothamBold
	soldLabel.TextXAlignment = Enum.TextXAlignment.Left
	soldLabel.Parent = notification

	-- Brainrot name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, -20, 0, 20)
	nameLabel.Position = UDim2.new(0, 10, 0, 28)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = brainrotName
	nameLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	nameLabel.TextSize = 14
	nameLabel.Font = Enum.Font.Gotham
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
	nameLabel.Parent = notification

	-- Money amount
	local moneyLabel = Instance.new("TextLabel")
	moneyLabel.Size = UDim2.new(1, -20, 0, 25)
	moneyLabel.Position = UDim2.new(0, 10, 0, 50)
	moneyLabel.BackgroundTransparency = 1
	moneyLabel.Text = "+$" .. NumberFormat.format(amount)
	moneyLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
	moneyLabel.TextSize = 20
	moneyLabel.Font = Enum.Font.GothamBold
	moneyLabel.TextXAlignment = Enum.TextXAlignment.Left
	moneyLabel.Parent = notification

	-- Slide in animation
	notification.Position = UDim2.new(1, 0, 0, 0)
	notification:TweenPosition(
		UDim2.new(0, 0, 0, 0),
		Enum.EasingDirection.Out,
		Enum.EasingStyle.Back,
		0.3,
		true
	)

	-- Auto-remove after 3 seconds
	task.delay(3, function()
		if notification and notification.Parent then
			notification:TweenPosition(
				UDim2.new(1, 0, 0, 0),
				Enum.EasingDirection.In,
				Enum.EasingStyle.Back,
				0.3,
				true,
				function()
					notification:Destroy()
				end
			)
		end
	end)
end

-- Listen for ProximityPrompt triggers to show notifications
workspace.DescendantAdded:Connect(function(descendant)
	if descendant:IsA("ProximityPrompt") and descendant.Name == "SellPrompt" then
		descendant.Triggered:Connect(function(playerWhoTriggered)
			if playerWhoTriggered == player then
				local brainrot = descendant.Parent.Parent
				if brainrot and brainrot:IsA("Model") then
					local rarity = brainrot:GetAttribute("Rarity") or "Common"
					local sellPrice = tonumber(descendant.ActionText:match("%d+")) or 0

					showSellNotification(brainrot.Name, sellPrice, rarity)
				end
			end
		end)
	end
end)

-- Check existing prompts
for _, descendant in pairs(workspace:GetDescendants()) do
	if descendant:IsA("ProximityPrompt") and descendant.Name == "SellPrompt" then
		descendant.Triggered:Connect(function(playerWhoTriggered)
			if playerWhoTriggered == player then
				local brainrot = descendant.Parent.Parent
				if brainrot and brainrot:IsA("Model") then
					local rarity = brainrot:GetAttribute("Rarity") or "Common"
					local sellPrice = tonumber(descendant.ActionText:match("%d+")) or 0

					showSellNotification(brainrot.Name, sellPrice, rarity)
				end
			end
		end)
	end
end

print("âœ… Sell Notification System loaded!")
s|L|FindBase
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local basesFolder = Workspace:WaitForChild("BrainrotBases")
local INDICATOR_NAME = "YourBaseIndicator" -- Must match exactly

local function updateBaseVisuals(base)
	-- Safely check if the parts exist yet
	local spawnLocation = base:FindFirstChild("SpawnLocation")
	if not spawnLocation then return end

	local indicator = spawnLocation:FindFirstChild(INDICATOR_NAME)
	if not indicator then return end

	local ownerValue = base:FindFirstChild("Owner")
	local ownerName = ownerValue and ownerValue.Value or ""

	-- LOGIC: Only enable it if I own it. Otherwise, hide it.
	if ownerName == player.Name then
		indicator.Enabled = true
		print("âœ… Showing base indicator for " .. base.Name)
	else
indicator.Enabled = false
	end
end

local function setupBase(base)
	-- 1. Try to update immediately
	updateBaseVisuals(base)

	-- 2. Listen for Ownership changes (When you claim the base)
	local ownerValue = base:WaitForChild("Owner", 10)
	if ownerValue then
		ownerValue.Changed:Connect(function()
			updateBaseVisuals(base)
		end)
	end

	-- 3. Listen for the Indicator loading in (In case of lag/streaming)
	local spawnLocation = base:WaitForChild("SpawnLocation", 10)
	if spawnLocation then
		spawnLocation.ChildAdded:Connect(function(child)
			if child.Name == INDICATOR_NAME then
				updateBaseVisuals(base)
			end
		end)

		-- Also check if indicator was already there inside spawnLocation
		updateBaseVisuals(base)
	end
end

-- Initialize existing bases
for _, base in pairs(basesFolder:GetChildren()) do
	setupBase(base)
end

-- Initialize future bases (if they are added later)
basesFolder.ChildAdded:Connect(setupBase)
s|L|BaseUpgradeClient
-- StarterPlayer/StarterPlayerScripts/BaseUpgradeClient
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- Wait for RemoteEvent
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents", 10)
if not remoteEvents then
	warn("RemoteEvents folder not found!")
	return
end

local upgradeBaseEvent = remoteEvents:WaitForChild("UpgradeBaseEvent", 10)
if not upgradeBaseEvent then
	warn("UpgradeBaseEvent not found!")
	return
end

-- Create UI for notifications
local playerGui = player:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "UpgradeNotifications"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-- Function to show notification
local function showNotification(success, message)
	local notification = Instance.new("Frame")
	notification.Size = UDim2.new(0, 400, 0, 80)
	notification.Position = UDim2.new(0.5, -200, 0.1, 0)
	notification.BackgroundColor3 = success and Color3.fromRGB(40, 180, 40) or Color3.fromRGB(180, 40, 40)
	notification.BorderSizePixel = 0
	notification.Parent = screenGui

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = notification

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -20, 1, -20)
	label.Position = UDim2.new(0, 10, 0, 10)
	label.BackgroundTransparency = 1
	label.Text = message
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.TextSize = 20
	label.Font = Enum.Font.SourceSansBold
	label.TextWrapped = true
	label.Parent = notification

	-- Animate in
	notification.BackgroundTransparency = 1
	label.TextTransparency = 1

	local tweenService = game:GetService("TweenService")
	local tweenIn = tweenService:Create(notification, TweenInfo.new(0.3), {BackgroundTransparency = 0})
	local tweenInText = tweenService:Create(label, TweenInfo.new(0.3), {TextTransparency = 0})

	tweenIn:Play()
	tweenInText:Play()

	-- Wait then fade out
	task.wait(3)

	local tweenOut = tweenService:Create(notification, TweenInfo.new(0.5), {
		BackgroundTransparency = 1,
		Position = UDim2.new(0.5, -200, 0, 0)
	})
	local tweenOutText = tweenService:Create(label, TweenInfo.new(0.5), {TextTransparency = 1})

	tweenOut:Play()
	tweenOutText:Play()

	tweenOut.Completed:Connect(function()
		notification:Destroy()
	end)
end

-- Listen for upgrade events
upgradeBaseEvent.OnClientEvent:Connect(function(success, message)
	showNotification(success, message)
end)

print("âœ… BaseUpgradeClient loaded!")
s|L|BounceNotifClient
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
-- Wait for your specific GUI
local purchaseGui = playerGui:WaitForChild("PurchaseGui") 
-- Wait for the new Green Frame you just made
local bounceFrame = purchaseGui:WaitForChild("BounceFrame") 

local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local bounceEvent = remoteEvents:WaitForChild("BounceNotif")

-- Animation State Variables
local currentTween = nil
local hideTask = nil

local function playBounceNotification()
	-- 1. CANCEL OLD TIMERS
	if hideTask then
		task.cancel(hideTask)
		hideTask = nil
	end

	-- 2. STOP CURRENT MOTION
	if currentTween then
		currentTween:Cancel()
	end

	-- 3. RESET (Make sure it's visible and on top)
	bounceFrame.Visible = true
	bounceFrame.ZIndex = 101 -- Higher than everything else

	-- If frame is currently hidden (off screen), reset to start position
	if bounceFrame.Position.Y.Scale < 0 then
		bounceFrame.Position = UDim2.new(0.5, 0,-0.007, 0)
	end

	-- DROP ANIMATION (Elastic Out)
	local dropInfo = TweenInfo.new(
		1.2, 
		Enum.EasingStyle.Elastic, 
		Enum.EasingDirection.Out
	)

	currentTween = TweenService:Create(bounceFrame, dropInfo, {
		Position = UDim2.new(0.5, 0, 0.075, 0)
	})
	currentTween:Play()

	-- 4. WAIT & HIDE
	hideTask = task.spawn(function()
		task.wait(2.5) -- Kept it long enough to read the long text

		local upInfo = TweenInfo.new(
			0.6,
			Enum.EasingStyle.Back,
			Enum.EasingDirection.In
		)

		currentTween = TweenService:Create(bounceFrame, upInfo, {
			Position = UDim2.new(0.5, 0, -0.3, 0)
		})
		currentTween:Play()
		currentTween.Completed:Wait()

		bounceFrame.Visible = false
		hideTask = nil
		currentTween = nil
	end)
end

-- Listen for the Server to tell us to play the animation
bounceEvent.OnClientEvent:Connect(playBounceNotification)
s|L|LocalScript
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local purchaseGui = playerGui:WaitForChild("PurchaseGui")
-- The new Red Frame
local capacityFrame = purchaseGui:WaitForChild("CapacityFrame") 

local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local capacityEvent = remoteEvents:WaitForChild("CapacityFullEvent")

-- Animation State Variables
local currentTween = nil
local hideTask = nil

local function playCapacityNotification()
	-- 1. CANCEL OLD TIMERS
	if hideTask then
		task.cancel(hideTask)
		hideTask = nil
	end

	-- 2. STOP CURRENT MOTION
	if currentTween then
		currentTween:Cancel()
	end

	-- 3. RESET
	capacityFrame.Visible = true
	capacityFrame.ZIndex = 102 -- Highest priority (above bounce)

	-- If frame is currently hidden (off screen), reset to start position
	if capacityFrame.Position.Y.Scale < 0 then
		capacityFrame.Position = UDim2.new(0.5, 0, -0.3, 0)
	end

	-- DROP ANIMATION (Elastic Out)
	local dropInfo = TweenInfo.new(
		1.2, 
		Enum.EasingStyle.Elastic, 
		Enum.EasingDirection.Out
	)

	currentTween = TweenService:Create(capacityFrame, dropInfo, {
		Position = UDim2.new(0.5, 0, 0.15, 0)
	})
	currentTween:Play()

	-- 4. WAIT & HIDE
	hideTask = task.spawn(function()
		task.wait(2.5) 

		local upInfo = TweenInfo.new(
			0.6,
			Enum.EasingStyle.Back,
			Enum.EasingDirection.In
		)

		currentTween = TweenService:Create(capacityFrame, upInfo, {
			Position = UDim2.new(0.5, 0, -0.3, 0)
		})
		currentTween:Play()
		currentTween.Completed:Wait()

		capacityFrame.Visible = false
		hideTask = nil
		currentTween = nil
	end)
end

capacityEvent.OnClientEvent:Connect(playCapacityNotification)
s|L|RebirthLocks
-- Put this in StarterPlayer/StarterPlayerScripts/BrainrotLockHandler
-- This is a LocalScript (CLIENT-SIDE)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local leaderstats = player:WaitForChild("leaderstats")
local rebirths = leaderstats:WaitForChild("Rebirths")

-- Rebirth requirements matching spawning system
local RARITY_REQUIREMENTS = {
	["Common"] = 0,
	["Rare"] = 1,
	["Epic"] = 3,
	["Legendary"] = 5,
	["Mythic"] = 10,
	["Brainrot God"] = 25,
	["Secret"] = 50,
	["OG"] = 100,
}

-- Store original visuals before applying monochrome
local originalVisuals = {}

local function storeBrainrotVisuals(brainrot)
	if originalVisuals[brainrot] then return end

	local visualData = {}
	for _, descendant in pairs(brainrot:GetDescendants()) do
		if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
			visualData[descendant] = {
				Color = descendant.Color,
				Material = descendant.Material,
				Reflectance = descendant.Reflectance,
			}
		end
	end
	originalVisuals[brainrot] = visualData
end

local function applyMonochrome(brainrot)
	for _, descendant in pairs(brainrot:GetDescendants()) do
		if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
			local originalColor = descendant.Color
			local gray = (originalColor.R + originalColor.G + originalColor.B) / 3
			descendant.Color = Color3.new(gray, gray, gray)
		end
	end
end

local function restoreOriginalVisuals(brainrot)
	local visualData = originalVisuals[brainrot]
	if not visualData then return end

	for part, data in pairs(visualData) do
		if part and part.Parent then
			part.Color = data.Color
			part.Material = data.Material
			part.Reflectance = data.Reflectance
		end
	end
end

local function updateBrainrotLockStatus(brainrot)
	local requirement = brainrot:GetAttribute("RebirthRequirement") or 0
	local currentRebirths = rebirths.Value
	local isLocked = currentRebirths < requirement

	-- Update lock attribute
	brainrot:SetAttribute("IsLocked", isLocked)

	if isLocked then
		-- Lock: store originals and apply grayscale
		storeBrainrotVisuals(brainrot)
		applyMonochrome(brainrot)

		-- CRITICAL: Remove SurfaceAppearance to allow grayscale to show
		for _, descendant in pairs(brainrot:GetDescendants()) do
			if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
				local surfaceAppearance = descendant:FindFirstChildOfClass("SurfaceAppearance")
				if surfaceAppearance then
					-- Store it so we can restore later
					if not originalVisuals[brainrot].surfaceAppearances then
						originalVisuals[brainrot].surfaceAppearances = {}
					end
					originalVisuals[brainrot].surfaceAppearances[descendant] = surfaceAppearance:Clone()
					surfaceAppearance:Destroy()
				end
				descendant.CanTouch = false
			end
		end
	else
		-- Unlock: restore original colors
		restoreOriginalVisuals(brainrot)

		-- Restore SurfaceAppearances if they existed
		if originalVisuals[brainrot] and originalVisuals[brainrot].surfaceAppearances then
			for part, surfaceAppearance in pairs(originalVisuals[brainrot].surfaceAppearances) do
				if part and part.Parent then
					surfaceAppearance:Clone().Parent = part
				end
			end
		end

		-- Make touchable again
		for _, descendant in pairs(brainrot:GetDescendants()) do
			if descendant:IsA("BasePart") then
				descendant.CanTouch = true
			end
		end

		-- Update nametag to remove lock indicator
		local statsGUI = brainrot:FindFirstChild("StatsGUI")
		if statsGUI then
			local container = statsGUI:FindFirstChild("Frame")
			if container then
				for _, child in pairs(container:GetChildren()) do
					if child:IsA("TextLabel") and child.Text:find("ðŸ”’") then
						child:Destroy()
					end
				end
			end
		end
	end
end

local function scanAllBrainrots()
	for _, obj in pairs(workspace:GetDescendants()) do
		if obj:IsA("Model") and obj:GetAttribute("Rarity") and obj:GetAttribute("RebirthRequirement") then
			updateBrainrotLockStatus(obj)
		end
	end
end

-- Initial scan
task.wait(1) -- Wait for brainrots to spawn
scanAllBrainrots()

-- Update when rebirths change
rebirths:GetPropertyChangedSignal("Value"):Connect(function()
	print("ðŸ”“ Rebirth count changed to " .. rebirths.Value .. " - checking locks...")
	scanAllBrainrots()
end)

-- Watch for new brainrots spawning
workspace.DescendantAdded:Connect(function(descendant)
	if descendant:IsA("Model") and descendant:GetAttribute("Rarity") then
		task.wait(0.2) -- Wait for all attributes to be set
		if descendant:GetAttribute("RebirthRequirement") then
			updateBrainrotLockStatus(descendant)
		end
	end
end)

-- Cleanup when brainrots are removed
workspace.DescendantRemoving:Connect(function(descendant)
	if originalVisuals[descendant] then
		originalVisuals[descendant] = nil
	end
end)

print("âœ… Brainrot Lock Handler (Client) loaded!")
s|L|WeatherUI
-- WeatherUI (LocalScript) -- place in StarterPlayerScripts
-- Shows a weather announcement banner when weather changes.
-- Optionally tints the sky to match the weather colour.

local Players           = game:GetService("Players")
local TweenService      = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player    = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for remotes
local Remotes             = ReplicatedStorage:WaitForChild("RemoteEvents")
local weatherChangedEvent = Remotes:WaitForChild("WeatherChanged")
local getWeatherFunc      = Remotes:WaitForChild("GetCurrentWeather")
local mutationAnnouncedEvent = Remotes:WaitForChild("MutationAnnounced")

local Lighting = game:GetService("Lighting")

-- Create or grab the ColorCorrection effect
local colorCorrection = Lighting:FindFirstChildOfClass("ColorCorrectionEffect")
if not colorCorrection then
	colorCorrection = Instance.new("ColorCorrectionEffect")
	colorCorrection.Name = "WeatherTint"
	colorCorrection.Parent = Lighting
end

local CLEAR_SKY_COLOR = Color3.new(1, 1, 1)  -- neutral/no tint

local skyTweenInfo = TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
local currentSkyTween = nil

local function setSkyColor(color)
	if currentSkyTween then currentSkyTween:Cancel() end
	currentSkyTween = TweenService:Create(colorCorrection, skyTweenInfo, { TintColor = color })
	currentSkyTween:Play()
end





-- ============================================================
--  BUILD THE WEATHER BANNER GUI
-- ============================================================
local screenGui = Instance.new("ScreenGui")
screenGui.Name            = "WeatherUI"
screenGui.ResetOnSpawn    = false
screenGui.IgnoreGuiInset  = true
screenGui.Parent          = playerGui

-- Banner frame (slides in from top)
local banner = Instance.new("Frame")
banner.Name              = "WeatherBanner"
banner.Size              = UDim2.new(0, 420, 0, 90)
banner.AnchorPoint       = Vector2.new(0.5, 0)
banner.Position          = UDim2.new(0.5, 0, 0, -100)  -- starts off-screen
banner.BackgroundColor3  = Color3.fromRGB(20, 20, 20)
banner.BackgroundTransparency = 0.25
banner.BorderSizePixel   = 0
banner.Parent            = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 14)
corner.Parent = banner

local stroke = Instance.new("UIStroke")
stroke.Color       = Color3.fromRGB(255, 255, 255)
stroke.Thickness   = 2
stroke.Transparency = 0.6
stroke.Parent = banner

-- Weather name label
local nameLabel = Instance.new("TextLabel")
nameLabel.Name              = "WeatherName"
nameLabel.Size              = UDim2.new(1, -20, 0.55, 0)
nameLabel.Position          = UDim2.new(0, 10, 0, 6)
nameLabel.BackgroundTransparency = 1
nameLabel.Text              = "â˜€ï¸ Clear"
nameLabel.Font              = Enum.Font.FredokaOne
nameLabel.TextScaled        = true
nameLabel.TextColor3        = Color3.new(1, 1, 1)
nameLabel.TextXAlignment    = Enum.TextXAlignment.Center
nameLabel.Parent            = banner

local nameConstraint = Instance.new("UITextSizeConstraint")
nameConstraint.MaxTextSize = 28
nameConstraint.Parent = nameLabel

-- Description label
local descLabel = Instance.new("TextLabel")
descLabel.Name              = "Description"
descLabel.Size              = UDim2.new(1, -20, 0.38, 0)
descLabel.Position          = UDim2.new(0, 10, 0.58, 0)
descLabel.BackgroundTransparency = 1
descLabel.Text              = ""
descLabel.Font              = Enum.Font.SourceSans
descLabel.TextScaled        = true
descLabel.TextColor3        = Color3.fromRGB(220, 220, 220)
descLabel.TextXAlignment    = Enum.TextXAlignment.Center
descLabel.Parent            = banner

local descConstraint = Instance.new("UITextSizeConstraint")
descConstraint.MaxTextSize = 18
descConstraint.Parent = descLabel

-- ============================================================
--  TIMER BAR (shows how long the weather lasts)
-- ============================================================
local timerBar = Instance.new("Frame")
timerBar.Name              = "TimerBar"
timerBar.Size              = UDim2.new(0.95, 0, 0, 5)
timerBar.Position          = UDim2.new(0.025, 0, 1, -8)
timerBar.AnchorPoint       = Vector2.new(0, 0)
timerBar.BackgroundColor3  = Color3.new(1, 1, 1)
timerBar.BackgroundTransparency = 0.4
timerBar.BorderSizePixel   = 0
timerBar.Parent            = banner

local timerCorner = Instance.new("UICorner")
timerCorner.CornerRadius = UDim.new(1, 0)
timerCorner.Parent = timerBar

-- ============================================================
--  PERSISTENT WEATHER INDICATOR (small icon top-right)
-- ============================================================
local indicator = Instance.new("Frame")
indicator.Name              = "WeatherIndicator"
indicator.Size              = UDim2.new(0, 160, 0, 44)
indicator.AnchorPoint       = Vector2.new(1, 0)
indicator.Position          = UDim2.new(1, -10, 0, 10)
indicator.BackgroundColor3  = Color3.fromRGB(20, 20, 20)
indicator.BackgroundTransparency = 0.35
indicator.BorderSizePixel   = 0
indicator.Parent            = screenGui

local indCorner = Instance.new("UICorner")
indCorner.CornerRadius = UDim.new(0, 10)
indCorner.Parent = indicator

local indLabel = Instance.new("TextLabel")
indLabel.Size               = UDim2.new(1, -8, 1, 0)
indLabel.Position           = UDim2.new(0, 4, 0, 0)
indLabel.BackgroundTransparency = 1
indLabel.Text               = "â˜€ï¸ Clear"
indLabel.Font               = Enum.Font.FredokaOne
indLabel.TextScaled         = true
indLabel.TextColor3         = Color3.new(1, 1, 1)
indLabel.TextXAlignment     = Enum.TextXAlignment.Center
indLabel.Parent             = indicator

local indConstraint = Instance.new("UITextSizeConstraint")
indConstraint.MaxTextSize = 16
indConstraint.Parent = indLabel

-- ============================================================
--  ANIMATION HELPERS
-- ============================================================
local tweenInfo_in  = TweenInfo.new(0.5, Enum.EasingStyle.Back,   Enum.EasingDirection.Out)
local tweenInfo_out = TweenInfo.new(0.4, Enum.EasingStyle.Quad,   Enum.EasingDirection.In)

local currentTimerThread = nil

local function showBanner(displayName, color, description, duration)
	-- Update text
	nameLabel.Text  = displayName
	descLabel.Text  = description
	nameLabel.TextColor3 = color
	stroke.Color         = color

	-- Slide in
	banner.Position = UDim2.new(0.5, 0, 0, -100)
	local tweenIn = TweenService:Create(banner, tweenInfo_in,
		{ Position = UDim2.new(0.5, 0, 0, 16) })
	tweenIn:Play()

	-- Timer bar countdown
	timerBar.Size = UDim2.new(0.95, 0, 0, 5)
	timerBar.BackgroundColor3 = color

	if currentTimerThread then task.cancel(currentTimerThread) end
	currentTimerThread = task.spawn(function()
		local startTime = os.clock()
		while os.clock() - startTime < duration do
			local elapsed  = os.clock() - startTime
			local fraction = math.max(0, 1 - (elapsed / duration))
			timerBar.Size = UDim2.new(0.95 * fraction, 0, 0, 5)
			task.wait(0.1)
		end
		-- Slide out when done
		local tweenOut = TweenService:Create(banner, tweenInfo_out,
			{ Position = UDim2.new(0.5, 0, 0, -100) })
		tweenOut:Play()
	end)
end

-- ============================================================
--  HOOK UP TO WEATHER EVENTS
-- ============================================================
weatherChangedEvent.OnClientEvent:Connect(function(weatherName, displayName, color, description, duration)
	indLabel.Text       = displayName
	indLabel.TextColor3 = color

	if weatherName == "Clear" then
		setSkyColor(CLEAR_SKY_COLOR)  -- â† ADD THIS

		local tweenOut = TweenService:Create(banner, tweenInfo_out,
			{ Position = UDim2.new(0.5, 0, 0, -100) })
		tweenOut:Play()
		if currentTimerThread then
			task.cancel(currentTimerThread)
			currentTimerThread = nil
		end
	else
		setSkyColor(color)            -- â† ADD THIS
		showBanner(displayName, color, description, duration)
	end
end)

-- ============================================================
--  SHOW CURRENT WEATHER ON JOIN
-- ============================================================
task.spawn(function()
	task.wait(1)
	local ok, weatherName, data = pcall(function()
		return getWeatherFunc:InvokeServer()
	end)
	if ok and weatherName and data then
		indLabel.Text       = data.displayName
		indLabel.TextColor3 = data.color
		setSkyColor(weatherName ~= "Clear" and data.color or CLEAR_SKY_COLOR)  -- â† ADD THIS
		if weatherName ~= "Clear" then
			local remaining = math.max(0, WeatherSystem and WeatherSystem._weatherEndTime - os.time() or 60)
			showBanner(data.displayName, data.color, data.description, remaining)
		end
	end
end)
mutationAnnouncedEvent.OnClientEvent:Connect(function(brainrotName, mutationName, mutColor)
	-- Create the Notification "Toast"
	local toast = Instance.new("TextLabel")
	toast.Size = UDim2.new(0, 320, 0, 45)
	toast.Position = UDim2.new(1, 10, 1, -80) -- Starts off-screen to the right
	toast.AnchorPoint = Vector2.new(1, 1)
	toast.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	toast.BackgroundTransparency = 0.15
	toast.Font = Enum.Font.GothamBold
	toast.TextSize = 16
	toast.Text = string.format("âœ¨ A %s gained the %s mutation!", brainrotName, mutationName)
	toast.TextColor3 = mutColor

	local stroke = Instance.new("UIStroke")
	stroke.Thickness = 2
	stroke.Color = Color3.new(1, 1, 1)
	stroke.Parent = toast

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = toast

	-- Put it in the existing WeatherUI (or directly in a ScreenGui)
	local screenGui = playerGui:FindFirstChild("WeatherUI")
	if not screenGui then
		screenGui = Instance.new("ScreenGui")
		screenGui.Name = "WeatherUI"
		screenGui.Parent = playerGui
	end
	toast.Parent = screenGui

	-- Slide In Animation
	TweenService:Create(toast, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Position = UDim2.new(1, -15, 1, -80)
	}):Play()

	-- Wait 3 seconds, Slide Out, and Destroy
	task.delay(3, function()
		local tweenOut = TweenService:Create(toast, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			Position = UDim2.new(1, 10, 1, -80)
		})
		tweenOut:Play()
		tweenOut.Completed:Wait()
		toast:Destroy()
	end)
end)
s|L|RainScript
--!GENERATED
local Rain = require(script.Rain)
local event = game.ReplicatedStorage.RemoteEvents.StartRain

Rain:SetColor(Color3.fromRGB(script.Color.Value.x, script.Color.Value.y, script.Color.Value.z))
Rain:SetDirection(script.Direction.Value)

Rain:SetTransparency(script.Transparency.Value)
Rain:SetSpeedRatio(script.SpeedRatio.Value)
Rain:SetIntensityRatio(script.IntensityRatio.Value)
Rain:SetLightInfluence(script.LightInfluence.Value)
Rain:SetLightEmission(script.LightEmission.Value)

Rain:SetVolume(script.Volume.Value)

Rain:SetSoundId(script.SoundId.Value)
Rain:SetStraightTexture(script.StraightTexture.Value)
Rain:SetTopDownTexture(script.TopDownTexture.Value)
Rain:SetSplashTexture(script.SplashTexture.Value)

local threshold = script.TransparencyThreshold.Value
if script.TransparencyConstraint.Value and script.CanCollideConstraint.Value then
	Rain:SetCollisionMode(
		Rain.CollisionMode.Function,
		function(p)
			return p.Transparency <= threshold and p.CanCollide
		end
	)
elseif script.TransparencyConstraint.Value then
	Rain:SetCollisionMode(
		Rain.CollisionMode.Function,
		function(p)
			return p.Transparency <= threshold
		end
	)
elseif script.CanCollideConstraint.Value then
	Rain:SetCollisionMode(
		Rain.CollisionMode.Function,
		function(p)
			return p.CanCollide
		end
	)
end

event.OnClientEvent:Connect(function(israining)
	print("oseifjooassaeifooooooooooooooooooooooooooaseofiiiiiiiiiiiiiiiiiasefoiiiiiiiiiiiiiiiiiiiii")
	if israining == false then
		Rain:Enable()
		return
	else
		Rain:Disable()
	end
	
end)
s|M|Rain
--[[
	
	Rain module v1.0 by buildthomas (July 2018)
	
	This module is licensed under the APLv2:
	http://www.apache.org/licenses/LICENSE-2.0
	
	In short, you may use this code only if you agree to the following:
	* This notice must always be present and may not be modified or removed in any copy of this code or derived code.
	* You may use this in commercial, closed source projects, and you may modify the source code itself.
	
	Refer to the license for a full description.
	
	For questions please reach out on the Developer Forum (@buildthomas)
	or via Twitter (https://www.twitter.com/buildthomasRBX)
	
	------
	
	
	Rain:Enable(<TweenInfo> tweenInfo)
		Enable the rain effects instantly, or over a given easing function if tweenInfo is given.
		
	Rain:Disable(<TweenInfo> tweenInfo)
		Disable the rain effects instantly, or over a given easing function if tweenInfo is given.
		
		
	Rain:SetColor(<Color3> color, <TweenInfo> tweenInfo)
		Set the global color of all rain particles to a given Color3 value.
		Sets the color instantly, or over a given easing function if tweenInfo is given.
		Color sequences are not supported because this would lead to a messy effect.
		The starting value is RAIN_DEFAULT_COLOR.
		
	Rain:SetTransparency(<number> transparency, <TweenInfo> tweenInfo)
		Set the global transparency of all rain effects. 0 = regular visibility, 1 = fully invisible.
		Sets the transparency instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_TRANSPARENCY.
	
	Rain:SetSpeedRatio(<number> ratio, <TweenInfo> tweenInfo)
		Set the vertical falling speed of the rain particles. 0 = still, 1 = max falling speed.
		Sets the speed instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_SPEEDRATIO.
		
	Rain:SetIntensityRatio(<number> ratio, <TweenInfo> tweenInfo)
		Set the intensity of the rain. 0 = no effects, 1 = full effects.
		Sets the intensity instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_INTENSITYRATIO.
		
	Rain:SetLightEmission(<number> ratio, <TweenInfo> tweenInfo)
		Set the global light emission of all rain effects.
		Sets the light emission instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_LIGHTEMISSION.
		
	Rain:SetLightInfluence(<number> transparency, <TweenInfo> tweenInfo)
		Set the global light influence of all rain effects.
		Sets the light influence instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_LIGHTINFLUENCE.
		
		
	Rain:SetVolume(<number> volume, <TweenInfo> tweenInfo)
		Set the global max volume of rain instantly, or over a given easing function if tweenInfo is given.
		The initial volume of the rain's soundgroup is RAIN_SOUND_BASEVOLUME.
		
		
	Rain:SetCeiling(<Variant<number, nil>> ceiling)
		Set a Y coordinate that marks the ceiling of the world. Above this spot, rain will act as if it's indoors.
		Feed nil to remove any previously set ceiling.
		
		
	Rain:SetDirection(<Vector3> direction, <TweenInfo> tweenInfo)
		Set the direction that rain falls from. The direction parameter should be a unit direction.
		Sets the rain direction instantly, or over a given easing function if tweenInfo is given.
		
	Rain:SetStraightTexture(<string> asset)
	Rain:SetTopDownTexture(<string> asset)
	Rain:SetSplashTexture(<string> asset)
		Adjust textures of the rain effect.
		
	Rain:SetSoundId(<string> asset)
		Adjust sound effect of the rain effect.
		
	Rain:SetCollisionMode(<Rain.CollisionMode> mode, ...)
		Sets the current way collisions are determined for the rain.
		
		Rain.CollisionMode
			A table that should be seen as an enumerator for the collision mode.
			The following values are available:
			* Rain.CollisionMode.None			- All parts in the default collision group will block the rain.
			* Rain.CollisionMode.Whitelist		- Use the whitelist provided by Rain::SetCollisionWhitelist.
			* Rain.CollisionMode.Blacklist		- Use the blacklist provided by Rain::SetCollisionBlacklist.
			* Rain.CollisionMode.Function		- Use the test function provided by Rain::SetCollisionFunction and do deep-casts.
			
		Rain:SetCollisionMode(Rain.CollisionMode.None)
			No parameters.
			
		Rain:SetCollisionMode(Rain.CollisionMode.Whitelist, <Variant<Instance, table>> whitelist)
			The provided value can either be a hierarchy of objects or a table of objects to filter with.
		
		Rain:SetCollisionMode(Rain.CollisionMode.Blacklist, <Variant<Instance, table>> blacklist)
			The provided value can either be a hierarchy of objects or a table of objects to filter out.
			
		Rain:SetCollisionMode(Rain.CollisionMode.Function, <function<BasePart -> boolean>> f)
			If f(part) returns a value that lua evaluates to a true condition, that part can be hit by rain.
			If f(part) returns any other value, that part cannot be hit by the rain.
			
	
--]]

-- Options:

local MIN_SIZE = Vector3.new(0.05,0.05,0.05)				-- Size of main emitter part when rain inactive

local RAIN_DEFAULT_COLOR = Color3.new(1,1,1)				-- Default color3 of all rain elements
local RAIN_DEFAULT_TRANSPARENCY = 0							-- Default transparency scale ratio of all rain elements
local RAIN_DEFAULT_SPEEDRATIO = 1							-- Default speed scale ratio of falling rain effects
local RAIN_DEFAULT_INTENSITYRATIO = 1						-- Default intensity ratio of all rain elements
local RAIN_DEFAULT_LIGHTEMISSION = 0.05						-- Default LightEmission of all rain elements
local RAIN_DEFAULT_LIGHTINFLUENCE = 0.9						-- Default LightInfluence of all rain elements
local RAIN_DEFAULT_DIRECTION = Vector3.new(0,-1,0)			-- Default direction for rain to fall into

local RAIN_TRANSPARENCY_T1 = .25							-- Define the shape (time-wise) of the transparency curves for emitters
local RAIN_TRANSPARENCY_T2 = .75

local RAIN_SCANHEIGHT = 1000								-- How many studs to scan up from camera position to determine whether occluded

local RAIN_EMITTER_DIM_DEFAULT = 40							-- Size of emitter block to the side/up
local RAIN_EMITTER_DIM_MAXFORWARD = 100						-- Size of emitter block forwards when looking at the horizon
local RAIN_EMITTER_UP_MODIFIER = 20							-- Maximum vertical displacement of emitter (when looking fully up/down)

local RAIN_SOUND_ASSET = "rbxassetid://1516791621"
local RAIN_SOUND_BASEVOLUME = 0.2							-- Starting volume of rain sound effect when not occluded
local RAIN_SOUND_FADEIN_TIME = 1							-- Tween in/out times for sound volume
local RAIN_SOUND_FADEOUT_TIME = 1

local RAIN_STRAIGHT_ASSET = "rbxassetid://1822883048"		-- Some properties of the straight rain particle effect
local RAIN_STRAIGHT_ALPHA_LOW = 0.7							-- Minimum particle transparency for the straight rain emitter
local RAIN_STRAIGHT_SIZE = NumberSequence.new(10)
local RAIN_STRAIGHT_LIFETIME = NumberRange.new(0.8)
local RAIN_STRAIGHT_MAX_RATE = 600							-- Maximum rate for the straight rain emitter
local RAIN_STRAIGHT_MAX_SPEED = 60							-- Maximum speed for the straight rain emitter

local RAIN_TOPDOWN_ASSET = "rbxassetid://1822856633"		-- Some properties of the top-down rain particle effect
local RAIN_TOPDOWN_ALPHA_LOW = 0.85							-- Minimum particle transparency for the top-down rain emitter
local RAIN_TOPDOWN_SIZE = NumberSequence.new {
	NumberSequenceKeypoint.new(0, 5.33, 2.75);
	NumberSequenceKeypoint.new(1, 5.33, 2.75);
}			
local RAIN_TOPDOWN_LIFETIME = NumberRange.new(0.8)
local RAIN_TOPDOWN_ROTATION = NumberRange.new(0,360)
local RAIN_TOPDOWN_MAX_RATE = 600							-- Maximum rate for the top-down rain emitter
local RAIN_TOPDOWN_MAX_SPEED = 60							-- Maximum speed for the top-down rain emitter

local RAIN_SPLASH_ASSET = "rbxassetid://1822856633"			-- Some properties of the splash particle effect
local RAIN_SPLASH_ALPHA_LOW = 0.6							-- Minimum particle transparency for the splash emitters
local RAIN_SPLASH_SIZE = NumberSequence.new {				
	NumberSequenceKeypoint.new(0, 0);
	NumberSequenceKeypoint.new(.4, 3);
	NumberSequenceKeypoint.new(1, 0);
}
local RAIN_SPLASH_LIFETIME = NumberRange.new(0.1, 0.15)
local RAIN_SPLASH_ROTATION = NumberRange.new(0,360)
local RAIN_SPLASH_NUM = 20									-- Amount of splashes per frame
local RAIN_SPLASH_CORRECTION_Y = .5							-- Offset from impact position for visual reasons
local RAIN_SPLASH_STRAIGHT_OFFSET_Y = 50					-- Offset against rain direction for straight rain particles from splash position
local RAIN_NOSPLASH_STRAIGHT_OFFSET_Y_MIN = 20				-- Min/max vertical offset from camera height for straight rain particles
local RAIN_NOSPLASH_STRAIGHT_OFFSET_Y_MAX = 100				-- when no splash position could be found (i.e. no floor at that XZ-column)

local RAIN_OCCLUDED_MINSPEED = 70							-- Minimum speed for the occluded straight rain emitters
local RAIN_OCCLUDED_MAXSPEED = 100							-- Maximum speed for the occluded straight rain emitters
local RAIN_OCCLUDED_SPREAD = Vector2.new(10,10)				-- Spread angle for the occluded straight rain emitters
local RAIN_OCCLUDED_MAXINTENSITY = 2						-- How many occluded straight rain particles are emitted for every splash for max intensity

local RAIN_OCCLUDECHECK_OFFSET_Y = 500						-- Vertical offset from camera height to start scanning downward from for splashes
local RAIN_OCCLUDECHECK_OFFSET_XZ_MIN = -100				-- Range of possible XZ offset values from camera XZ position for the splashes
local RAIN_OCCLUDECHECK_OFFSET_XZ_MAX = 100
local RAIN_OCCLUDECHECK_SCAN_Y = 550						-- Scan magnitude along rain path

local RAIN_UPDATE_PERIOD = 6								-- Update the transparency of the main emitters + volume of rain inside every X frames

local RAIN_VOLUME_SCAN_RADIUS = 35							-- Defining grid for checking how far the camera is away from a spot exposed to rain
local RAIN_VOLUME_SCAN_GRID = {								-- Unit range grid for scanning how far away user is from rain space
	-- range 0.2, 4 pts
	Vector3.new(0.141421363, 0, 0.141421363);
	Vector3.new(-0.141421363, 0, 0.141421363);
	Vector3.new(-0.141421363, 0, -0.141421363);
	Vector3.new(0.141421363, 0, -0.141421363);
	-- range 0.4, 8 pts
	Vector3.new(0.400000006, 0, 0);
	Vector3.new(0.282842726, 0, 0.282842726);
	Vector3.new(2.44929371e-17, 0, 0.400000006);
	Vector3.new(-0.282842726, 0, 0.282842726);
	Vector3.new(-0.400000006, 0, 4.89858741e-17);
	Vector3.new(-0.282842726, 0, -0.282842726);
	Vector3.new(-7.34788045e-17, 0, -0.400000006);
	Vector3.new(0.282842726, 0, -0.282842726);
	-- range 0.6, 10 pts
	Vector3.new(0.600000024, 0, 0);
	Vector3.new(0.485410213, 0, 0.352671146);
	Vector3.new(0.185410202, 0, 0.570633948);
	Vector3.new(-0.185410202, 0, 0.570633948);
	Vector3.new(-0.485410213, 0, 0.352671146);
	Vector3.new(-0.600000024, 0, 7.34788112e-17);
	Vector3.new(-0.485410213, 0, -0.352671146);
	Vector3.new(-0.185410202, 0, -0.570633948);
	Vector3.new(0.185410202, 0, -0.570633948);
	Vector3.new(0.485410213, 0, -0.352671146);
	-- range 0.8, 12 pts
	Vector3.new(0.772740662, 0, 0.207055241);
	Vector3.new(0.565685451, 0, 0.565685451);
	Vector3.new(0.207055241, 0, 0.772740662);
	Vector3.new(-0.207055241, 0, 0.772740662);
	Vector3.new(-0.565685451, 0, 0.565685451);
	Vector3.new(-0.772740662, 0, 0.207055241);
	Vector3.new(-0.772740662, 0, -0.207055241);
	Vector3.new(-0.565685451, 0, -0.565685451);
	Vector3.new(-0.207055241, 0, -0.772740662);
	Vector3.new(0.207055241, 0, -0.772740662);
	Vector3.new(0.565685451, 0, -0.565685451);
	Vector3.new(0.772740662, 0, -0.207055241);
}


-- Enumerators:

local CollisionMode = {
	None = 0;
	Whitelist = 1;
	Blacklist = 2;
	Function = 3;
}


-- Variables & setup:

-- services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local GlobalModifier = Instance.new("NumberValue")			-- modifier for rain visibility for disabling/enabling over time span
GlobalModifier.Value = 1									-- 0 = fully visible, 1 = invisible

local connections = {}										-- Stores connections to RunService signals when enabled

local disabled = true										-- Value to figure out whether we are moving towards a disabled state (useful during tweens)

local rainDirection = RAIN_DEFAULT_DIRECTION				-- Direction that rain falls into

local currentCeiling = nil									-- Y coordinate of ceiling (if present)

local collisionMode = CollisionMode.None					-- Collision mode (from Rain.CollisionMode) for raycasting
local collisionList = nil									-- Blacklist/whitelist for raycasting
local collisionFunc = nil									-- Raycasting test function for when collisionMode == Rain.CollisionMode.Function

local straightLowAlpha = 1									-- Current transparency for straight rain particles
local topdownLowAlpha = 1									-- Current transparency for top-down rain particles
local intensityOccludedRain = 0								-- Current intensity of occluded rain particles
local numSplashes = 0										-- Current number of generated splashes per frame
local volumeTarget = 0										-- Current (target of tween for) sound volume

-- shorthands
local v3 = Vector3.new
local NSK010 = NumberSequenceKeypoint.new(0, 1, 0)
local NSK110 = NumberSequenceKeypoint.new(1, 1, 0)

local volumeScanGrid = {}									-- Pre-generate grid used for raining area distance scanning
for _,v in pairs(RAIN_VOLUME_SCAN_GRID) do
	table.insert(volumeScanGrid, v * RAIN_VOLUME_SCAN_RADIUS)
end
table.sort(volumeScanGrid, function(a,b)					-- Optimization: sort from close to far away for fast evaluation if closeby
	return a.magnitude < b.magnitude
end)

-- sound group for easy main volume tweaking
local SoundGroup = Instance.new("SoundGroup")
SoundGroup.Name = "__RainSoundGroup"
SoundGroup.Volume = RAIN_SOUND_BASEVOLUME
SoundGroup.Archivable = false

local Sound = Instance.new("Sound")
Sound.Name = "RainSound"
Sound.Volume = volumeTarget
Sound.SoundId = RAIN_SOUND_ASSET
Sound.Looped = true
Sound.SoundGroup = SoundGroup
Sound.Parent = SoundGroup
Sound.Archivable = false

-- emitter block around camera used when outside
local Emitter do
	
	Emitter = Instance.new("Part")
	Emitter.Transparency = 1
	Emitter.Anchored = true
	Emitter.CanCollide = false
	Emitter.Locked = false
	Emitter.Archivable = false
	Emitter.TopSurface = Enum.SurfaceType.Smooth
	Emitter.BottomSurface = Enum.SurfaceType.Smooth
	Emitter.Name = "__RainEmitter"
	Emitter.Size = MIN_SIZE
	Emitter.Archivable = false
	
	local straight = Instance.new("ParticleEmitter")
	straight.Name = "RainStraight"
	straight.LightEmission = RAIN_DEFAULT_LIGHTEMISSION
	straight.LightInfluence = RAIN_DEFAULT_LIGHTINFLUENCE
	straight.Size = RAIN_STRAIGHT_SIZE
	straight.Texture = RAIN_STRAIGHT_ASSET
	straight.LockedToPart = true
	straight.Enabled = false
	straight.Lifetime = RAIN_STRAIGHT_LIFETIME
	straight.Rate = RAIN_STRAIGHT_MAX_RATE
	straight.Speed = NumberRange.new(RAIN_STRAIGHT_MAX_SPEED)
	straight.EmissionDirection = Enum.NormalId.Bottom
	straight.Parent = Emitter
	straight.Orientation = Enum.ParticleOrientation.FacingCameraWorldUp
	
	local topdown = Instance.new("ParticleEmitter")
	topdown.Name = "RainTopDown"
	topdown.LightEmission = RAIN_DEFAULT_LIGHTEMISSION
	topdown.LightInfluence = RAIN_DEFAULT_LIGHTINFLUENCE
	topdown.Size = RAIN_TOPDOWN_SIZE
	topdown.Texture = RAIN_TOPDOWN_ASSET
	topdown.LockedToPart = true
	topdown.Enabled = false
	topdown.Rotation = RAIN_TOPDOWN_ROTATION
	topdown.Lifetime = RAIN_TOPDOWN_LIFETIME
	topdown.Rate = RAIN_TOPDOWN_MAX_RATE
	topdown.Speed = NumberRange.new(RAIN_TOPDOWN_MAX_SPEED)
	topdown.EmissionDirection = Enum.NormalId.Bottom
	topdown.Parent = Emitter
	
end

local splashAttachments, rainAttachments do
	
	splashAttachments = {}
	rainAttachments = {}
	
	for i = 1, RAIN_SPLASH_NUM do
		
		-- splashes on ground
		local splashAttachment = Instance.new("Attachment")
		splashAttachment.Name = "__RainSplashAttachment"
		local splash = Instance.new("ParticleEmitter")
		splash.LightEmission = RAIN_DEFAULT_LIGHTEMISSION
		splash.LightInfluence = RAIN_DEFAULT_LIGHTINFLUENCE
		splash.Size = RAIN_SPLASH_SIZE
		splash.Texture = RAIN_SPLASH_ASSET
		splash.Rotation = RAIN_SPLASH_ROTATION
		splash.Lifetime = RAIN_SPLASH_LIFETIME
		splash.Transparency = NumberSequence.new {
			NSK010;
			NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T1, RAIN_SPLASH_ALPHA_LOW, 0);
			NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T2, RAIN_SPLASH_ALPHA_LOW, 0);
			NSK110;
		}
		splash.Enabled = false
		splash.Rate = 0
		splash.Speed = NumberRange.new(0)
		splash.Name = "RainSplash"
		splash.Parent = splashAttachment
		splashAttachment.Archivable = false
		table.insert(splashAttachments, splashAttachment)
		
		-- occluded rain particle generation
		local rainAttachment = Instance.new("Attachment")
		rainAttachment.Name = "__RainOccludedAttachment"
		local straightOccluded = Emitter.RainStraight:Clone()
		straightOccluded.Speed = NumberRange.new(RAIN_OCCLUDED_MINSPEED, RAIN_OCCLUDED_MAXSPEED)
		straightOccluded.SpreadAngle = RAIN_OCCLUDED_SPREAD
		straightOccluded.LockedToPart = false
		straightOccluded.Enabled = false
		straightOccluded.Parent = rainAttachment
		local topdownOccluded = Emitter.RainTopDown:Clone()
		topdownOccluded.Speed = NumberRange.new(RAIN_OCCLUDED_MINSPEED, RAIN_OCCLUDED_MAXSPEED)
		topdownOccluded.SpreadAngle = RAIN_OCCLUDED_SPREAD
		topdownOccluded.LockedToPart = false
		topdownOccluded.Enabled = false
		topdownOccluded.Parent = rainAttachment
		rainAttachment.Archivable = false
		table.insert(rainAttachments, rainAttachment)
		
	end
	
end


-- Helper methods:

local ignoreEmitterList = { Emitter }

local raycastFunctions = {
	[CollisionMode.None] = function(ray, ignoreCharacter)
		return workspace:FindPartOnRayWithIgnoreList(ray, ignoreCharacter and {Emitter, Players.LocalPlayer and Players.LocalPlayer.Character} or ignoreEmitterList)
	end;
	[CollisionMode.Blacklist] = function(ray)
		return workspace:FindPartOnRayWithIgnoreList(ray, collisionList)
	end;
	[CollisionMode.Whitelist] = function(ray)
		return workspace:FindPartOnRayWithWhitelist(ray, collisionList)
	end;
	[CollisionMode.Function] = function(ray)
		local destination = ray.Origin + ray.Direction
		-- draw multiple raycasts concatenated to each other until no hit / valid hit found
		while ray.Direction.magnitude > 0.001 do
			local part, pos, norm, mat = workspace:FindPartOnRayWithIgnoreList(ray, ignoreEmitterList)
			if not part or collisionFunc(part) then
				return part, pos, norm, mat
			end
			local start = pos + ray.Direction.Unit * 0.001
			ray = Ray.new(start, destination - start)
		end
	end;
}
local raycast = raycastFunctions[collisionMode]

local function connectLoop()
	
	local rand = Random.new()
	
	local inside = true					-- Whether camera is currently in a spot occluded from the sky
	local frame = RAIN_UPDATE_PERIOD	-- Frame counter, and force update cycle right now
	
	-- Update Emitter on RenderStepped since it needs to be synced to Camera
	table.insert(connections, RunService.RenderStepped:connect(function()
		
		-- Check if camera is outside or inside
		local part, position = raycast(Ray.new(workspace.CurrentCamera.CFrame.p, -rainDirection * RAIN_SCANHEIGHT), true)
		
		if (not currentCeiling or workspace.CurrentCamera.CFrame.p.y <= currentCeiling) and not part then
			
			-- Camera is outside and under ceiling
				
			if volumeTarget < 1 and not disabled then
				volumeTarget = 1
				TweenService:Create(Sound, TweenInfo.new(.5), {Volume = 1}):Play()
			end
			
			frame = RAIN_UPDATE_PERIOD
			
			local t = math.abs(workspace.CurrentCamera.CFrame.lookVector:Dot(rainDirection))
			
			local center = workspace.CurrentCamera.CFrame.p
			local right = workspace.CurrentCamera.CFrame.lookVector:Cross(-rainDirection)
			right = right.magnitude > 0.001 and right.unit or -rainDirection
			local forward = rainDirection:Cross(right).unit
			
			Emitter.Size = v3(
				RAIN_EMITTER_DIM_DEFAULT,
				RAIN_EMITTER_DIM_DEFAULT,
				RAIN_EMITTER_DIM_DEFAULT + (1 - t)*(RAIN_EMITTER_DIM_MAXFORWARD - RAIN_EMITTER_DIM_DEFAULT)
			)
			
			Emitter.CFrame =
				CFrame.new(
					center.x, center.y, center.z,
					right.x, -rainDirection.x, forward.x,
					right.y, -rainDirection.y, forward.y,
					right.z, -rainDirection.z, forward.z
				)
				+ (1 - t) * workspace.CurrentCamera.CFrame.lookVector * Emitter.Size.Z/3
				- t * rainDirection * RAIN_EMITTER_UP_MODIFIER
			
			Emitter.RainStraight.Enabled = true
			Emitter.RainTopDown.Enabled = true
			
			inside = false
			
		else
			
			-- Camera is inside / above ceiling
			
			Emitter.RainStraight.Enabled = false
			Emitter.RainTopDown.Enabled = false
		
			inside = true
			
		end
		
	end))

	-- Do the other effects on Stepped
	local signal = RunService:IsRunning() and RunService.Stepped or RunService.RenderStepped
	table.insert(connections, signal:connect(function()
		
		frame = frame + 1
		
		-- Only do some updates once every few frames
		if frame >= RAIN_UPDATE_PERIOD then
			
			-- Measure of how much camera is facing down (0-1)
			local t = math.abs(workspace.CurrentCamera.CFrame.lookVector:Dot(rainDirection))
			
			-- More looking down = see straight particles less and see top-down particles more
			local straightSequence = NumberSequence.new {
				NSK010;
				NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T1, (1 - t)*straightLowAlpha + t, 0);
				NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T2, (1 - t)*straightLowAlpha + t, 0);
				NSK110;
			}
			local topdownSequence = NumberSequence.new {
				NSK010;
				NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T1, t*topdownLowAlpha + (1 - t), 0);
				NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T2, t*topdownLowAlpha + (1 - t), 0);
				NSK110;
			}
			
			-- Find desired rotation for the straight rain particles
			local mapped = workspace.Camera.CFrame:inverse() * (workspace.Camera.CFrame.p - rainDirection)
			local straightRotation = NumberRange.new(math.deg(math.atan2(-mapped.x, mapped.y)))
			
			if inside then
				
				-- Update emitter properties
				for _,v in pairs(rainAttachments) do
					v.RainStraight.Transparency = straightSequence
					v.RainStraight.Rotation = straightRotation
					v.RainTopDown.Transparency = topdownSequence
				end
				
				if not disabled then
					
					-- Only do occluded volume check if not moving towards disabled state
					
					local volume = 0
					
					if (not currentCeiling or workspace.CurrentCamera.CFrame.p.y <= currentCeiling) then
						
						-- Check how far away camera is from a space open to the sky using volume scan grid
						
						local minDistance = RAIN_VOLUME_SCAN_RADIUS
						local rayDirection = -rainDirection * RAIN_SCANHEIGHT
						
						for i = 1, #volumeScanGrid do -- In order, so first hit is closest
							if not raycast(Ray.new(workspace.CurrentCamera.CFrame * volumeScanGrid[i], rayDirection), true) then
								minDistance = volumeScanGrid[i].magnitude
								break
							end
						end
						
						-- Volume is inversely proportionate to minimum distance
						volume = 1 - minDistance / RAIN_VOLUME_SCAN_RADIUS
						
					end
					
					if math.abs(volume - volumeTarget) > .01 then
						-- Value is sufficiently different from previous target, overwrite it
						volumeTarget = volume
						TweenService:Create(Sound, TweenInfo.new(1), {Volume = volumeTarget}):Play()
					end
					
				end
				
			else
				
				-- Update emitter properties
				Emitter.RainStraight.Transparency = straightSequence
				Emitter.RainStraight.Rotation = straightRotation
				Emitter.RainTopDown.Transparency = topdownSequence
				
			end
			
			-- Reset frame counter
			frame = 0
			
		end
		
		local center = workspace.CurrentCamera.CFrame.p
		local right = workspace.CurrentCamera.CFrame.lookVector:Cross(-rainDirection)
		right = right.magnitude > 0.001 and right.unit or -rainDirection
		local forward = rainDirection:Cross(right).unit
		local transform = CFrame.new(
			center.x, center.y, center.z,
			right.x, -rainDirection.x, forward.x,
			right.y, -rainDirection.y, forward.y,
			right.z, -rainDirection.z, forward.z
		)
		local rayDirection = rainDirection * RAIN_OCCLUDECHECK_SCAN_Y
		
		-- Splash and occlusion effects
		for i = 1, numSplashes do
			
			local splashAttachment = splashAttachments[i]
			local rainAttachment = rainAttachments[i]
			
			-- Sample random splash position
			local x = rand:NextNumber(RAIN_OCCLUDECHECK_OFFSET_XZ_MIN, RAIN_OCCLUDECHECK_OFFSET_XZ_MAX)
			local z = rand:NextNumber(RAIN_OCCLUDECHECK_OFFSET_XZ_MIN, RAIN_OCCLUDECHECK_OFFSET_XZ_MAX)
			local part, position, normal = raycast(Ray.new(transform * v3(x, RAIN_OCCLUDECHECK_OFFSET_Y, z), rayDirection))
			
			if part then
				
				-- Draw a splash at hit
				splashAttachment.Position = position + normal * RAIN_SPLASH_CORRECTION_Y
				splashAttachment.RainSplash:Emit(1)
				
				if inside then
					
					-- Draw occlusion rain particles a little bit above the splash position
					local corrected = position - rainDirection * RAIN_SPLASH_STRAIGHT_OFFSET_Y
					if currentCeiling and corrected.Y > currentCeiling and rainDirection.Y < 0 then
						corrected = corrected + rainDirection * (currentCeiling - corrected.Y) / rainDirection.Y
					end
					rainAttachment.CFrame = transform - transform.p + corrected
					rainAttachment.RainStraight:Emit(intensityOccludedRain)
					rainAttachment.RainTopDown:Emit(intensityOccludedRain)
					
				end
				
			elseif inside then
				
				-- Draw occlusion rain particles on the XZ-position at around the camera's height
				local corrected = transform * v3(x, rand:NextNumber(RAIN_NOSPLASH_STRAIGHT_OFFSET_Y_MIN, RAIN_NOSPLASH_STRAIGHT_OFFSET_Y_MAX), z)
				if currentCeiling and corrected.Y > currentCeiling and rainDirection.Y < 0 then
					corrected = corrected + rainDirection * (currentCeiling - corrected.Y) / rainDirection.Y
				end
				rainAttachment.CFrame = transform - transform.p + corrected
				rainAttachment.RainStraight:Emit(intensityOccludedRain)
				rainAttachment.RainTopDown:Emit(intensityOccludedRain)
				
			end
			
		end
		
	end))

end

local function disconnectLoop()
	-- If present, disconnect all RunService connections
	if #connections > 0 then
		for _,v in pairs(connections) do
			v:disconnect()
		end
		connections = {}
	end
end

local function disableSound(tweenInfo)
	
	-- Tween the rain sound to be mute over a given easing function
	volumeTarget = 0
	local tween = TweenService:Create(Sound, tweenInfo, {Volume = 0})
	tween.Completed:connect(function(state)
		if state == Enum.PlaybackState.Completed then
			Sound:Stop()
		end
		tween:Destroy()
	end)
	tween:Play()
	
end

local function disable()
	
	disconnectLoop()
	
	-- Hide Emitter
	Emitter.RainStraight.Enabled = false
	Emitter.RainTopDown.Enabled = false
	Emitter.Size = MIN_SIZE
	
	-- Disable sound now if not tweened into disabled state beforehand
	if not disabled then
		disableSound(TweenInfo.new(RAIN_SOUND_FADEOUT_TIME))
	end
	
end

-- Shorthand for creating a tweenable "variable" using value object
local function makeProperty(valueObjectClass, defaultValue, setter)
	local valueObject = Instance.new(valueObjectClass)
	if defaultValue then
		valueObject.Value = defaultValue
	end
	valueObject.Changed:connect(setter)
	setter(valueObject.Value)
	return valueObject
end

local Color = makeProperty("Color3Value", RAIN_DEFAULT_COLOR, function(value)
	
	local value = ColorSequence.new(value)
	
	Emitter.RainStraight.Color = value
	Emitter.RainTopDown.Color = value
	
	for _,v in pairs(splashAttachments) do
		v.RainSplash.Color = value
	end
	for _,v in pairs(rainAttachments) do
		v.RainStraight.Color = value
		v.RainTopDown.Color = value
	end
	
end)

local function updateTransparency(value)
	
	local opacity = (1 - value) * (1 - GlobalModifier.Value)
	local transparency = 1 - opacity
	
	straightLowAlpha = RAIN_STRAIGHT_ALPHA_LOW * opacity + transparency
	topdownLowAlpha = RAIN_TOPDOWN_ALPHA_LOW * opacity + transparency
	
	local splashSequence = NumberSequence.new {
		NSK010;
		NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T1, opacity*RAIN_SPLASH_ALPHA_LOW + transparency, 0);
		NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T2, opacity*RAIN_SPLASH_ALPHA_LOW + transparency, 0);
		NSK110;
	}
	
	for _,v in pairs(splashAttachments) do
		v.RainSplash.Transparency = splashSequence
	end
	
end
local Transparency = makeProperty("NumberValue", RAIN_DEFAULT_TRANSPARENCY, updateTransparency)
GlobalModifier.Changed:connect(updateTransparency)

local SpeedRatio = makeProperty("NumberValue", RAIN_DEFAULT_SPEEDRATIO, function(value)
	
	Emitter.RainStraight.Speed = NumberRange.new(value * RAIN_STRAIGHT_MAX_SPEED)
	Emitter.RainTopDown.Speed = NumberRange.new(value * RAIN_TOPDOWN_MAX_SPEED)
	
end)

local IntensityRatio = makeProperty("NumberValue", RAIN_DEFAULT_INTENSITYRATIO, function(value)
	
	Emitter.RainStraight.Rate = RAIN_STRAIGHT_MAX_RATE * value
	Emitter.RainTopDown.Rate = RAIN_TOPDOWN_MAX_RATE * value
	
	intensityOccludedRain = math.ceil(RAIN_OCCLUDED_MAXINTENSITY * value)
	numSplashes = RAIN_SPLASH_NUM * value
	
end)

local LightEmission = makeProperty("NumberValue", RAIN_DEFAULT_LIGHTEMISSION, function(value)
	
	Emitter.RainStraight.LightEmission = value
	Emitter.RainTopDown.LightEmission = value
	
	for _,v in pairs(rainAttachments) do
		v.RainStraight.LightEmission = value
		v.RainTopDown.LightEmission = value
	end
	for _,v in pairs(splashAttachments) do
		v.RainSplash.LightEmission = value
	end
	
end)

local LightInfluence = makeProperty("NumberValue", RAIN_DEFAULT_LIGHTINFLUENCE, function(value)
	
	Emitter.RainStraight.LightInfluence = value
	Emitter.RainTopDown.LightInfluence = value
	
	for _,v in pairs(rainAttachments) do
		v.RainStraight.LightInfluence = value
		v.RainTopDown.LightInfluence = value
	end
	for _,v in pairs(splashAttachments) do
		v.RainSplash.LightInfluence = value
	end
	
end)

local RainDirection = makeProperty("Vector3Value", RAIN_DEFAULT_DIRECTION, function(value)
	if value.magnitude > 0.001 then
		rainDirection = value.unit
	end
end)


-- Exposed API:

local Rain = {}

Rain.CollisionMode = CollisionMode

function Rain:Enable(tweenInfo)
	
	if tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #1 to 'Enable' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	disconnectLoop() -- Just in case :Enable(..) is called multiple times on accident
	
	Emitter.RainStraight.Enabled = true
	Emitter.RainTopDown.Enabled = true
	Emitter.Parent = workspace.CurrentCamera
	
	for i = 1, RAIN_SPLASH_NUM do
		splashAttachments[i].Parent = workspace.Terrain
		rainAttachments[i].Parent = workspace.Terrain
	end
	
	if RunService:IsRunning() then -- don't need sound in studio preview, it won't work anyway
		SoundGroup.Parent = game:GetService("SoundService")
	end
	
	connectLoop()
	
	if tweenInfo then
		TweenService:Create(GlobalModifier, tweenInfo, {Value = 0}):Play()
	else
		GlobalModifier.Value = 0
	end
	
	if not Sound.Playing then
		Sound:Play()
		Sound.TimePosition = math.random()*Sound.TimeLength
	end
	
	disabled = false
	
end

function Rain:Disable(tweenInfo)
	
	if tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #1 to 'Disable' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	if tweenInfo then
		local tween = TweenService:Create(GlobalModifier, tweenInfo, {Value = 1})
		tween.Completed:connect(function(state)
			if state == Enum.PlaybackState.Completed then
				-- Only disable the rain completely once the visual effects are faded out
				disable()
			end
			tween:Destroy()
		end)
		tween:Play()
		-- Start tweening out sound now as well
		disableSound(tweenInfo)
	else
		GlobalModifier.Value = 1
		disable()
	end
	
	disabled = true
	
end

function Rain:SetColor(value, tweenInfo)
		
	if typeof(value) ~= "Color3" then
		error("bad argument #1 to 'SetColor' (Color3 expected, got " .. typeof(value) .. ")", 2)
	elseif tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #2 to 'SetColor' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	if tweenInfo then
		TweenService:Create(Color, tweenInfo, {Value = value}):Play()
	else
		Color.Value = value
	end
	
end

local function makeRatioSetter(methodName, valueObject)
	-- Shorthand because most of the remaining property setters are very similar
	return function(_, value, tweenInfo)
		
		if typeof(value) ~= "number" then
			error("bad argument #1 to '" .. methodName .. "' (number expected, got " .. typeof(value) .. ")", 2)
		elseif tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
			error("bad argument #2 to '" .. methodName .. "' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
		end
		
		value = math.clamp(value, 0, 1)
		
		if tweenInfo then
			TweenService:Create(valueObject, tweenInfo, {Value = value}):Play()
		else
			valueObject.Value = value
		end
		
	end
end

Rain.SetTransparency = makeRatioSetter("SetTransparency", Transparency)
Rain.SetSpeedRatio = makeRatioSetter("SetSpeedRatio", SpeedRatio)
Rain.SetIntensityRatio = makeRatioSetter("SetIntensityRatio", IntensityRatio)
Rain.SetLightEmission = makeRatioSetter("SetLightEmission", LightEmission)
Rain.SetLightInfluence = makeRatioSetter("SetLightInfluence", LightInfluence)

function Rain:SetVolume(volume, tweenInfo)
	
	if typeof(volume) ~= "number" then
		error("bad argument #1 to 'SetVolume' (number expected, got " .. typeof(volume) .. ")", 2)
	elseif tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #2 to 'SetVolume' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	if tweenInfo then
		TweenService:Create(SoundGroup, tweenInfo, {Volume = volume}):Play()
	else
		SoundGroup.Volume = volume
	end
	
end

function Rain:SetDirection(direction, tweenInfo)
	
	if typeof(direction) ~= "Vector3" then
		error("bad argument #1 to 'SetDirection' (Vector3 expected, got " .. typeof(direction) .. ")", 2)
	elseif tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #2 to 'SetDirection' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	if not (direction.unit.magnitude > 0) then -- intentional statement formatting since NaN comparison
		warn("Attempt to set rain direction to a zero-length vector, falling back on default direction = (" .. tostring(RAIN_DEFAULT_DIRECTION) .. ")")
		direction = RAIN_DEFAULT_DIRECTION
	end
	
	if tweenInfo then
		TweenService:Create(RainDirection, tweenInfo, {Value = direction}):Play()
	else
		RainDirection.Value = direction
	end
	
end

function Rain:SetCeiling(ceiling)
	
	if ceiling ~= nil and typeof(ceiling) ~= "number" then
		error("bad argument #1 to 'SetCeiling' (number expected, got " .. typeof(ceiling) .. ")", 2)
	end
	
	currentCeiling = ceiling
	
end

function Rain:SetStraightTexture(asset)
	
	if typeof(asset) ~= "string" then
		error("bad argument #1 to 'SetStraightTexture' (string expected, got " .. typeof(asset) .. ")", 2)
	end
	
	Emitter.RainStraight.Texture = asset
	
	for _,v in pairs(rainAttachments) do
		v.RainStraight.Texture = asset
	end
	
end

function Rain:SetTopDownTexture(asset)
	
	if typeof(asset) ~= "string" then
		error("bad argument #1 to 'SetStraightTexture' (string expected, got " .. typeof(asset) .. ")", 2)
	end
	
	Emitter.RainTopDown.Texture = asset
	
	for _,v in pairs(rainAttachments) do
		v.RainTopDown.Texture = asset
	end
	
end

function Rain:SetSplashTexture(asset)
	
	if typeof(asset) ~= "string" then
		error("bad argument #1 to 'SetStraightTexture' (string expected, got " .. typeof(asset) .. ")", 2)
	end
	
	for _,v in pairs(splashAttachments) do
		v.RainSplash.Texture = asset
	end
	
end

function Rain:SetSoundId(asset)
	
	if typeof(asset) ~= "string" then
		error("bad argument #1 to 'SetSoundId' (string expected, got " .. typeof(asset) .. ")", 2)
	end
	
	Sound.SoundId = asset
	
end

function Rain:SetCollisionMode(mode, param)
	
	if mode == CollisionMode.None then
		
		-- Regular mode needs no white/blacklist or test function
		collisionList = nil
		collisionFunc = nil
		
	elseif mode == CollisionMode.Blacklist then
		
		if typeof(param) == "Instance" then
			-- Add Emitter anyway, since users will probably not expect collisions with emitter block regardless
			collisionList = {param, Emitter}
		elseif typeof(param) == "table" then
			for i = 1, #param do
				if typeof(param[i]) ~= "Instance" then
					error("bad argument #2 to 'SetCollisionMode' (blacklist contained a " .. typeof(param[i]) .. " on index " .. tostring(i) .. " which is not an Instance)", 2)
				end
			end
			collisionList = {Emitter} -- see above
			for i = 1, #param do
				table.insert(collisionList, param[i])
			end
		else
			error("bad argument #2 to 'SetCollisionMode (Instance or array of Instance expected, got " .. typeof(param) .. ")'", 2)
		end
		
		-- Blacklist does not need a test function
		collisionFunc = nil
		
	elseif mode == CollisionMode.Whitelist then
		
		if typeof(param) == "Instance" then
			collisionList = {param}
		elseif typeof(param) == "table" then
			for i = 1, #param do
				if typeof(param[i]) ~= "Instance" then
					error("bad argument #2 to 'SetCollisionMode' (whitelist contained a " .. typeof(param[i])  .. " on index " .. tostring(i) .. " which is not an Instance)", 2)
				end
			end
			collisionList = {}
			for i = 1, #param do
				table.insert(collisionList, param[i])
			end
		else
			error("bad argument #2 to 'SetCollisionMode (Instance or array of Instance expected, got " .. typeof(param) .. ")'", 2)
		end
		
		-- Whitelist does not need a test function
		collisionFunc = nil
		
	elseif mode == CollisionMode.Function then
		
		if typeof(param) ~= "function" then
			error("bad argument #2 to 'SetCollisionMode' (function expected, got " .. typeof(param) .. ")", 2)
		end
		
		-- Test function does not need a list
		collisionList = nil
		
		collisionFunc = param
		
	else
		error("bad argument #1 to 'SetCollisionMode (Rain.CollisionMode expected, got " .. typeof(param) .. ")'", 2)
	end
	
	collisionMode = mode
	raycast = raycastFunctions[mode]
	
end

return Rain
s|L|FlyPhysics
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local camera = workspace.CurrentCamera

local flyEvent = ReplicatedStorage:WaitForChild("AdminFlyEvent")

local canFly = false 
local isFlying = false
local lastJump = 0
local speed = 500
local bv, bg

local function stopFlying()
	isFlying = false
	if bv then bv:Destroy() bv = nil end
	if bg then bg:Destroy() bg = nil end
	if player.Character and player.Character:FindFirstChild("Humanoid") then
		player.Character.Humanoid.PlatformStand = false
	end
end

local function startFlying()
	local char = player.Character
	local hrp = char:FindFirstChild("HumanoidRootPart")
	local hum = char:FindFirstChild("Humanoid")
	if not hrp or not hum then return end

	isFlying = true
	hum.PlatformStand = true
	bv = Instance.new("BodyVelocity", hrp)
	bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bg = Instance.new("BodyGyro", hrp)
	bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)

	task.spawn(function()
		while isFlying and char.Parent do
			local move = Vector3.new(0,0,0)
			-- Keyboard Input
			if UserInputService:IsKeyDown(Enum.KeyCode.W) then move += camera.CFrame.LookVector end
			if UserInputService:IsKeyDown(Enum.KeyCode.S) then move -= camera.CFrame.LookVector end
			if UserInputService:IsKeyDown(Enum.KeyCode.D) then move += camera.CFrame.RightVector end
			if UserInputService:IsKeyDown(Enum.KeyCode.A) then move -= camera.CFrame.RightVector end

			-- Mobile Joystick + Combined Logic
			local finalMove = move + hum.MoveDirection
			if UserInputService:IsKeyDown(Enum.KeyCode.Space) then finalMove += Vector3.new(0,1,0)
			elseif UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then finalMove -= Vector3.new(0,1,0) end

			bv.Velocity = (finalMove.Magnitude > 0) and (finalMove.Unit * speed) or Vector3.new(0,0,0)
			bg.CFrame = camera.CFrame
			RunService.RenderStepped:Wait()
		end
		stopFlying()
	end)
end

-- SERVER TOGGLE RECEIVER
flyEvent.OnClientEvent:Connect(function(state)
	canFly = state -- State is true or false
	if not canFly and isFlying then
		stopFlying()
	end
	print(canFly and "âœ”ï¸ Fly Perms ENABLED" or "âŒ Fly Perms DISABLED")
end)

-- DOUBLE JUMP DETECTION (iPad & PC)
UserInputService.JumpRequest:Connect(function()
	if not canFly then return end
	local now = tick()
	if now - lastJump < 0.3 then
		if isFlying then stopFlying() else startFlying() end
	end
	lastJump = now
end)

s|L|ConcentratorClient
-- ================================================================
--  WeatherConcentratorClient  (LocalScript)
--  Place inside StarterPlayerScripts (or StarterCharacterScripts)
--
--  Listens for ConcentratorResult and ConcentratorBroadcast remote
--  events fired by WeatherConcentratorSystem and shows on-screen
--  notifications â€” exactly like the slot system's client feedback.
-- ================================================================

local Players           = game:GetService("Players")
local TweenService      = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player    = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local Remotes             = ReplicatedStorage:WaitForChild("RemoteEvents")
local ConcentratorResult  = Remotes:WaitForChild("ConcentratorResult")
local ConcentratorBroadcast = Remotes:WaitForChild("ConcentratorBroadcast")

-- ================================================================
--  NOTIFICATION UI
--  Two separate notification tracks:
--    Personal  â€” craft result shown only to the player who triggered
--    Discovery â€” server-wide broadcast when a first discovery happens
-- ================================================================

local function createNotifGui(name)
	-- Destroy old one if it exists (e.g. character respawn)
	local old = playerGui:FindFirstChild(name)
	if old then old:Destroy() end

	local sg = Instance.new("ScreenGui")
	sg.Name              = name
	sg.ResetOnSpawn      = false
	sg.ZIndexBehavior    = Enum.ZIndexBehavior.Sibling
	sg.IgnoreGuiInset    = true
	sg.Parent            = playerGui

	local frame = Instance.new("Frame")
	frame.Name              = "Frame"
	frame.AnchorPoint       = Vector2.new(0.5, 0)
	frame.Position          = UDim2.new(0.5, 0, -0.15, 0)  -- starts off-screen above
	frame.Size              = UDim2.new(0.55, 0, 0.08, 0)
	frame.BackgroundColor3  = Color3.fromRGB(15, 15, 25)
	frame.BackgroundTransparency = 0.15
	frame.BorderSizePixel   = 0
	frame.Parent            = sg

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = frame

	local stroke = Instance.new("UIStroke")
	stroke.Color     = Color3.fromRGB(100, 80, 255)
	stroke.Thickness = 2
	stroke.Parent    = frame

	local label = Instance.new("TextLabel")
	label.Name                  = "Message"
	label.Size                  = UDim2.new(1, -20, 1, 0)
	label.Position              = UDim2.new(0, 10, 0, 0)
	label.BackgroundTransparency = 1
	label.TextColor3            = Color3.fromRGB(255, 255, 255)
	label.TextScaled            = true
	label.Font                  = Enum.Font.FredokaOne
	label.TextXAlignment        = Enum.TextXAlignment.Center
	label.TextStrokeTransparency = 0.5
	label.TextStrokeColor3      = Color3.new(0, 0, 0)
	label.Parent                = frame

	local constraint = Instance.new("UITextSizeConstraint")
	constraint.MaxTextSize = 26
	constraint.MinTextSize = 10
	constraint.Parent      = label

	sg.Enabled = false
	return sg, frame, label
end

-- â”€â”€ Personal result notification (centre-top) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local personalGui, personalFrame, personalLabel = createNotifGui("ConcentratorPersonalNotif")

-- â”€â”€ Discovery broadcast notification (slightly lower, gold border) â”€
local discoveryGui, discoveryFrame, discoveryLabel = createNotifGui("ConcentratorDiscoveryNotif")

-- Make discovery notification visually distinct
discoveryFrame.Size              = UDim2.new(0.7, 0, 0.1, 0)
discoveryFrame.BackgroundColor3  = Color3.fromRGB(20, 10, 5)
local dStroke = discoveryFrame:FindFirstChildOfClass("UIStroke")
if dStroke then dStroke.Color = Color3.fromRGB(255, 200, 0) end

-- ================================================================
--  SHOW NOTIFICATION  (slide down, hold, slide up)
-- ================================================================
local function showNotif(sg, frame, label, message, color, holdTime)
	-- Cancel any running hide task for this gui
	local existingTag = sg:GetAttribute("HideTaskRunning")
	sg:SetAttribute("HideTaskRunning", false)

	label.TextColor3 = color or Color3.fromRGB(255, 255, 255)
	label.Text       = message
	sg.Enabled       = true

	-- Reset to off-screen
	frame.Position = UDim2.new(0.5, 0, -0.15, 0)

	-- Slide in
	TweenService:Create(frame,
		TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
		{ Position = UDim2.new(0.5, 0, 0.04, 0) }
	):Play()

	sg:SetAttribute("HideTaskRunning", true)
	task.spawn(function()
		task.wait(holdTime or 3)
		-- Only hide if no newer call has taken over
		if not sg:GetAttribute("HideTaskRunning") then return end

		TweenService:Create(frame,
			TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.In),
			{ Position = UDim2.new(0.5, 0, -0.15, 0) }
		):Play()
		task.wait(0.4)
		sg.Enabled = false
	end)
end

-- ================================================================
--  PERSONAL RESULT  â€” fired only to this player
--  (success: bool, message: string, discoveryBonus: number|nil)
-- ================================================================
ConcentratorResult.OnClientEvent:Connect(function(success, message, discoveryBonus)
	if success then
		local color = discoveryBonus
			and Color3.fromRGB(255, 215, 0)    -- gold for discoveries
			or  Color3.fromRGB(100, 255, 150)  -- green for normal fuse
		showNotif(personalGui, personalFrame, personalLabel, message, color, 4)
	else
		showNotif(personalGui, personalFrame, personalLabel, message,
			Color3.fromRGB(255, 80, 80), 3)    -- red for failures
	end
end)

-- ================================================================
--  DISCOVERY BROADCAST  â€” fired to everyone when someone discovers
--  (playerName, blendedName, brainrotName, bonusAmount, depth)
-- ================================================================
ConcentratorBroadcast.OnClientEvent:Connect(function(discovererName, blendedName, brainrotName, bonus, depth)
	-- Don't double-show for the discoverer (they already got a personal notif)
	if discovererName == player.Name then return end

	local msg = string.format(
		"ðŸ”¬ %s discovered '%s' (depth %d) and earned $%s!",
		discovererName,
		blendedName,
		depth,
		string.format("%d", bonus)
	)

	showNotif(discoveryGui, discoveryFrame, discoveryLabel,
		msg, Color3.fromRGB(255, 215, 0), 5)
end)

-- ================================================================
--  CONCENTRATOR COST PREVIEW
--  Updates the ProximityPrompt subtitle with the live cost so
--  players know what they'll pay before they commit.
-- ================================================================
local ConcentratorInfo = Remotes:WaitForChild("ConcentratorInfo", 5)

if ConcentratorInfo then
	-- Poll every 2 seconds so it stays current as weather changes
	-- and as the player swaps tools
	task.spawn(function()
		while true do
			task.wait(2)
			local char = player.Character
			if char then
				local ok, info = pcall(function()
					return ConcentratorInfo:InvokeServer()
				end)
				if ok and info then
					-- Find the concentrator's ProximityPrompt in the world
					-- and update its ActionText with the cost
					local concentrator = workspace:FindFirstChild("WeatherConcentrator", true)
					if concentrator then
						local prompt = concentrator:FindFirstChildWhichIsA("ProximityPrompt", true)
						if prompt then
							if info.activeMutation then
								prompt.ActionText = string.format(
									"Concentrate  ($%s)",
									string.format("%d", info.cost)
								)
							else
								prompt.ActionText = "Concentrate"
							end
						end
					end
				end
			end
		end
	end)
end
c|L|PowerBar UI + Throwing Handler
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for RemoteEvent
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local throwMemeEvent = remoteEvents:WaitForChild("ThrowMemeEvent")

-- Create UI
local screenGui = playerGui:WaitForChild("ThrowingUI")

-- Power bar background (vertical)
local powerBarBg = screenGui:WaitForChild("PowerBarBackground")

local gradientFrame = powerBarBg.Frame
local gradientCorner = gradientFrame.UICorner
local gradient = gradientFrame.UIGradient

-- Moving indicator
local indicator = powerBarBg.Indicator

-- ---------------------------------------------------------
-- LOGIC
-- ---------------------------------------------------------

local isLoopActive = false
local currentPower = 0.01
local powerDirection = 1
local POWER_SPEED = 1.2 -- Speed is now per second (1.2 means it takes ~0.83s to fill)
local renderConnection = nil

local function startPowerBar()
	-- 1. Prevent loop stacking by killing any existing connection
	if renderConnection then
		renderConnection:Disconnect()
		renderConnection = nil
	end

	isLoopActive = true

	-- 2. Use RenderStepped for butter-smooth, constant speed
	renderConnection = RunService.RenderStepped:Connect(function(deltaTime)
		if not (isLoopActive and screenGui.Enabled) then
			if renderConnection then
				renderConnection:Disconnect()
				renderConnection = nil
			end
			return
		end

		-- Multiply by deltaTime so speed is perfectly constant
		currentPower = currentPower + (POWER_SPEED * powerDirection * deltaTime)

		if currentPower >= 1 then
			currentPower = 1
			powerDirection = -1
		elseif currentPower <= 0.01 then
			currentPower = 0.01
			powerDirection = 1
		end

		indicator.Position = UDim2.new(0, 0, currentPower, -4)
	end)
end

local function stopPowerBar()
	isLoopActive = false
	if renderConnection then
		renderConnection:Disconnect()
		renderConnection = nil
	end
end

local function getPowerPercentage()
	local distanceFromCenter = math.abs(currentPower - 0.5)
	local powerPercent = 1 - (distanceFromCenter * 2) 
	return math.max(0.01, powerPercent) 
end

local function getCurrentColor()
	local power = currentPower
	if power < 0.25 then
		local t = power / 0.25
		return Color3.fromRGB(220, 50 + (150 * t), 50)
	elseif power < 0.5 then
		local t = (power - 0.25) / 0.25
		return Color3.fromRGB(240 - (190 * t), 200 + (20 * t), 50 + (170 * t))
	elseif power < 0.75 then
		local t = (power - 0.5) / 0.25
		return Color3.fromRGB(50 + (190 * t), 220 - (20 * t), 220 - (170 * t))
	else
		local t = (power - 0.75) / 0.25
		return Color3.fromRGB(240 - (20 * t), 200 - (150 * t), 50)
	end
end

local function throwMeme(targetPosition)
	if not screenGui.Enabled or not isLoopActive then return end

	stopPowerBar() -- Stop the bar
	local powerPercent = getPowerPercentage()

	-- Visual feedback
	local lockColor = getCurrentColor()
	indicator.BackgroundColor3 = lockColor

	-- Handle default target if none provided (e.g. Spacebar)
	if not targetPosition then
		if player.Character and player.Character.PrimaryPart then
			targetPosition = player.Character.PrimaryPart.Position + (player.Character.PrimaryPart.CFrame.LookVector * 100)
		else
			targetPosition = Vector3.new(0, 0, 0)
		end
	end

	-- Send Power AND Position to server
	throwMemeEvent:FireServer(powerPercent, targetPosition)

	task.wait(0.5)

	if screenGui.Enabled then
		indicator.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		startPowerBar() -- Safely restart the bar
	end
end

-- ---------------------------------------------------------
-- INPUT HANDLING (Click Anywhere Logic)
-- ---------------------------------------------------------

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if not screenGui.Enabled then return end
	if gameProcessed then return end

	if input.UserInputType == Enum.UserInputType.MouseButton1 or
		input.UserInputType == Enum.UserInputType.Touch then

		if mouse.Hit then
			throwMeme(mouse.Hit.Position)
		end
	end
end)

-- ---------------------------------------------------------
-- EQUIP / UNEQUIP HANDLING
-- ---------------------------------------------------------
local THROW_TOOL_NAME = "Tool" -- change to your actual tool name

local function bindTool(tool)
	if tool.Name ~= THROW_TOOL_NAME then return end

	tool.Equipped:Connect(function()
		screenGui.Enabled = true
		currentPower = 0.01
		indicator.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		startPowerBar()
	end)

	tool.Unequipped:Connect(function()
		screenGui.Enabled = false
		stopPowerBar()
	end)
end

local function setupCharacter(character)
	for _, child in ipairs(character:GetChildren()) do
		if child:IsA("Tool") then
			bindTool(child)
		end
	end

	character.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			bindTool(child)
		end
	end)
end

if player.Character then
	setupCharacter(player.Character)
end

player.CharacterAdded:Connect(setupCharacter)
c|L|BrainrotHold
-- Put this in StarterPlayer > StarterCharacterScripts
-- This will automatically position ANY tool with a Rarity attribute above the player's head
local brainrotevent = game.ReplicatedStorage.RemoteEvents.pickupbrainrot
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = script.Parent
local humanoid = character:WaitForChild("Humanoid")
local dropgui = player.PlayerGui:WaitForChild("DropBrainrotGui")
-- Wait for necessary body parts
local head = character:WaitForChild("Head")
local rootPart = character:WaitForChild("HumanoidRootPart")
local leftShoulder = character:WaitForChild("LeftUpperArm", 5)
local rightShoulder = character:WaitForChild("RightUpperArm", 5)

-- Track current brainrot tool
local currentBrainrotTool = nil
local customWeld = nil
local leftArmWeld = nil
local rightArmWeld = nil
local originalCollisionStates = {}

-- Arm raising animation setup
local function raiseArms()
	if not leftShoulder or not rightShoulder then return end

	if not leftArmWeld then
		leftArmWeld = Instance.new("Weld")
		leftArmWeld.Name = "LeftArmRaise"
		leftArmWeld.Part0 = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
		leftArmWeld.Part1 = leftShoulder
		leftArmWeld.C0 = CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(180), 0, 0)
		leftArmWeld.Parent = leftArmWeld.Part0
	end

	if not rightArmWeld then
		rightArmWeld = Instance.new("Weld")
		rightArmWeld.Name = "RightArmRaise"
		rightArmWeld.Part0 = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
		rightArmWeld.Part1 = rightShoulder
		rightArmWeld.C0 = CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(180), 0, 0)
		rightArmWeld.Parent = rightArmWeld.Part0
	end
end

local function lowerArms()
	if leftArmWeld then
		leftArmWeld:Destroy()
		leftArmWeld = nil
	end
	if rightArmWeld then
		rightArmWeld:Destroy()
		rightArmWeld = nil
	end
end

-- Clean up physics objects that interfere with movement
local function cleanupPhysicsObjects(tool)
	local removedCount = 0

	for _, descendant in pairs(tool:GetDescendants()) do
		-- Remove BodyVelocity, BodyGyro, and other physics movers
		if descendant:IsA("BodyVelocity") or 
			descendant:IsA("BodyGyro") or 
			descendant:IsA("BodyPosition") or
			descendant:IsA("BodyForce") or
			descendant:IsA("BodyThrust") or
			descendant:IsA("BodyAngularVelocity") then
			descendant:Destroy()
			removedCount = removedCount + 1
		end
	end

	if removedCount > 0 then
		print("ðŸ§¹ Removed", removedCount, "physics objects")
	end
end

-- Disable collision on all brainrot parts
local function disableBrainrotCollision(tool)
	originalCollisionStates = {}
	local partsFound = 0

	for _, descendant in pairs(tool:GetDescendants()) do
		if descendant:IsA("BasePart") then
			partsFound = partsFound + 1
			originalCollisionStates[descendant] = descendant.CanCollide
			descendant.CanCollide = false
		end
	end

	print("ðŸ”§ Disabled collision on", partsFound, "parts")
end

-- Restore collision on all brainrot parts
local function restoreBrainrotCollision(tool)
	for part, originalState in pairs(originalCollisionStates) do
		if part and part.Parent then
			part.CanCollide = originalState
		end
	end

	originalCollisionStates = {}
end

local function positionBrainrotAboveHead(tool)
	local handle = tool:FindFirstChild("Handle")
	if not handle then 
		print("âŒ No Handle found!")
		return 
	end

	-- Destroy the default RightGrip
	local rightGrip = character:FindFirstChild("RightGrip")
	if rightGrip then
		rightGrip:Destroy()
	end

	-- CRITICAL: Remove physics objects that cause movement issues
	cleanupPhysicsObjects(tool)

	-- Disable collision
	disableBrainrotCollision(tool)

	-- Create custom weld to position above head
	customWeld = Instance.new("Weld")
	customWeld.Name = "BrainrotWeld"
	customWeld.Part0 = head
	customWeld.Part1 = handle
	customWeld.C0 = CFrame.new(0, 6, 0) * CFrame.Angles(0, 0, 0)
	customWeld.Parent = handle

	-- Raise arms
	raiseArms()

	print("ðŸŽ’ Positioned brainrot above head:", tool.Name)
end

local function onToolEquipped(tool)
	if tool:GetAttribute("Rarity") then
		currentBrainrotTool = tool

		task.wait(0.05)

		positionBrainrotAboveHead(tool)
		dropgui.Enabled = true
	end

end

local function onToolUnequipped(tool)
	if tool == currentBrainrotTool then
		restoreBrainrotCollision(tool)

		if customWeld then
			customWeld:Destroy()
			customWeld = nil
		end

		lowerArms()

		currentBrainrotTool = nil
		dropgui.Enabled = false

	end
end


character.ChildAdded:Connect(function(child)
	if child:IsA("Tool") then
		onToolEquipped(child)
	end
end)

character.ChildRemoved:Connect(function(child)
	if child:IsA("Tool") then
		onToolUnequipped(child)
	end
end)

local equippedTool = character:FindFirstChildOfClass("Tool")
if equippedTool then
	onToolEquipped(equippedTool)
end
brainrotevent.OnClientEvent:Connect(function(brainrot)
	print(brainrot.Name)
end)
print("âœ… Brainrot Overhead Positioning loaded!")
g|L|GUI
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

-- ðŸ› ï¸ Developer check
local function isDeveloper(p)
	if RunService:IsStudio() then return true end
	return p.UserId == game.CreatorId or p.UserId == 10378926133 or p.UserId == 8834525880
end

if not isDeveloper(player) then return end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- ðŸ—‚ï¸ Register your debug panels here
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local DEBUG_PANELS = {
	{ guiName = "WeatherDebugUI",  frameName = "WeatherFrame",  label = "ðŸŒ¦ Weather"  },
	{ guiName = "DebugUI", frameName = "Frame",  label = "ðŸ§  Brainrot" },
	{ guiName = "MainUI", frameName = "Panel", label = "ðŸŽ² Random"},
	{guiName = "DevMoneyButton", frameName = "Frame", label = "ðŸ’¸ Money"},
	{guiName = "AdminFly", frameName = "Frame", label = "ðŸš Fly"}
}

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Build the container UI from scratch
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local PlayerGui = player:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "DebugContainerUI"
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 999
screenGui.Parent = PlayerGui

-- Outer frame
local frame = Instance.new("Frame")
frame.Name = "ContainerFrame"
frame.Size = UDim2.new(0, 200, 0, 40) -- starts minimized, expands below
frame.Position = UDim2.new(0, 10, 0, 10)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
frame.BorderSizePixel = 0
frame.Active = true
frame.Parent = screenGui

local frameCorner = Instance.new("UICorner")
frameCorner.CornerRadius = UDim.new(0, 6)
frameCorner.Parent = frame

-- Title bar
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 36)
titleBar.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
titleBar.BorderSizePixel = 0
titleBar.Active = true
titleBar.Parent = frame

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 6)
titleCorner.Parent = titleBar

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, -40, 1, 0)
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "ðŸ›  Debug Panel"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 13
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleBar

local minimizeBtn = Instance.new("TextButton")
minimizeBtn.Size = UDim2.new(0, 30, 0, 30)
minimizeBtn.Position = UDim2.new(1, -34, 0, 3)
minimizeBtn.BackgroundColor3 = Color3.fromRGB(90, 90, 110)
minimizeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextSize = 16
minimizeBtn.Text = "âˆ’"
minimizeBtn.Parent = titleBar

local minCorner = Instance.new("UICorner")
minCorner.CornerRadius = UDim.new(0, 4)
minCorner.Parent = minimizeBtn

-- Panel list (vertical, below title bar)
local panelList = Instance.new("Frame")
panelList.Name = "PanelList"
panelList.Position = UDim2.new(0, 0, 0, 36)
panelList.Size = UDim2.new(1, 0, 0, 0) -- height driven by AutomaticSize
panelList.AutomaticSize = Enum.AutomaticSize.Y
panelList.BackgroundTransparency = 1
panelList.Parent = frame

local listLayout = Instance.new("UIListLayout")
listLayout.FillDirection = Enum.FillDirection.Vertical
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Padding = UDim.new(0, 4)
listLayout.Parent = panelList

local listPadding = Instance.new("UIPadding")
listPadding.PaddingTop = UDim.new(0, 6)
listPadding.PaddingBottom = UDim.new(0, 6)
listPadding.PaddingLeft = UDim.new(0, 6)
listPadding.PaddingRight = UDim.new(0, 6)
listPadding.Parent = panelList

-- Auto-resize outer frame to fit list
local function updateFrameHeight()
	frame.Size = UDim2.new(0, 200, 0, 36 + panelList.AbsoluteSize.Y)
end
panelList:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateFrameHeight)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Register panels
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for _, panel in ipairs(DEBUG_PANELS) do
	local debugGui = PlayerGui:WaitForChild(panel.guiName, 10)
	if not debugGui then
		warn("âŒ DebugContainer: Could not find '" .. panel.guiName .. "'")
		continue
	end
	local debugFrame = debugGui:WaitForChild(panel.frameName, 10)
	if not debugFrame then
		warn("âŒ DebugContainer: Could not find frame '" .. panel.frameName .. "'")
		continue
	end

	debugFrame.Visible = false

	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(1, 0, 0, 34)
	btn.BackgroundColor3 = Color3.fromRGB(50, 50, 65)
	btn.TextColor3 = Color3.fromRGB(220, 220, 255)
	btn.Font = Enum.Font.GothamMedium
	btn.TextSize = 13
	btn.Text = panel.label .. "  â—" -- â— = hidden
	btn.Parent = panelList

	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 4)
	btnCorner.Parent = btn

	print("âœ… DebugContainer: Registered '" .. panel.label .. "'")

	btn.MouseButton1Click:Connect(function()
		debugFrame.Visible = not debugFrame.Visible
		btn.Text = panel.label .. (debugFrame.Visible and "  â—‰" or "  â—")
		print("ðŸ” Toggled", panel.label, "â†’", debugFrame.Visible)
	end)
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Minimize / expand
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local expanded = true

minimizeBtn.MouseButton1Click:Connect(function()
	expanded = not expanded
	panelList.Visible = expanded
	minimizeBtn.Text = expanded and "âˆ’" or "+"
	if expanded then
		updateFrameHeight()
	else
		frame.Size = UDim2.new(0, 200, 0, 36)
	end
end)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Draggable
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local dragging, dragStart, startPos

titleBar.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = frame.Position
	end
end)

titleBar.InputChanged:Connect(function(input)
	if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(
			startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y
		)
	end
end)

titleBar.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = false
	end
end)
gG|L|LocalScript
if not game:IsLoaded() then game.Loaded:Wait() end

local grad = script.Parent
while true do
	grad.Rotation +=5
	wait()
end
gGB|L|LocalScript
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local event = game.ReplicatedStorage.RemoteEvents.randombrainrot

local button = script.Parent
-- Find the RemoteFunction that the Server created
local getPassesFunc = ReplicatedStorage:WaitForChild("GetPasses")

local player = Players.LocalPlayer
local isDebounce = false -- Prevents spamming the button

-- ðŸ› ï¸ Helper: Check Developer Status
local function isDeveloper(player)
	-- Always allow in Studio
	if RunService:IsStudio() then
		return true
	end

	-- Allow if you are the owner OR if your ID matches
	return player.UserId == game.CreatorId or player.UserId == 1037892613 or player.UserId == 8834525880 -- Put your ID here
end

-- Hide button from non-developers
if not isDeveloper(player) then
	script.Parent.Visible = false
	return
end

button.MouseButton1Click:Connect(function()
	event:FireServer()
	if isDebounce then return end
	isDebounce = true

	print("ðŸ–±ï¸ CLIENT: Button Clicked! Calling Server...")
	button.Text = "Loading..."

	-- This sends the signal to 'BoothServer' script
	local items = getPassesFunc:InvokeServer()

	print("ðŸ–±ï¸ CLIENT: Server replied with " .. #items .. " items.")

	-- RESET THE BUTTON
	button.Text = "Refresh"
	isDebounce = false

	-- TODO: This is where you would update your scrolling frame
	-- For now, we just print the names to prove it works
	for _, item in ipairs(items) do
		print("   > Item: " .. item.name .. " - " .. item.price .. " R$")
	end
end)
gG|L|Spawn
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local brainrotsFolder = ReplicatedStorage:WaitForChild("Brainrot pack1")
local spawnEvent = ReplicatedStorage.RemoteEvents.SpawnSpecificBrainrot
--local spawnButton = script.Parent:WaitForChild("SpawnButton")

-- ðŸ› ï¸ Helper: Check Developer Status
local function isDeveloper(player)
	-- Always allow in Studio
	if RunService:IsStudio() then
		return true
	end

	-- Allow if you are the owner OR if your ID matches
	return player.UserId == game.CreatorId or player.UserId == 8834525880 -- Put your ID here
end

if not isDeveloper(player) then
	script.Parent.Enabled = false
	return
end

local gui = script.Parent
local frame = gui:WaitForChild("Frame")

local dropdownButton = frame:WaitForChild("DropdownButton")

local dropdown = frame:WaitForChild("Dropdown")
local template = dropdown:WaitForChild("Template")

-- Initial Setup
local selectedBrainrot = nil
dropdown.Visible = false
template.Visible = false -- Keep template hidden
dropdown.AutomaticSize = Enum.AutomaticSize.Y -- Force the frame to grow

-- ðŸ§  Populate dropdown
for _, brainrot in ipairs(brainrotsFolder:GetChildren()) do
	if brainrot:IsA("Model") or brainrot:IsA("BasePart") then
		local button = template:Clone()
		button.Visible = true
		button.Text = brainrot.Name
		button.Parent = dropdown

		button.MouseButton1Click:Connect(function()
			-- 1. TRACK START: See if the button even registers the click
			print("--- Dropdown Clicked: " .. brainrot.Name .. " ---")

			selectedBrainrot = brainrot.Name
			dropdownButton.Text = "Selected: " .. brainrot.Name
			dropdown.Visible = false

			-- 2. CHECK REMOTE: Verify the RemoteEvent actually exists
			if spawnEvent then
				spawnEvent:FireServer(brainrot.Name)
				-- 3. TRACK END: Confirm the instruction was sent to the server
				print("âœ… LocalScript: Sent spawn request for " .. brainrot.Name)
			else
				warn("âŒ LocalScript Error: spawnEvent is missing!")
			end
		end)
	end
end

-- Toggle dropdown
dropdownButton.MouseButton1Click:Connect(function()
	dropdown.Visible = not dropdown.Visible
	print("Dropdown is now:", dropdown.Visible)
end)

-- Spawn selected brainrot
--[[spawnButton.MouseButton1Click:Connect(function()
	if selectedBrainrot then
		spawnEvent:FireServer(selectedBrainrot)
	else
		warn("Select something first!")
	end
end)]]


gG|L|openUpgradeGui
local ProximityPrompt = workspace.Environment.Shops:WaitForChild("UpgradeStation"):WaitForChild("ProximityPrompt")
local screenGui = script.Parent
local closeButton = screenGui:WaitForChild("MainFrame"):WaitForChild("CloseButton")

-- Handle Opening
ProximityPrompt.Triggered:Connect(function()
	screenGui.Enabled = true
end)

-- Handle Closing
closeButton.MouseButton1Click:Connect(function()
	screenGui.Enabled = false
end)
gGB|L|LocalScript
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

local openButton = script.Parent
local mainFrame = openButton.Parent.Parent.Rebirth.MainRebirthFrame
local badge = openButton:WaitForChild("Badge")

local player = Players.LocalPlayer
local leaderstats = player:WaitForChild("leaderstats")
local rebirths = leaderstats:WaitForChild("Rebirths")
local moneyRaw = player:WaitForChild("MoneyRaw")

-- Configuration (must match server)
local BASE_REBIRTH_COST = 100000
local COST_MULTIPLIER = 1.5

local function calculateCost(rebirthCount)
	return math.floor(BASE_REBIRTH_COST * (COST_MULTIPLIER ^ rebirthCount))
end

-- Update badge visibility (show red dot only when rebirth is affordable)
local function updateBadge()
	local currentCost = calculateCost(rebirths.Value)

	if moneyRaw.Value >= currentCost then
		badge.Visible = true -- Show red dot when can afford rebirth
	else
		badge.Visible = false -- Hide dot when can't afford
	end
end

moneyRaw.Changed:Connect(updateBadge)
rebirths.Changed:Connect(updateBadge)
updateBadge()

-- Open button click
openButton.MouseButton1Click:Connect(function()
	-- Hide open button
	local hideTween = TweenService:Create(openButton, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0)
	})
	hideTween:Play()
	hideTween.Completed:Wait()
	openButton.Visible = false

	-- Show main frame
	mainFrame.Visible = true
	mainFrame.Size = UDim2.new(0, 0, 0, 0)
	mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)

	local openTween = TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 380, 0, 480),
		Position = UDim2.new(0.5, -190, 0.5, -240)
	})
	openTween:Play()
end)



-- Start with main frame hidden and open button visible
mainFrame.Visible = false
openButton.Visible = true
gG|L|LocalScript
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
script.Parent.Parent.Enabled= true

script.Parent.Visible = false
local player = Players.LocalPlayer
local leaderstats = player:WaitForChild("leaderstats")
local moneyRaw = player:WaitForChild("MoneyRaw")
local rebirths = leaderstats:WaitForChild("Rebirths")

local NumberFormat = require(ReplicatedStorage:WaitForChild("NumberFormat"))

local frame = script.Parent
local rebirthButton = frame:WaitForChild("RebirthButton")
local costLabel = frame:WaitForChild("CostContainer"):WaitForChild("CostLabel")
local progressBar = frame:WaitForChild("ProgressBarFrame")
local fillBar = progressBar:WaitForChild("FillBar")
local progressText = progressBar:WaitForChild("ProgressText")
local statusLabel = frame:WaitForChild("StatusLabel")
local currentRebirthsLabel = frame:WaitForChild("CurrentRebirthsLabel")
local rewardLabel = frame:WaitForChild("RewardContainer"):WaitForChild("RewardLabel")

-- Configuration (must match server)
local BASE_REBIRTH_COST = 100000
local COST_MULTIPLIER = 1.5

local function calculateCost(rebirthCount)
	return math.floor(BASE_REBIRTH_COST * (COST_MULTIPLIER ^ rebirthCount))
end



local function updateUI()
	local currentCost = calculateCost(rebirths.Value)
	local nextRebirthBonus = rebirths.Value + 1

	-- Update cost label
	costLabel.Text = "ðŸ’° Cost: $" .. NumberFormat.format(currentCost)

	-- Update current rebirths
	currentRebirthsLabel.Text = "Current Rebirths: " .. rebirths.Value

	-- Update reward label
	rewardLabel.Text = "ðŸŽ Next Rebirth Bonus\n+" .. nextRebirthBonus .. "x Multiplier"

	-- Update benefit label in confirmation

	-- Update progress bar
	local progress = math.min(moneyRaw.Value / currentCost, 1)
	progressText.Text = "$" .. NumberFormat.format(moneyRaw.Value) .. " / $" .. NumberFormat.format(currentCost)

	-- Animate fill bar
	local targetSize = UDim2.new(progress, 0, 1, 0)
	local fillTween = TweenService:Create(fillBar, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = targetSize
	})
	fillTween:Play()

	-- Update button state
	if moneyRaw.Value >= currentCost then
		-- Can afford rebirth - enable button
		rebirthButton.BackgroundColor3 = Color3.fromRGB(255, 170, 0)
		rebirthButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		local buttonStroke = rebirthButton:FindFirstChild("UIStroke")
		if buttonStroke then
			buttonStroke.Color = Color3.fromRGB(255, 200, 0)
		end
		local buttonGradient = rebirthButton:FindFirstChild("UIGradient")
		if buttonGradient then
			buttonGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 190, 50)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 140, 0))
			}
		end

		statusLabel.Text = "âœ… Ready to rebirth!"
		statusLabel.TextColor3 = Color3.fromRGB(100, 255, 150)

		-- Change fill bar color to green
		fillBar.BackgroundColor3 = Color3.fromRGB(100, 255, 150)
		local fillGradient = fillBar:FindFirstChild("UIGradient")
		if fillGradient then
			fillGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(120, 255, 170)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(80, 220, 130))
			}
		end
	else
		-- Cannot afford - disable button
		rebirthButton.BackgroundColor3 = Color3.fromRGB(120, 120, 130)
		rebirthButton.TextColor3 = Color3.fromRGB(180, 180, 190)
		local buttonStroke = rebirthButton:FindFirstChild("UIStroke")
		if buttonStroke then
			buttonStroke.Color = Color3.fromRGB(100, 100, 110)
		end
		local buttonGradient = rebirthButton:FindFirstChild("UIGradient")
		if buttonGradient then
			buttonGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(140, 140, 150)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 100, 110))
			}
		end

		local needed = currentCost - moneyRaw.Value
		statusLabel.Text = "âŒ Need $" .. NumberFormat.format(needed) .. " more"
		statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)

		-- Keep fill bar blue
		fillBar.BackgroundColor3 = Color3.fromRGB(80, 200, 255)
		local fillGradient = fillBar:FindFirstChild("UIGradient")
		if fillGradient then
			fillGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 220, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 160, 255))
			}
		end
	end
end

-- Update UI when values change
moneyRaw.Changed:Connect(updateUI)
rebirths.Changed:Connect(updateUI)

-- Initial update
updateUI()
gGB|L|LocalScript
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local rebirthevent = ReplicatedStorage.RemoteEvents:WaitForChild("rebirthevent")
local rebirthButton = script.Parent

-- Button click - rebirth immediately (no confirmation)
rebirthButton.MouseButton1Click:Connect(function()
	print("Rebirth button clicked!") -- Debug

	-- Check if button is enabled using attribute (set by the UI update script)
	if rebirthButton:GetAttribute("Disabled") == true then
		print("Button is disabled") -- Debug
		return
	end

	print("Firing rebirth event to server") -- Debug

	-- Fire rebirth event immediately
	rebirthevent:FireServer()
end)

-- Listen for server response
rebirthevent.OnClientEvent:Connect(function(success, data)
	if success then
		print("Successfully rebirthed! New rebirth count: " .. data)
		-- Optional: Play success sound, effects, etc.
	else
		print("Rebirth failed! Need: $" .. data)
		-- Optional: Play error sound
	end
end)
gGB|L|LocalScript
local TweenService = game:GetService("TweenService")

local closeButton = script.Parent
local mainFrame = closeButton.Parent
local openButton = mainFrame.Parent.Parent.RebirthOpen:WaitForChild("RebirthOpenButton")

closeButton.MouseButton1Click:Connect(function()
	-- Hide confirmation frame if it's open
	

	-- Animate main frame closing
	local closeTween = TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0)
	})
	closeTween:Play()
	closeTween.Completed:Wait()
	mainFrame.Visible = false

	-- Show open button
	openButton.Visible = true
	openButton.Size = UDim2.new(0, 0, 0, 0)
	local openTween = TweenService:Create(openButton, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 70, 0, 70)
	})
	openTween:Play()

	-- Button press animation
	closeButton.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
	wait(0.1)
	closeButton.BackgroundColor3 = Color3.fromRGB(220, 70, 70)
end)

-- Hover effects
closeButton.MouseEnter:Connect(function()
	local hoverTween = TweenService:Create(closeButton, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 45, 0, 45),
		BackgroundColor3 = Color3.fromRGB(255, 100, 100)
	})
	hoverTween:Play()
end)

closeButton.MouseLeave:Connect(function()
	local leaveTween = TweenService:Create(closeButton, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 40, 0, 40),
		BackgroundColor3 = Color3.fromRGB(220, 70, 70)
	})
	leaveTween:Play()
end)
gG|L|openShop
local ProximityPrompt = workspace.Environment.Shops:WaitForChild("WeaponsUpgradesShop"):WaitForChild("WeaponsStation"):WaitForChild("ProximityPrompt")
local screenGui = script.Parent
local closeButton = screenGui:WaitForChild("MainFrame").TitleBar:WaitForChild("CloseButton") -- Adjust paths

-- Handle Opening
ProximityPrompt.Triggered:Connect(function()
	screenGui.Enabled = true
end)

-- Handle Closing
closeButton.MouseButton1Click:Connect(function()
	screenGui.Enabled = false
end)
gGB|L|LocalScript
local usr = game:GetService('UserInputService')
local gui = script.Parent.Parent.Parent.Parent
script.Parent.MouseButton1Click:Connect(function()
	gui.Enabled = false
end)
gGB|L|LocalScript
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")

-- DATA
local event = ReplicatedStorage.RemoteEvents.Purchasecoil -- Make sure this matches the specific coil for each script!
local button = script.Parent
local player = Players.LocalPlayer
local moneyRaw = player:WaitForChild("MoneyRaw")

-- GUI SETUP
local purchaseGui = player:WaitForChild("PlayerGui"):WaitForChild("PurchaseGui")

-- [[ FIX 1: FORCE GUI TO FRONT ]] --
-- This ensures this GUI always sits on top of your Shop GUI
purchaseGui.DisplayOrder = 100 

local fundsFrame = purchaseGui:WaitForChild("funds")
local ownershipFrame = purchaseGui:WaitForChild("ownership")

-- Set frames to start at top middle (centered and hidden)
fundsFrame.AnchorPoint = Vector2.new(0.5, 0)
fundsFrame.Position = UDim2.new(0.5, 0, -0.3, 0) -- Moved higher up so it doesn't peek
fundsFrame.Visible = false

ownershipFrame.AnchorPoint = Vector2.new(0.5, 0)
ownershipFrame.Position = UDim2.new(0.5, 0, -0.3, 0)
ownershipFrame.Visible = false

-- VARIABLES
local haspurchased = false
local currentTween = nil
local hideTask = nil

local function showNotification(frame)
	-- 1. CANCEL OLD TIMERS
	if hideTask then
		task.cancel(hideTask)
		hideTask = nil
	end

	-- 2. STOP CURRENT MOTION
	if currentTween then
		currentTween:Cancel()
	end

	-- 3. RESET (Make sure it's visible and on top)
	frame.Visible = true
	frame.ZIndex = 100 -- Extra safety

	-- If frame is currently hidden (off screen), reset it to start position
	if frame.Position.Y.Scale < 0 then
		frame.Position = UDim2.new(0.5, 0, -0.3, 0)
	end

	-- [[ FIX 2: SLOWER ANIMATION ]] --
	-- Changed from 0.8 to 1.2 for a slower, floatier drop
	local dropInfo = TweenInfo.new(
		1.2, 
		Enum.EasingStyle.Elastic, 
		Enum.EasingDirection.Out
	)

	currentTween = TweenService:Create(frame, dropInfo, {
		Position = UDim2.new(0.5, 0, 0.15, 0)
	})
	currentTween:Play()

	-- 4. WAIT & HIDE
	hideTask = task.spawn(function()
		task.wait(2.0) -- Increased wait time so you can read it (was 1.2)

		local upInfo = TweenInfo.new(
			0.6, -- Slower exit (was 0.4)
			Enum.EasingStyle.Back,
			Enum.EasingDirection.In
		)

		currentTween = TweenService:Create(frame, upInfo, {
			Position = UDim2.new(0.5, 0, -0.3, 0)
		})
		currentTween:Play()
		currentTween.Completed:Wait()

		frame.Visible = false -- Hide it completely after it goes up
		hideTask = nil
		currentTween = nil
	end)
end

-- BUTTON CLICK
button.MouseButton1Click:Connect(function()
	-- CHANGE THE PRICE HERE PER SCRIPT (e.g. 500 or 800)
	local PRICE = 800 
	local ITEM_NAME = "SpeedCoil" -- Change to "SpeedCoil" for the other script

	if moneyRaw.Value >= PRICE and not haspurchased then
		event:FireServer(ITEM_NAME)
		haspurchased = true
		button.Text = "OWNED"
		button.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
	elseif haspurchased then
		showNotification(ownershipFrame)
	elseif moneyRaw.Value < PRICE then
		showNotification(fundsFrame)
	end
end)
gGB|L|LocalScript
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")

-- DATA
local event = ReplicatedStorage.RemoteEvents.Purchasecoil -- Make sure this matches the specific coil for each script!
local button = script.Parent
local player = Players.LocalPlayer
local moneyRaw = player:WaitForChild("MoneyRaw")

-- GUI SETUP
local purchaseGui = player:WaitForChild("PlayerGui"):WaitForChild("PurchaseGui")

-- [[ FIX 1: FORCE GUI TO FRONT ]] --
-- This ensures this GUI always sits on top of your Shop GUI
purchaseGui.DisplayOrder = 100 

local fundsFrame = purchaseGui:WaitForChild("funds")
local ownershipFrame = purchaseGui:WaitForChild("ownership")

-- Set frames to start at top middle (centered and hidden)
fundsFrame.AnchorPoint = Vector2.new(0.5, 0)
fundsFrame.Position = UDim2.new(0.5, 0, -0.3, 0) -- Moved higher up so it doesn't peek
fundsFrame.Visible = false

ownershipFrame.AnchorPoint = Vector2.new(0.5, 0)
ownershipFrame.Position = UDim2.new(0.5, 0, -0.3, 0)
ownershipFrame.Visible = false

-- VARIABLES
local haspurchased = false
local currentTween = nil
local hideTask = nil

local function showNotification(frame)
	-- 1. CANCEL OLD TIMERS
	if hideTask then
		task.cancel(hideTask)
		hideTask = nil
	end

	-- 2. STOP CURRENT MOTION
	if currentTween then
		currentTween:Cancel()
	end

	-- 3. RESET (Make sure it's visible and on top)
	frame.Visible = true
	frame.ZIndex = 100 -- Extra safety

	-- If frame is currently hidden (off screen), reset it to start position
	if frame.Position.Y.Scale < 0 then
		frame.Position = UDim2.new(0.5, 0, -0.3, 0)
	end

	-- [[ FIX 2: SLOWER ANIMATION ]] --
	-- Changed from 0.8 to 1.2 for a slower, floatier drop
	local dropInfo = TweenInfo.new(
		1.2, 
		Enum.EasingStyle.Elastic, 
		Enum.EasingDirection.Out
	)

	currentTween = TweenService:Create(frame, dropInfo, {
		Position = UDim2.new(0.5, 0, 0.15, 0)
	})
	currentTween:Play()

	-- 4. WAIT & HIDE
	hideTask = task.spawn(function()
		task.wait(2.0) -- Increased wait time so you can read it (was 1.2)

		local upInfo = TweenInfo.new(
			0.6, -- Slower exit (was 0.4)
			Enum.EasingStyle.Back,
			Enum.EasingDirection.In
		)

		currentTween = TweenService:Create(frame, upInfo, {
			Position = UDim2.new(0.5, 0, -0.3, 0)
		})
		currentTween:Play()
		currentTween.Completed:Wait()

		frame.Visible = false -- Hide it completely after it goes up
		hideTask = nil
		currentTween = nil
	end)
end

-- BUTTON CLICK
button.MouseButton1Click:Connect(function()
	-- CHANGE THE PRICE HERE PER SCRIPT (e.g. 500 or 800)
	local PRICE = 800 
	local ITEM_NAME = "SuperSpeedCoil" -- Change to "SpeedCoil" for the other script

	if moneyRaw.Value >= PRICE and not haspurchased then
		event:FireServer(ITEM_NAME)
		haspurchased = true
		button.Text = "OWNED"
		button.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
	elseif haspurchased then
		showNotification(ownershipFrame)
	elseif moneyRaw.Value < PRICE then
		showNotification(fundsFrame)
	end
end)
gG|L|LocalScript
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local forceWeatherEvent = ReplicatedStorage.RemoteEvents.ForceWeather

-- ðŸ› ï¸ Developer check (matches your existing script)
local function isDeveloper(p)
	if RunService:IsStudio() then return true end
	return p.UserId == game.CreatorId or p.UserId == 10378926133
end

if not isDeveloper(player) then
	script.Parent.Enabled = false
	return
end

local gui = script.Parent  -- this is now DebugUI
local frame = gui:WaitForChild("WeatherFrame")  -- name your new Frame whatever you like
local dropdownButton = frame:WaitForChild("DropdownButton")
local dropdown = frame:WaitForChild("Dropdown")
local template = dropdown:WaitForChild("Template")

-- Weather types (must match WeatherSystem module keys exactly)
local WEATHER_OPTIONS = {
	"Clear",
	"Bloodstorm",
	"Candyland",
	"Volcanic",
	"Galactic",
	"YinYang",
	"Radioactive", "Rain",
}

-- Initial setup
dropdown.Visible = false
template.Visible = false
dropdown.AutomaticSize = Enum.AutomaticSize.Y

-- Populate dropdown with weather options
for _, weatherName in ipairs(WEATHER_OPTIONS) do
	local button = template:Clone()
	button.Visible = true
	button.Text = weatherName
	button.Parent = dropdown

	button.MouseButton1Click:Connect(function()
		print("--- Weather Selected: " .. weatherName .. " ---")
		dropdownButton.Text = "Weather: " .. weatherName
		dropdown.Visible = false

		if forceWeatherEvent then
			forceWeatherEvent:FireServer(weatherName)
			print("âœ… LocalScript: Sent force weather request for " .. weatherName)
		else
			warn("âŒ LocalScript Error: forceWeatherEvent is missing!")
		end
	end)
end

-- Toggle dropdown
dropdownButton.MouseButton1Click:Connect(function()
	dropdown.Visible = not dropdown.Visible
	print("Weather dropdown is now:", dropdown.Visible)
end)

-- Toggle main frame (open button is the parent of this script)

gFGB|S|Script
local button = script.Parent
local runService = game:GetService("RunService")

local time = 0
local speed = 1
local buttonGradient = button.UIGradient
runService.Heartbeat:Connect(function(dt)
	time = time + dt * speed

	-- Animated diagonal movement (45 degrees = 0.785 radians)

	buttonGradient.Rotation = 45
	buttonGradient.Offset = Vector2.new(math.sin(time), math.cos(time))
end)
gFGB|L|LocalScript
local usr = game:GetService("UserInputService")
local parent = script.Parent
local event = game.ReplicatedStorage.RemoteEvents.UpgradeBase
parent.MouseButton1Click:Connect(function()
	print("SEOIFJSOIEJF")
	event:FireServer()
end)
gFGB|S|Script
local button = script.Parent
local runService = game:GetService("RunService")

local time = 0
local speed = 1
local buttonGradient = button.UIGradient
runService.Heartbeat:Connect(function(dt)
	time = time + dt * speed

	-- Animated diagonal movement (45 degrees = 0.785 radians)

	buttonGradient.Rotation = 45
	buttonGradient.Offset = Vector2.new(math.sin(time), math.cos(time))
end)
gFGB|L|LocalScript
local usr = game:GetService("UserInputService")
local parent = script.Parent
local event = game.ReplicatedStorage.RemoteEvents.UpgradeBase
parent.MouseButton1Click:Connect(function()
	print("SEOIFJSOIEJF")
	event:FireServer()
end)
gFGB|S|Script
local button = script.Parent
local runService = game:GetService("RunService")

local time = 0
local speed = 1
local buttonGradient = button.UIGradient
runService.Heartbeat:Connect(function(dt)
	time = time + dt * speed

	-- Animated diagonal movement (45 degrees = 0.785 radians)

	buttonGradient.Rotation = 45
	buttonGradient.Offset = Vector2.new(math.sin(time), math.cos(time))
end)
gFGB|L|LocalScript
local usr = game:GetService("UserInputService")
local parent = script.Parent
local event = game.ReplicatedStorage.RemoteEvents.UpgradeBase
parent.MouseButton1Click:Connect(function()
	print("SEOIFJSOIEJF")
	event:FireServer()
end)
gFGB|S|Script
local button = script.Parent
local runService = game:GetService("RunService")

local time = 0
local speed = 1
local buttonGradient = button.UIGradient
runService.Heartbeat:Connect(function(dt)
	time = time + dt * speed

	-- Animated diagonal movement (45 degrees = 0.785 radians)

	buttonGradient.Rotation = 45
	buttonGradient.Offset = Vector2.new(math.sin(time), math.cos(time))
end)
gFGB|L|LocalScript
local usr = game:GetService("UserInputService")
local parent = script.Parent
local event = game.ReplicatedStorage.RemoteEvents.UpgradeBase
parent.MouseButton1Click:Connect(function()
	print("SEOIFJSOIEJF")
	event:FireServer()
end)
gFGB|S|Script
local button = script.Parent
local runService = game:GetService("RunService")

local time = 0
local speed = 1
local buttonGradient = button.UIGradient
runService.Heartbeat:Connect(function(dt)
	time = time + dt * speed

	-- Animated diagonal movement (45 degrees = 0.785 radians)

	buttonGradient.Rotation = 45
	buttonGradient.Offset = Vector2.new(math.sin(time), math.cos(time))
end)
gFGB|L|LocalScript
local usr = game:GetService("UserInputService")
local parent = script.Parent
local event = game.ReplicatedStorage.RemoteEvents.UpgradeBase
parent.MouseButton1Click:Connect(function()
	print("SEOIFJSOIEJF")
	event:FireServer()
end)
gG|L|LocalScript
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local addMoneyEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("AddMoneyRequest")

local frame = script.Parent
local textBox = frame:WaitForChild("TextBox")
local playerTextBox = frame:WaitForChild("PlayerTextBox")
local addButton = frame:WaitForChild("AddButton")

-- Add money
local function onAddButtonClicked()
	local amount = tonumber(textBox.Text)
	local targetUsername = playerTextBox.Text

	if not amount or amount <= 0 then
		warn("Invalid amount:", textBox.Text)
		return
	end

	-- Send both amount and target username (empty string means self)
	addMoneyEvent:FireServer(amount, targetUsername)
	textBox.Text = ""
end

addButton.MouseButton1Click:Connect(onAddButtonClicked)

gGB|L|LocalScript
local but = script.Parent
local usr = game:GetService("UserInputService")
local player = game.Players.LocalPlayer
local character = player.Character
local brainrots = game.ReplicatedStorage["Brainrot pack1"]

but.MouseButton1Click:Connect(function()
	if but.Parent.Enabled == true then
		local items = character:GetChildren()
		for i, item in pairs(items) do
			if item:IsA("Tool") then
				item:Destroy()
			
			end
		end
		but.Enabled = false
		wait(1)
	end
end)
gGB|L|LocalScript
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local flyEvent = ReplicatedStorage:WaitForChild("AdminFlyEvent")
local button = script.Parent
local textBox = button.Parent:FindFirstChildOfClass("TextBox") -- Finds any textbox in the same frame

button.MouseButton1Click:Connect(function()
	if textBox and textBox.Text ~= "" then
		print("ðŸ–±ï¸ GUI: Requesting fly for " .. textBox.Text)
		flyEvent:FireServer(textBox.Text)
		button.Text = "Sent!"
		task.wait(1)
		button.Text = "Give Fly"
	end
end)

gGB|L|LocalScript
local parent = script.Parent
local plr = game.Players.LocalPlayer
local name = plr.Name
local bases = game.Workspace.BrainrotBases:GetChildren()
local usr = game:GetService("UserInputService")
local plrbase = nil
local TweenService = game:GetService("TweenService")
parent.Size = UDim2.new(0, 100, 0, 100)

for i, v in pairs(bases) do
	if v.Owner.Value == name then
		print("Sef")
		plrbase = v
	end
end
parent.MouseButton1Click:Connect(function()
	local tp = plrbase.SpawnLocation
	plr.Character:MoveTo(tp.Position)
end)
parent.MouseEnter:Connect(function()
	local hoverTween = TweenService:Create(parent, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 120, 0, 120),
		BackgroundColor3 = Color3.fromRGB(40, 40, 55)
	})
	hoverTween:Play()


end)
parent.MouseLeave:Connect(function()
	local leaveTween = TweenService:Create(parent, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 100, 0, 100),
		BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	})
	leaveTween:Play()


end)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gFGB|L|Script
print(script.Parent.Text)
gGB|L|Script
print(script.Parent.Text)
gGB|L|LocalScript
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

local openButton = script.Parent
local mainFrame = openButton.Parent.Parent.TradeReal.ItemGrid


local player = Players.LocalPlayer




-- Open button click
openButton.MouseButton1Click:Connect(function()
	-- Hide open button
	local hideTween = TweenService:Create(openButton, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0)
	})
	hideTween:Play()
	hideTween.Completed:Wait()
	openButton.Visible = false

	-- Show main frame
	mainFrame.Visible = true
	mainFrame.Size = UDim2.new(0, 0, 0, 0)
	mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)

	local openTween = TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 380, 0, 480),
		Position = UDim2.new(0.5, -190, 0.5, -240)
	})
	openTween:Play()
end)



-- Start with main frame hidden and open button visible
mainFrame.Visible = false
openButton.Visible = true
gG|L|LocalScript
-- LocalScript inside your trade menu ScreenGui

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

-- Wait for character and backpack to exist
local backpack = player:WaitForChild("Backpack")

-- Point this to whatever Frame you want the slots to appear in
local itemGrid = script.Parent:WaitForChild("ItemGrid")

local RARITY_COLORS = {
	["Common"]      = Color3.fromRGB(0, 255, 0),
	["Rare"]        = Color3.fromRGB(0, 100, 255),
	["Epic"]        = Color3.fromRGB(150, 0, 255),
	["Legendary"]   = Color3.fromRGB(255, 215, 0),
	["Mythic"]      = Color3.fromRGB(255, 0, 0),
	["Brainrot God"]= Color3.fromRGB(255, 100, 0),
	["Secret"]      = Color3.fromRGB(30, 30, 30),
	["OG"]          = Color3.fromRGB(0, 255, 200),
}

local function createToolPreview(tool, viewportFrame)
	for _, child in pairs(viewportFrame:GetChildren()) do
		if not child:IsA("Camera") then child:Destroy() end
	end

	local toolClone = tool:Clone()
	toolClone.Parent = viewportFrame

	local camera = viewportFrame:FindFirstChildOfClass("Camera")
	if not camera then
		camera = Instance.new("Camera")
		camera.Parent = viewportFrame
	end
	viewportFrame.CurrentCamera = camera

	local rootPart = toolClone:FindFirstChild("Handle")
		or toolClone.PrimaryPart
		or toolClone:FindFirstChildWhichIsA("BasePart")

	if rootPart then
		local cf, size = toolClone:GetBoundingBox()
		local distance = size.Magnitude * 1.5

		-- Store cf.Position so the rotation loop can reference it
		viewportFrame:SetAttribute("BoundX", cf.Position.X)
		viewportFrame:SetAttribute("BoundY", cf.Position.Y)
		viewportFrame:SetAttribute("BoundZ", cf.Position.Z)
		viewportFrame:SetAttribute("CamDist", distance)

		camera.CFrame = CFrame.new(
			cf.Position + Vector3.new(distance, distance * 0.5, distance),
			cf.Position
		)
	end

	return camera
end

local function addRotation(viewportFrame)
	local angle = 0
	RunService.RenderStepped:Connect(function(dt)
		if not viewportFrame or not viewportFrame.Parent then return end
		local camera = viewportFrame.CurrentCamera
		if not camera then return end

		local bx       = viewportFrame:GetAttribute("BoundX") or 0
		local by       = viewportFrame:GetAttribute("BoundY") or 0
		local bz       = viewportFrame:GetAttribute("BoundZ") or 0
		local distance = viewportFrame:GetAttribute("CamDist") or 5
		local center   = Vector3.new(bx, by, bz)

		angle += dt * 60
		local rad = math.rad(angle)
		camera.CFrame = CFrame.new(
			center + Vector3.new(
				math.cos(rad) * distance,
				distance * 0.5,
				math.sin(rad) * distance
			),
			center
		)
	end)
end

local function buildTradeSlot(parent, tool)
	local rarity = tool:GetAttribute("Rarity") or "Common"

	local slot = Instance.new("Frame")
	slot.Size = UDim2.new(0, 120, 0, 120)
	slot.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
	slot.BorderSizePixel = 0
	slot.Parent = parent

	local stroke = Instance.new("UIStroke")
	stroke.Color = RARITY_COLORS[rarity] or Color3.new(1, 1, 1)
	stroke.Thickness = 3
	stroke.Parent = slot

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = slot

	local viewport = Instance.new("ViewportFrame")
	viewport.Size = UDim2.new(1, 0, 1, 0)
	viewport.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
	viewport.BorderSizePixel = 0
	viewport.Ambient = Color3.fromRGB(180, 180, 180)
	viewport.LightDirection = Vector3.new(-1, -2, -1)
	viewport.Parent = slot

	local vpCorner = Instance.new("UICorner")
	vpCorner.CornerRadius = UDim.new(0, 8)
	vpCorner.Parent = viewport

	createToolPreview(tool, viewport)
	addRotation(viewport)

	return slot
end

local function refreshInventory()
	-- Clear existing slots
	for _, child in pairs(itemGrid:GetChildren()) do
		if child:IsA("Frame") then child:Destroy() end
	end

	-- Tools in backpack (not currently equipped)
	for _, tool in pairs(backpack:GetChildren()) do
		if tool:IsA("Tool") then
			buildTradeSlot(itemGrid, tool)
		end
	end

	-- Tools currently equipped (sitting in the Character)
	local character = player.Character
	if character then
		for _, tool in pairs(character:GetChildren()) do
			if tool:IsA("Tool") then
				buildTradeSlot(itemGrid, tool)
			end
		end
	end
end

-- Initial load
refreshInventory()

-- Re-render if the player picks up or drops a tool
backpack.ChildAdded:Connect(refreshInventory)
backpack.ChildRemoved:Connect(refreshInventory)
gG|L|TradeController
local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService        = game:GetService("RunService")
local UserInputService  = game:GetService("UserInputService")

local player  = Players.LocalPlayer
local backpack = player:WaitForChild("Backpack")

-- Wait for remotes
local remotes = ReplicatedStorage:WaitForChild("TradeRemotes", 20)
if not remotes then warn("TradeRemotes not found!") return end

local sendRequest    = remotes:WaitForChild("SendTradeRequest")
local respondRequest = remotes:WaitForChild("RespondToRequest")
local confirmTrade   = remotes:WaitForChild("ConfirmTrade")
local cancelTrade    = remotes:WaitForChild("CancelTrade")
local tradeNotify    = remotes:WaitForChild("TradeNotify")

-- GUI refs
local gui              = script.Parent
local openBtn          = gui:WaitForChild("OpenTradeButton")
local badge            = openBtn:WaitForChild("NotificationBadge")
local reqPrompt        = gui:WaitForChild("TradeRequestPrompt")
local tradeMenu        = gui:WaitForChild("TradeMenu")
local dropBtn          = gui:WaitForChild("DropdownButton")
local cancelBtn        = tradeMenu:WaitForChild("CancelButton")
local confirmBtn       = tradeMenu:WaitForChild("ConfirmButton")
local leftSide         = tradeMenu:WaitForChild("LeftSide")
local rightSide        = tradeMenu:WaitForChild("RightSide")
local invPanel         = tradeMenu:WaitForChild("InventoryPanel")
local scrollFrame      = invPanel:WaitForChild("ScrollFrame")
local countdownOverlay = tradeMenu:WaitForChild("CountdownOverlay")
local countdownLbl     = countdownOverlay:WaitForChild("CountdownLabel")
local leftGrid         = leftSide:WaitForChild("SlotGrid")
local rightGrid        = rightSide:WaitForChild("SlotGrid")

-- Slot tables
local mySlots = {}
for i = 1,4 do mySlots[i] = leftGrid:WaitForChild("Slot"..i) end

-- State
local pendingRequesterName = nil
local tradePartnerName     = nil
local selfConfirmed        = false
local partnerConfirmed     = false
local dragData             = nil
local dropdownOpen         = false
local dropdownList         = nil

-- offeredTools[toolName] = tool object  (currently sitting in a slot)
local offeredTools = {}

-- â”€â”€â”€ Viewport rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function renderInViewport(tool, vp)
	for _, c in pairs(vp:GetChildren()) do
		if not c:IsA("Camera") then c:Destroy() end
	end
	vp:SetAttribute("CD", nil)
	vp.CurrentCamera = nil

	local clone = tool:Clone()
	for _, s in pairs(clone:GetDescendants()) do
		if s:IsA("BaseScript") then s:Destroy() end
	end
	clone.Parent = vp

	local cam = Instance.new("Camera")
	cam.Parent = vp
	vp.CurrentCamera = cam

	local ok, cf, sz = pcall(function() return clone:GetBoundingBox() end)
	if not ok then
		local part = clone:IsA("BasePart") and clone or clone:FindFirstChildWhichIsA("BasePart")
		if not part then return end
		cf, sz = part.CFrame, part.Size
	end

	local dist = sz.Magnitude * 1.5
	vp:SetAttribute("BX",  cf.Position.X)
	vp:SetAttribute("BY",  cf.Position.Y)
	vp:SetAttribute("BZ",  cf.Position.Z)
	vp:SetAttribute("CD",  dist)
	vp:SetAttribute("Ang", 0)

	cam.CFrame = CFrame.new(
		cf.Position + Vector3.new(dist, dist*0.4, dist),
		cf.Position
	)
end

-- Single rotation loop for all viewports
RunService.RenderStepped:Connect(function(dt)
	for _, vp in pairs(gui:GetDescendants()) do
		if vp:IsA("ViewportFrame") and vp.CurrentCamera and vp:GetAttribute("CD") then
			local a      = (vp:GetAttribute("Ang") or 0) + dt * 55
			vp:SetAttribute("Ang", a)
			local rad    = math.rad(a)
			local cx     = vp:GetAttribute("BX") or 0
			local cy     = vp:GetAttribute("BY") or 0
			local cz     = vp:GetAttribute("BZ") or 0
			local dist   = vp:GetAttribute("CD") or 5
			local center = Vector3.new(cx, cy, cz)
			vp.CurrentCamera.CFrame = CFrame.new(
				center + Vector3.new(math.cos(rad)*dist, dist*0.4, math.sin(rad)*dist),
				center
			)
		end
	end
end)

-- â”€â”€â”€ Slot management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function clearSlot(slot)
	local toolName = slot:GetAttribute("ToolName")
	if toolName then
		-- Restore the tool: move it back from wherever it is to backpack
		local tool = offeredTools[toolName]
		if tool then
			tool.Parent = backpack
			offeredTools[toolName] = nil
		end
		slot:SetAttribute("ToolName", nil)
	end

	local rb = slot:FindFirstChild("RemoveBtn")
	if rb then rb:Destroy() end

	local el = slot:FindFirstChild("EmptyLabel")
	if el then el.Visible = true end

	local vp = slot:FindFirstChild("Viewport")
	if vp then
		for _, c in pairs(vp:GetChildren()) do
			if not c:IsA("Camera") then c:Destroy() end
		end
		vp:SetAttribute("CD",  nil)
		vp:SetAttribute("BX",  nil)
		vp.CurrentCamera = nil
	end

	-- Refresh inventory so the tool reappears
	refreshInventory()
end

local function fillSlot(slot, tool)
	if slot:GetAttribute("ToolName") then return false end  -- occupied

	slot:SetAttribute("ItemId", tool:GetAttribute("ItemId"))

	-- Consume: move tool out of backpack (and character) into a hidden folder
	local holder = gui:FindFirstChild("_OfferedHolder")
	if not holder then
		holder      = Instance.new("Folder")
		holder.Name = "_OfferedHolder"
		holder.Parent = gui
	end

	-- Find the actual tool object (backpack or equipped)
	local actualTool = backpack:FindFirstChild(tool.Name)
	if not actualTool and player.Character then
		actualTool = player.Character:FindFirstChild(tool.Name)
	end
	if actualTool then
		local id = actualTool:GetAttribute("ItemId")
		offeredTools[id] = actualTool
		actualTool.Parent       = holder
	end

	local el = slot:FindFirstChild("EmptyLabel")
	if el then el.Visible = false end

	local vp = slot:FindFirstChild("Viewport")
	if vp then renderInViewport(tool, vp) end

	local rb                = Instance.new("TextButton")
	rb.Name                 = "RemoveBtn"
	rb.Size                 = UDim2.new(0,22,0,22)
	rb.Position             = UDim2.new(1,-25,0,3)
	rb.Text                 = "âœ•"
	rb.TextColor3           = Color3.new(1,1,1)
	rb.BackgroundColor3     = Color3.fromRGB(195,45,45)
	rb.BorderSizePixel      = 0
	rb.Font                 = Enum.Font.GothamBold
	rb.TextSize             = 11
	rb.ZIndex               = 30
	rb.Parent               = slot
	addCorner(rb, 11)  -- local helper won't be in scope; inline it
	local rc = Instance.new("UICorner")
	rc.CornerRadius = UDim.new(1,0)
	rc.Parent = rb

	rb.MouseButton1Click:Connect(function()
		clearSlot(slot)
		-- Reset confirm state since the offer changed
		resetConfirmState()
	end)

	-- Refresh inventory to remove the card for this tool
	refreshInventory()
	return true
end

-- â”€â”€â”€ Inventory panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function refreshInventory()
	for _, c in pairs(scrollFrame:GetChildren()) do
		if c:IsA("Frame") then c:Destroy() end
	end

	local allTools = {}
	for _, t in pairs(backpack:GetChildren()) do
		if t:IsA("Tool") and not offeredTools[t.Name] then
			table.insert(allTools, t)
		end
	end
	local char = player.Character
	if char then
		for _, t in pairs(char:GetChildren()) do
			if t:IsA("Tool") and not offeredTools[t.Name] then
				table.insert(allTools, t)
			end
		end
	end

	local totalWidth = 0
	for _, tool in pairs(allTools) do
		local card              = Instance.new("Frame")
		card.Name               = "Item_"..tool.Name
		card.Size               = UDim2.new(0,68,1,-8)
		card.BackgroundColor3   = Color3.fromRGB(32,32,50)
		card.BorderSizePixel    = 0
		card.ZIndex             = 13
		card.Parent             = scrollFrame

		local cc = Instance.new("UICorner")
		cc.CornerRadius = UDim.new(0,7)
		cc.Parent = card

		local vp                = Instance.new("ViewportFrame")
		vp.Size                 = UDim2.new(1,0,1,0)
		vp.BackgroundTransparency = 0
		vp.BackgroundColor3     = Color3.fromRGB(32,32,50)
		vp.Ambient              = Color3.fromRGB(190,190,190)
		vp.LightDirection       = Vector3.new(-1,-2,-1)
		vp.ZIndex               = 14
		vp.Parent               = card

		local vc = Instance.new("UICorner")
		vc.CornerRadius = UDim.new(0,7)
		vc.Parent = vp

		renderInViewport(tool, vp)

		-- Invisible drag trigger sits on top
		local trigger           = Instance.new("TextButton")
		trigger.Size            = UDim2.new(1,0,1,0)
		trigger.BackgroundTransparency = 1
		trigger.Text            = ""
		trigger.ZIndex          = 15
		trigger.Parent          = card

		local capturedTool = tool
		local id = capturedTool:GetAttribute("ItemId")
		table.insert(offered, id)
		trigger.MouseButton1Down:Connect(function()
			-- Create ghost
			local ghost             = Instance.new("Frame")
			ghost.Name              = "DragGhost"
			ghost.Size              = UDim2.new(0,68,0,68)
			ghost.BackgroundColor3  = Color3.fromRGB(45,45,65)
			ghost.BackgroundTransparency = 0.3
			ghost.BorderSizePixel   = 0
			ghost.ZIndex            = 200
			ghost.Parent            = gui

			local gc = Instance.new("UICorner")
			gc.CornerRadius = UDim.new(0,7)
			gc.Parent = ghost

			local gvp               = Instance.new("ViewportFrame")
			gvp.Size                = UDim2.new(1,0,1,0)
			gvp.BackgroundTransparency = 0.3
			gvp.Ambient             = Color3.fromRGB(190,190,190)
			gvp.LightDirection      = Vector3.new(-1,-2,-1)
			gvp.ZIndex              = 201
			gvp.Parent              = ghost

			local gvc = Instance.new("UICorner")
			gvc.CornerRadius = UDim.new(0,7)
			gvc.Parent = gvp

			renderInViewport(capturedTool, gvp)

			local mp        = UserInputService:GetMouseLocation()
			ghost.Position  = UDim2.new(0, mp.X-34, 0, mp.Y-34)
			dragData        = { tool = capturedTool, ghost = ghost }
		end)

		totalWidth = totalWidth + 76
	end

	scrollFrame.CanvasSize = UDim2.new(0, math.max(totalWidth, 10), 1, 0)
end

-- â”€â”€â”€ Drag and drop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

UserInputService.InputChanged:Connect(function(input)
	if input.UserInputType ~= Enum.UserInputType.MouseMovement then return end
	if dragData and dragData.ghost then
		dragData.ghost.Position = UDim2.new(0, input.Position.X-34, 0, input.Position.Y-34)
	end
end)

local function mouseOverFrame(frame)
	if not frame or not frame.Visible then return false end
	local mp  = UserInputService:GetMouseLocation()
	local pos = frame.AbsolutePosition
	local sz  = frame.AbsoluteSize
	return mp.X >= pos.X and mp.X <= pos.X+sz.X
	   and mp.Y >= pos.Y and mp.Y <= pos.Y+sz.Y
end

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
	if not dragData then return end
	if dragData.ghost then dragData.ghost:Destroy() end

	for _, slot in pairs(mySlots) do
		if mouseOverFrame(slot) then
			if fillSlot(slot, dragData.tool) then
				-- Reset confirm since offer changed
				resetConfirmState()
			end
			break
		end
	end
	dragData = nil
end)

-- â”€â”€â”€ Confirm state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function resetConfirmState()
	selfConfirmed    = false
	partnerConfirmed = false
	confirmBtn.BackgroundColor3 = Color3.fromRGB(45,170,75)
	confirmBtn.Text  = "âœ“  Confirm Trade"
	confirmBtn.Active= true
end

local function updateConfirmButton()
	if selfConfirmed and partnerConfirmed then
		confirmBtn.Text = "âœ“  Both Confirmed!"
		confirmBtn.BackgroundColor3 = Color3.fromRGB(30,140,55)
	elseif selfConfirmed then
		confirmBtn.Text = "â³  Waiting for partner..."
		confirmBtn.BackgroundColor3 = Color3.fromRGB(30,110,50)
	elseif partnerConfirmed then
		confirmBtn.Text = "âš   Partner confirmed!"
		confirmBtn.BackgroundColor3 = Color3.fromRGB(45,170,75)
	else
		confirmBtn.Text = "âœ“  Confirm Trade"
		confirmBtn.BackgroundColor3 = Color3.fromRGB(45,170,75)
	end
end

confirmBtn.MouseButton1Click:Connect(function()
	if selfConfirmed then return end
	selfConfirmed = true
	confirmBtn.Active = false

	-- Build list of offered tool names
	local offered = {}
	for _, slot in pairs(mySlots) do
		local name = slot:GetAttribute("ToolName")
		if name then
			local tool = offeredTools[name]  -- this is the actual instance
			table.insert(offered, tool:GetAttribute("ItemId"))
		end
	end

	confirmTrade:FireServer(offered)
	updateConfirmButton()
end)

-- â”€â”€â”€ Dropdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function destroyDropdown()
	if dropdownList then
		dropdownList:Destroy()
		dropdownList = nil
	end
	dropdownOpen = false
end

local function buildDropdown()
	destroyDropdown()

	-- Position the list directly below the dropBtn using absolute position
	local absPos  = dropBtn.AbsolutePosition
	local absSize = dropBtn.AbsoluteSize

	local list              = Instance.new("Frame")
	list.Name               = "DropdownList"
	list.BackgroundColor3   = Color3.fromRGB(28,28,42)
	list.BorderSizePixel    = 0
	list.ZIndex             = 300
	list.Parent             = gui  -- parented to root ScreenGui to avoid any clipping

	local lc = Instance.new("UICorner")
	lc.CornerRadius = UDim.new(0,8)
	lc.Parent = list

	local ls = Instance.new("UIStroke")
	ls.Color     = Color3.fromRGB(80,80,130)
	ls.Thickness = 1
	ls.Parent    = list

	local ll = Instance.new("UIListLayout")
	ll.SortOrder = Enum.SortOrder.LayoutOrder
	ll.Parent    = list

	local count = 0
	for _, p in pairs(Players:GetPlayers()) do
		if p ~= player then
			count += 1
			local btn               = Instance.new("TextButton")
			btn.Name                = "PlayerBtn_"..p.Name
			btn.Size                = UDim2.new(1,0,0,40)
			btn.BackgroundColor3    = Color3.fromRGB(36,36,55)
			btn.BorderSizePixel     = 0
			btn.Text                = "  "..p.DisplayName  -- use display name
			btn.TextXAlignment      = Enum.TextXAlignment.Left
			btn.TextColor3          = Color3.new(1,1,1)
			btn.Font                = Enum.Font.GothamSemibold
			btn.TextSize            = 14
			btn.ZIndex              = 301
			btn.AutoButtonColor     = false
			btn.Parent              = list

			local capturedPlayer = p
			btn.MouseEnter:Connect(function()
				btn.BackgroundColor3 = Color3.fromRGB(55,55,80)
			end)
			btn.MouseLeave:Connect(function()
				btn.BackgroundColor3 = Color3.fromRGB(36,36,55)
			end)
			btn.MouseButton1Click:Connect(function()
				local targetName = capturedPlayer.Name
				destroyDropdown()
				sendRequest:FireServer(targetName)
				dropBtn.Text   = "â³  Waiting for "..capturedPlayer.DisplayName.."..."
				dropBtn.Active = false
			end)
		end
	end

	if count == 0 then
		count = 1
		local noOne             = Instance.new("TextLabel")
		noOne.Size              = UDim2.new(1,0,0,40)
		noOne.BackgroundTransparency = 1
		noOne.Text              = "  No other players online"
		noOne.TextXAlignment    = Enum.TextXAlignment.Left
		noOne.TextColor3        = Color3.fromRGB(110,110,140)
		noOne.Font              = Enum.Font.Gotham
		noOne.TextSize          = 13
		noOne.ZIndex            = 301
		noOne.Parent            = list
	end

	local listH = count * 40
	list.Size     = UDim2.new(0, absSize.X, 0, listH)
	list.Position = UDim2.new(0, absPos.X, 0, absPos.Y + absSize.Y + 4)

	dropdownList = list
	dropdownOpen = true
end

dropBtn.MouseButton1Click:Connect(function()
	if not dropBtn.Active then return end
	if dropdownOpen then destroyDropdown()
	else buildDropdown() end
end)

-- Close dropdown when clicking outside it
UserInputService.InputBegan:Connect(function(input)
	if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
	if not dropdownOpen or not dropdownList then return end
	task.wait()  -- let button clicks fire first
	if not mouseOverFrame(dropdownList) and not mouseOverFrame(dropBtn) then
		destroyDropdown()
	end
end)

-- â”€â”€â”€ Trade menu open/close â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local function openTradeMenu()
	tradeMenu.Visible = true
	dropBtn.Visible   = true

	-- Position dropBtn over the menu's dropdown area
	local mp = tradeMenu.AbsolutePosition
	local ms = tradeMenu.AbsoluteSize
	dropBtn.Position = UDim2.new(0, mp.X + ms.X/2 - 112, 0, mp.Y + 52)

	leftSide.UsernameLabel.Text = player.DisplayName
	refreshInventory()
end

local function closeTradeMenu()
	tradeMenu.Visible = false
	dropBtn.Visible   = false
	destroyDropdown()
end

local function resetTradeMenu()
	closeTradeMenu()
	tradePartnerName = nil
	dropBtn.Text     = "â–¾  Select Player"
	dropBtn.Active   = true
	rightSide.UsernameLabel.Text = "Partner"
	resetConfirmState()
	countdownOverlay.Visible = false

	-- Clear all slots (restores tools to backpack)
	for _, slot in pairs(mySlots) do
		clearSlot(slot)
	end

	-- Return any remaining offered tools to backpack
	for name, tool in pairs(offeredTools) do
		tool.Parent     = backpack
		offeredTools[name] = nil
	end

	-- Clear right side slots
	for i = 1,4 do
		local s = rightGrid:FindFirstChild("Slot"..i)
		if s then
			local el = s:FindFirstChild("EmptyLabel")
			if el then el.Visible = true end
			local vp = s:FindFirstChild("Viewport")
			if vp then
				for _, c in pairs(vp:GetChildren()) do
					if not c:IsA("Camera") then c:Destroy() end
				end
				vp:SetAttribute("CD", nil)
				vp.CurrentCamera = nil
			end
		end
	end
end

-- â”€â”€â”€ Open button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

openBtn.MouseButton1Click:Connect(function()
	if pendingRequesterName then
		reqPrompt.Visible = true
		reqPrompt.RequestLabel.Text = pendingRequesterName.." wants to trade with you!"
	else
		if tradeMenu.Visible then
			closeTradeMenu()
		else
			openTradeMenu()
		end
	end
end)

-- â”€â”€â”€ Request prompt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

reqPrompt.AcceptButton.MouseButton1Click:Connect(function()
	respondRequest:FireServer(true)
	reqPrompt.Visible    = false
	badge.Visible        = false
	pendingRequesterName = nil
	openTradeMenu()
end)

reqPrompt.DeclineButton.MouseButton1Click:Connect(function()
	respondRequest:FireServer(false)
	reqPrompt.Visible    = false
	badge.Visible        = false
	pendingRequesterName = nil
end)

-- â”€â”€â”€ Cancel button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cancelBtn.MouseButton1Click:Connect(function()
	cancelTrade:FireServer()
	resetTradeMenu()
end)

-- â”€â”€â”€ Server event handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

tradeNotify.OnClientEvent:Connect(function(eventType, data)
	if eventType == "Request" then
		pendingRequesterName = data   -- display name sent from server
		badge.Visible        = true

	elseif eventType == "Accepted" then
		tradePartnerName = data
		leftSide.UsernameLabel.Text  = player.DisplayName
		rightSide.UsernameLabel.Text = data
		dropBtn.Text   = "Trading with "..data
		dropBtn.Active = false
		destroyDropdown()
		openTradeMenu()

	elseif eventType == "Declined" then
		dropBtn.Text   = "â–¾  Select Player"
		dropBtn.Active = true

	elseif eventType == "PartnerConfirmed" then
		partnerConfirmed = true
		updateConfirmButton()

	elseif eventType == "Countdown" then
		countdownOverlay.Visible = true
		countdownLbl.Text        = tostring(data)

	elseif eventType == "TradeComplete" then
		countdownOverlay.Visible = false
		resetTradeMenu()

	elseif eventType == "Cancelled" then
		countdownOverlay.Visible = false
		resetTradeMenu()
	end
end)

-- Keep inventory in sync
backpack.ChildAdded:Connect(function()
	if tradeMenu.Visible then refreshInventory() end
end)
backpack.ChildRemoved:Connect(function()
	if tradeMenu.Visible then refreshInventory() end
end)

r|M|WeatherSystem
-- WeatherSystem (ModuleScript) -- place in ReplicatedStorage
-- Manages weather states that enable Limited mutations during events

local WeatherSystem = {}

-- ============================================================
--  WEATHER DEFINITIONS
--  Each weather maps to one Limited mutation from the wiki.
--  limitedChance = rolls out of 1000 during active weather.
-- ============================================================
WeatherSystem.WEATHER_TYPES = {
	["Clear"] = {
		displayName   = "â˜€ï¸ Clear",
		mutation      = nil,       -- no limited mutation during clear
		limitedChance = 0,
		color         = Color3.fromRGB(135, 206, 235),
		description   = "Normal spawns.",
	},
	["Bloodstorm"] = {
		displayName   = "ðŸ©¸ Bloodstorm",
		mutation      = "Bloodrot",
		limitedChance = 150,        -- 4% chance per spawn during event
		color         = Color3.fromRGB(139, 0, 0),
		description   = "Dark clouds bring Bloodrot mutations!",
	},
	["Rain"] = {
		displayName   = "ðŸŒ§ï¸ Rain",
		mutation      = "Wet",
		limitedChance = 150,        -- 2% chance per spawn during event
		color         = Color3.fromRGB(135, 206, 235),
		description   = "Rain brings Wet mutations!",
	},

	["Candyland"] = {
		displayName   = "ðŸ¬ Candy Rain",
		mutation      = "Candy",
		limitedChance = 150,        -- 2.5% â€” rarer because 4x mult
		color         = Color3.fromRGB(255, 182, 193),
		description   = "Sweet showers bring Candy mutations!",
	},
	["Volcanic"] = {
		displayName   = "ðŸŒ‹ Volcanic Eruption",
		mutation      = "Lava",
		limitedChance = 150,        -- ~1.8% â€” 6x mult
		color         = Color3.fromRGB(255, 69, 0),
		description   = "Scorching heat brings Lava mutations!",
	},
	["Galactic"] = {
		displayName   = "ðŸŒŒ Galactic Storm",
		mutation      = "Galaxy",
		limitedChance = 150,        -- ~1.5% â€” 7x mult
		color         = Color3.fromRGB(75, 0, 130),
		description   = "Cosmic energy brings Galaxy mutations!",
	},
	["YinYang"] = {
		displayName   = "â˜¯ï¸ Balance Shift",
		mutation      = "Yin-Yang",
		limitedChance = 150,        -- ~1.2% â€” 7.5x mult
		color         = Color3.fromRGB(50, 50, 50),
		description   = "Reality splits, bringing Yin-Yang mutations!",
	},
	["Radioactive"] = {
		displayName   = "â˜¢ï¸ Toxic Fallout",
		mutation      = "Radioactive",
		limitedChance = 150,         -- 0.8% â€” 8.5x mult (near-Rainbow tier)
		color         = Color3.fromRGB(0, 255, 50),
		description   = "Toxic rain brings Radioactive mutations!",
	},
}

-- ============================================================
--  WEATHER EVENT RARITY (WEIGHTS)
--  Higher number = more common. 
--  (e.g., 4 means it gets added to the selection pool 4 times)
-- ============================================================
WeatherSystem.EVENT_WEIGHTS = {
	["Bloodstorm"]  = 1,
	["Candyland"]   = 1,
	["Volcanic"]    = 1,
	["Galactic"]    = 1,
	["YinYang"]     = 1,
	["Radioactive"] = 1,
	["Rain"]        = 1, -- Set higher to make Rain more common!
}

-- Auto-generate the WEATHER_EVENTS array based on the weights above.
-- This keeps your external scripts working perfectly without modifications!
WeatherSystem.WEATHER_EVENTS = {}
for weatherName, weight in pairs(WeatherSystem.EVENT_WEIGHTS) do
	for i = 1, weight do
		table.insert(WeatherSystem.WEATHER_EVENTS, weatherName)
	end
end

-- Duration config (seconds)
WeatherSystem.EVENT_DURATION  = 15   -- how long each weather event lasts
WeatherSystem.CLEAR_DURATION  = 15    -- gap between events

-- ============================================================
--  LIMITED MUTATION MULTIPLIERS
-- ============================================================
WeatherSystem.LIMITED_MULTIPLIERS = {
	["Bloodrot"]    = 2.0,
	["Candy"]       = 4.0,
	["Lava"]        = 6.0,
	["Galaxy"]      = 7.0,
	["Yin-Yang"]    = 7.5,
	["Radioactive"] = 8.5,
	["Wet"] = 1.5
}

-- ============================================================
--  LIMITED MUTATION VISUALS
--  Colors/effects applied server-side (SurfaceAppearance removed)
-- ============================================================
WeatherSystem.LIMITED_VISUALS = {
	["Bloodrot"] = {
		color       = Color3.fromRGB(100, 0, 0),
		material    = Enum.Material.SmoothPlastic,
		reflectance = 0,
		animated    = false,
	},
	["Candy"] = {
		color       = Color3.fromRGB(255, 105, 180),
		material    = Enum.Material.SmoothPlastic,
		reflectance = 0.1,
		animated    = false,
	},
	["Lava"] = {
		color       = Color3.fromRGB(255, 80, 0),
		material    = Enum.Material.Neon,   -- glowing neon orange
		reflectance = 0,
		animated    = false,
	},
	["Galaxy"] = {
		color       = Color3.fromRGB(138, 43, 226),
		material    = Enum.Material.Neon,
		reflectance = 0,
		animated    = "galaxy",   -- slow purple pulse
	},
	["Yin-Yang"] = {
		color       = nil,        -- handled specially (alternating B&W)
		material    = Enum.Material.SmoothPlastic,
		reflectance = 0,
		animated    = "yinyang",
	},
	["Radioactive"] = {
		color       = Color3.fromRGB(0, 255, 50),
		material    = Enum.Material.Neon,
		reflectance = 0,
		animated    = "radioactive",  -- fast green pulse
	},
	["Wet"] = {
		color       = Color3.fromRGB(84, 130, 255),
		material    = Enum.Material.Neon,
		reflectance = 0,
		animated    = "wet",  -- fast green pulse
	}
}

-- ============================================================
--  STATE  (runtime, not saved)
-- ============================================================
WeatherSystem._currentWeather  = "Clear"
WeatherSystem._weatherEndTime  = 0
WeatherSystem._lastEventIndex  = 0

-- ============================================================
--  PUBLIC API
-- ============================================================

function WeatherSystem.getCurrentWeather()
	return WeatherSystem._currentWeather
end

function WeatherSystem.getWeatherData(weatherName)
	return WeatherSystem.WEATHER_TYPES[weatherName]
end

-- Returns the limited mutation name if one is active, else nil
function WeatherSystem.getActiveLimitedMutation()
	local data = WeatherSystem.WEATHER_TYPES[WeatherSystem._currentWeather]
	if data then return data.mutation end
	return nil
end

-- Returns limitedChance (out of 1000) for current weather
function WeatherSystem.getLimitedChance()
	local data = WeatherSystem.WEATHER_TYPES[WeatherSystem._currentWeather]
	if data then return data.limitedChance end
	return 0
end

return WeatherSystem
r|M|NumberFormat
-- Shared number formatting module
-- Use this anywhere you need to format numbers with suffixes

local NumberFormat = {}

local suffixes = {
	"", "K", "M", "B", "T",
	"Qa", "Qi", "Sx", "Sp", "Oc", "No",
	"Dc", "Ud", "Dd", "Td", "Qd", "QiD",
	"SxD", "SpD", "OcD", "NoD"
}

function NumberFormat.format(num)
	-- Safety check just in case a nil value passes through
	if not num then return "0" end

	if num < 1000 then
		return tostring(math.floor(num))
	end

	local magnitude = math.floor(math.log10(num) / 3)

	-- [THE FIX]: Add +1 because Lua tables start at index 1!
	-- magnitude 1 (Thousands) + 1 = Index 2 ("K")
	local suffix = suffixes[magnitude + 1] or ("e" .. (magnitude * 3))

	local short = num / (1000 ^ magnitude)

	-- Format to 2 decimal places, then remove unnecessary ".00"
	-- This turns "10.00M" into "10M", while keeping "1.25M" intact
	local formatted = string.format("%.2f", short):gsub("%.?0+$", "")

	return formatted .. suffix
end

return NumberFormat
e|S|tradeserver
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MarketplaceService = game:GetService("MarketplaceService")

local getPassesFunc = ReplicatedStorage:FindFirstChild("GetPasses")
if not getPassesFunc then
	getPassesFunc = Instance.new("RemoteFunction")
	getPassesFunc.Name = "GetPasses"
	getPassesFunc.Parent = ReplicatedStorage
end

local PYTHON_URL = "http://127.0.0.1:8080/get-passes/"

local function fetchPasses(player)
	print("ðŸ”´ [1] Lua requesting Manual List...")

	local response
	local success, err = pcall(function()
		response = HttpService:GetAsync(PYTHON_URL .. player.UserId)
	end)

	if not success then
		warn("Connection Error: " .. err)
		return {}
	end

	local data = HttpService:JSONDecode(response)
	local rawItems = data.passes or {}
	local finalItems = {}

	print("ðŸŸ¢ [2] Python sent " .. #rawItems .. " IDs. Verifying...")

	for _, item in ipairs(rawItems) do
		local id = item.id

		-- STRICTLY CHECK AS GAMEPASS
		local infoSuccess, info = pcall(function()
			return MarketplaceService:GetProductInfo(id, Enum.InfoType.GamePass)
		end)

		if infoSuccess and info then
			print("   -> LOADED: " .. info.Name .. " (" .. (info.PriceInRobux or 0) .. " R$)")

			table.insert(finalItems, {
				id = id,
				name = info.Name,
				price = info.PriceInRobux or 0,
				type = "GamePass"
			})
		else
			warn("   -> FAILED to verify ID: " .. id .. " (Check if it's really a GamePass?)")
		end
	end

	print("ðŸŸ¢ [3] Sending " .. #finalItems .. " items to Booth.")
	return finalItems
end

getPassesFunc.OnServerInvoke = function(player)
	return fetchPasses(player)
end
e|S|ThrowingSystem
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local StarterPack = game:GetService("StarterPack")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

-- EVENTS
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local bounceNotificationEvent = remoteEvents:WaitForChild("BounceNotif")
local capacityFullEvent = remoteEvents:WaitForChild("CapacityFullEvent") -- NEW EVENT
local throwMemeEvent = remoteEvents:WaitForChild("ThrowMemeEvent")

-- Constants
local MAX_DISTANCE = 500 
local RELOAD_TIME = 0.8

local function calculateTrajectory(powerPercent, strength, rebirthMultiplier)
	local baseDistance = MAX_DISTANCE * powerPercent
	local finalDistance = baseDistance * strength * rebirthMultiplier
	local accuracy = powerPercent
	return finalDistance, accuracy
end

-- Function to find the brainrot model from any part within it
local function findBrainrotModel(part)
	local current = part.Parent
	for i = 1, 5 do
		if current and current:IsA("Model") and current:GetAttribute("Rarity") ~= nil then
			return current
		end
		if current then
			current = current.Parent
		else
			break
		end
	end
	return nil
end

-- Function to count how many brainrots player currently has
local function countPlayerBrainrots(player)
	local count = 0

	local backpack = player:FindFirstChild("Backpack")
	if backpack then
		for _, tool in pairs(backpack:GetChildren()) do
			if tool:IsA("Tool") and tool:GetAttribute("Rarity") then
				count = count + 1
			end
		end
	end

	-- Check equipped tool
	if player.Character then
		local equippedTool = player.Character:FindFirstChildOfClass("Tool")
		if equippedTool and equippedTool:GetAttribute("Rarity") then
			count = count + 1
		end
	end

	return count
end


local function canCollectBrainrot(player, brainrotModel)
	local requirement = brainrotModel:GetAttribute("RebirthRequirement") or 0

	if requirement == 0 then
		return true -- Common brainrots always collectible
	end

	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then return false end

	local rebirths = leaderstats:FindFirstChild("Rebirths")
	if not rebirths then return false end

	if rebirths.Value < requirement then
		-- Player doesn't have enough rebirths
		warn("ðŸ”’ " .. player.Name .. " needs " .. requirement .. " rebirths to collect this brainrot!")
		return false
	end

	return true
end






-- Function to convert brainrot model into a tool and add to player's inventory
local function collectBrainrot(player, brainrotModel)
	
	
	-- CHECK LOCK STATUS FIRST
	if not canCollectBrainrot(player, brainrotModel) then
		print("âŒ " .. player.Name .. " cannot collect locked brainrot: " .. brainrotModel.Name)
		return false
	end
	-- Check capacity SECOND
	local currentCount = countPlayerBrainrots(player)
	local maxCapacity = player:GetAttribute("BrainrotCapacity") or 1

	if currentCount >= maxCapacity then
		print("âŒ " .. player.Name .. " is at capacity (" .. currentCount .. "/" .. maxCapacity .. ")")

		-- [[ NEW FEATURE: FIRE CAPACITY GUI ]] --
		capacityFullEvent:FireClient(player)
		return false
	end

	local rarity = brainrotModel:GetAttribute("Rarity") or "Common"

	-- COPY THE MUTATION
	local mutation = brainrotModel:GetAttribute("Mutation")
	local mutationMult = brainrotModel:GetAttribute("MutationMult")

	-- Clone world model
	local clone = brainrotModel:Clone()
	clone.Parent = nil

	-- Gather BaseParts
	local parts = {}
	for _, obj in ipairs(clone:GetDescendants()) do
		if obj:IsA("BasePart") then
			table.insert(parts, obj)
		end
	end

	if #parts == 0 then
		warn("Brainrot has no BaseParts:", brainrotModel.Name)
		clone:Destroy()
		return false
	end

	-- Choose handle
	local handle = parts[1]
	handle.Name = "Handle"
	handle.Anchored = false
	handle.CanCollide = false
	handle.CanTouch = false

	-- Create Tool
	local tool = Instance.new("Tool")
	tool.Name = brainrotModel.Name
	tool.RequiresHandle = true
	tool.CanBeDropped = true
	tool:SetAttribute("Rarity", rarity)
	
	--For trading
	tool:SetAttribute("ItemId", HttpService:GenerateGUID(false))


	-- PASTE THE MUTATION
	if mutation then
		tool:SetAttribute("Mutation", mutation)
		if mutationMult then
			tool:SetAttribute("MutationMult", mutationMult)
		end
		print("âœ¨ SAVED MUTATION: " .. mutation .. " on " .. tool.Name)
	end

	-- Parent handle
	handle.Parent = tool

	-- Weld remaining parts
	for _, part in ipairs(parts) do
		if part ~= handle then
			part.Anchored = false
			part.CanCollide = false
			part.CanTouch = false
			part.Parent = tool

			local weld = Instance.new("WeldConstraint")
			weld.Part0 = handle
			weld.Part1 = part
			weld.Parent = handle
		end
	end

	-- Destroy leftover containers
	clone:Destroy()

	-- Give tool to player
	tool.Parent = player:WaitForChild("Backpack")

	-- Remove world instance
	brainrotModel:Destroy()

	local newCount = currentCount + 1
	print("âœ“ Brainrot added to Backpack:", tool.Name, "(" .. newCount .. "/" .. maxCapacity .. ")")
	return true
end

local function trackProjectile(player, projectile, detector, expectedDistance)
	local startPosition = projectile.Position
	local hoopsHit = {}
	local maxHeight = projectile.Position.Y
	local collectedBrainrots = {}

	-- TIME TRACKING VARIABLES
	local launchTime = os.clock()
	local groundHitTime = nil

	local heartbeatConnection
	local detectorConnection

	detectorConnection = detector.Touched:Connect(function(hit)
		if hit:IsDescendantOf(player.Character) then return end

		local currentTime = os.clock()

		-- Check for brainrot collision
		local brainrotModel = findBrainrotModel(hit)

		if brainrotModel then
			if not collectedBrainrots[brainrotModel] then

				-- Logic: Bounce vs Direct Hit
				local isBounce = false
				if groundHitTime ~= nil then
					local timeSinceGroundHit = currentTime - groundHitTime
					if timeSinceGroundHit > 0.15 then
						isBounce = true
					end
				end

				if isBounce then
					-- CASE 1: REAL BOUNCE (Notification ONLY)
					bounceNotificationEvent:FireClient(player) 
					print("Bounce Detected! (Notification sent)")
					collectedBrainrots[brainrotModel] = true
				else
					-- CASE 2: DIRECT HIT (Collect item)
					-- NOTE: collectBrainrot now handles the capacity check internally!
					local success = collectBrainrot(player, brainrotModel)

					-- If we successfully collected OR failed due to capacity, we mark it as processed
					-- so we don't trigger it again instantly
					collectedBrainrots[brainrotModel] = true
				end
			end
			return 
		end

		-- Check for hoop collision
		if hit.Name == "HoopPart" and hit.Parent and not hoopsHit[hit.Parent] then
			local hoop = hit.Parent
			local tier = hoop:FindFirstChild("Tier")
			if tier and tier:IsA("IntValue") then
				hoopsHit[hoop] = tier.Value
				hit.BrickColor = BrickColor.new("Bright green")
				task.delay(0.5, function()
					if hit then hit.BrickColor = BrickColor.new("Really red") end
				end)
			end
			return
		end

		-- Ground/Wall Detection
		if hit.CanCollide and hit.Name ~= "ProjectileDetector" then
			if groundHitTime == nil and (currentTime - launchTime > 0.1) then
				groundHitTime = currentTime
			end
		end
	end)

	-- Monitor projectile height and landing
	heartbeatConnection = RunService.Heartbeat:Connect(function()
		if not projectile or not projectile.Parent then
			heartbeatConnection:Disconnect()
			if detectorConnection then detectorConnection:Disconnect() end
			return
		end

		if projectile.Position.Y > maxHeight then
			maxHeight = projectile.Position.Y
		end

		if projectile.Position.Y < -50 or projectile.AssemblyLinearVelocity.Magnitude < 1 then
			heartbeatConnection:Disconnect()
			if detectorConnection then detectorConnection:Disconnect() end

			local endPosition = projectile.Position
			local distanceTraveled = (endPosition - startPosition).Magnitude
			local moneyEarned = math.floor(distanceTraveled)

			if distanceTraveled > 5 then
				print("SERVER: " .. player.Name .. " threw " .. math.floor(distanceTraveled) .. " studs, earned $" .. moneyEarned)
			end

			task.wait(2)
			if detector then detector:Destroy() end
			if projectile then projectile:Destroy() end
		end
	end)
end

local function reloadTool(player, toolName)
	task.wait(RELOAD_TIME)
	local originalToolTemplate = StarterPack:FindFirstChild(toolName)
	if originalToolTemplate and player.Character then
		local newTool = originalToolTemplate:Clone()

		-- GET REBIRTH COUNT FOR SCALING
		local leaderstats = player:FindFirstChild("leaderstats")
		local rebirthCount = 0
		if leaderstats then
			local rebirths = leaderstats:FindFirstChild("Rebirths")
			if rebirths then
				rebirthCount = rebirths.Value
			end
		end

		-- Calculate scale for 2x volume per rebirth
		local volumeMultiplier = 1.5 ^ rebirthCount
		local scaleMultiplier = volumeMultiplier ^ (1/3)

		if rebirthCount > 0 then
			print("ðŸŽ¯ Scaling tool for " .. player.Name .. ": " .. string.format("%.2f", scaleMultiplier) .. "x (" .. volumeMultiplier .. "x volume)")

			-- Scale all parts in the tool
			for _, descendant in pairs(newTool:GetDescendants()) do
				if descendant:IsA("BasePart") then
					descendant.Size = descendant.Size * scaleMultiplier
					-- IMPORTANT: Keep CanCollide false while held to prevent floor clipping
					descendant.CanCollide = false
					descendant.Massless = true
				elseif descendant:IsA("SpecialMesh") then
					descendant.Scale = descendant.Scale * scaleMultiplier
				end
			end
		else
			-- Make sure parts don't collide when held
			for _, descendant in pairs(newTool:GetDescendants()) do
				if descendant:IsA("BasePart") then
					descendant.CanCollide = false
					descendant.Massless = true
				end
			end
		end

		newTool.Parent = player.Backpack
		local humanoid = player.Character:FindFirstChild("Humanoid")
		if humanoid then humanoid:EquipTool(newTool) end
	else
		warn("Could not find tool " .. toolName .. " in StarterPack to reload!")
	end
end

local function launchProjectile(player, powerPercent, distance, accuracy, targetPosition)
	local character = player.Character
	if not character then return end

	local tool = character:FindFirstChildOfClass("Tool")
	if not tool then return end

	local handle = tool:FindFirstChild("Handle")
	if not handle then return end

	local toolName = tool.Name
	local startPos = handle.Position

	local projectile = handle
	projectile.Parent = Workspace 
	projectile.Name = "MemeProjectile"
	projectile.Anchored = false
	projectile.CanCollide = true
	projectile.CanTouch = true
	
	-- In your ThrowingSystem, in the launchProjectile function:
	-- Right after you set projectile properties, add:

	local PhysicsService = game:GetService("PhysicsService")

	-- Assign projectile to Projectiles collision group
	PhysicsService:SetPartCollisionGroup(projectile, "Projectiles")

	-- Also assign the detector
	PhysicsService:SetPartCollisionGroup(detector, "Projectiles")

	-- GET REBIRTH COUNT FOR DETECTOR SCALING
	local leaderstats = player:FindFirstChild("leaderstats")
	local rebirthCount = 0
	if leaderstats then
		local rebirths = leaderstats:FindFirstChild("Rebirths")
		if rebirths then
			rebirthCount = rebirths.Value
		end
	end

	-- Calculate detector scale (2x volume per rebirth)
	local volumeMultiplier = 2 ^ rebirthCount
	local detectorScale = volumeMultiplier ^ (1/3)

	-- Scale detector for collision detection
	local baseDetectorSize = 8
	local detectorSize = baseDetectorSize * detectorScale

	local detector = Instance.new("Part")
	detector.Name = "ProjectileDetector"
	detector.Size = Vector3.new(detectorSize, detectorSize, detectorSize) 
	detector.Transparency = 1
	detector.CanCollide = false
	detector.CanTouch = true
	detector.Massless = true
	detector.CFrame = projectile.CFrame
	detector.Parent = Workspace

	print("ðŸŽ¯ Detector size: " .. detectorSize .. " (" .. volumeMultiplier .. "x volume)")

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = projectile
	weld.Part1 = detector
	weld.Parent = projectile

	for _, child in pairs(projectile:GetChildren()) do
		if child:IsA("Script") or child:IsA("LocalScript") or child:IsA("Motor6D") then
			child:Destroy()
		end
	end

	tool:Destroy()

	local directionVector = (targetPosition - startPos).Unit
	local arcDirection = (directionVector + Vector3.new(0, 0.2, 0)).Unit
	local deviation = (1 - accuracy) * 0.3
	local randomWobble = Vector3.new(
		(math.random() - 0.5) * deviation,
		(math.random() - 0.5) * deviation,
		(math.random() - 0.5) * deviation
	)

	local finalDirection = (arcDirection + randomWobble).Unit
	local speed = 50 + (powerPercent * 150) 
	local velocity = finalDirection * speed

	projectile.AssemblyLinearVelocity = velocity
	projectile:SetNetworkOwner(nil)

	trackProjectile(player, projectile, detector, distance)

	task.spawn(function() 
		reloadTool(player, toolName)
	end)
end

local function launchProjectile(player, powerPercent, distance, accuracy, targetPosition)
	local character = player.Character
	if not character then return end

	local tool = character:FindFirstChildOfClass("Tool") -- FIXED: was "Banana"
	if not tool then return end

	local handle = tool:FindFirstChild("Handle")
	if not handle then return end

	local toolName = tool.Name
	local startPos = handle.Position

	local projectile = handle
	projectile.Parent = Workspace 
	projectile.Name = "MemeProjectile"
	projectile.Anchored = false
	projectile.CanCollide = true
	projectile.CanTouch = true

	local detector = Instance.new("Part")
	detector.Name = "ProjectileDetector"
	detector.Size = Vector3.new(8, 8, 8) 
	detector.Transparency = 1
	detector.CanCollide = false
	detector.CanTouch = true
	detector.Massless = true
	detector.CFrame = projectile.CFrame
	detector.Parent = Workspace

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = projectile
	weld.Part1 = detector
	weld.Parent = projectile

	for _, child in pairs(projectile:GetChildren()) do
		if child:IsA("Script") or child:IsA("LocalScript") or child:IsA("Motor6D") then
			child:Destroy()
		end
	end

	tool:Destroy()

	local directionVector = (targetPosition - startPos).Unit
	local arcDirection = (directionVector + Vector3.new(0, 0.2, 0)).Unit
	local deviation = (1 - accuracy) * 0.3
	local randomWobble = Vector3.new(
		(math.random() - 0.5) * deviation,
		(math.random() - 0.5) * deviation,
		(math.random() - 0.5) * deviation
	)

	local finalDirection = (arcDirection + randomWobble).Unit
	local speed = 50 + (powerPercent * 150) 
	local velocity = finalDirection * speed

	projectile.AssemblyLinearVelocity = velocity
	projectile:SetNetworkOwner(nil)

	trackProjectile(player, projectile, detector, distance)

	task.spawn(function() 
		reloadTool(player, toolName)
	end)
end

throwMemeEvent.OnServerEvent:Connect(function(player, powerPercent, targetPosition)
	if type(powerPercent) ~= "number" then return end
	if typeof(targetPosition) ~= "Vector3" then
		if player.Character and player.Character.PrimaryPart then
			targetPosition = player.Character.PrimaryPart.Position + (player.Character.PrimaryPart.CFrame.LookVector * 50)
		else
			return 
		end
	end
	local strength = 1
	local rebirthMultiplier = 1
	local distance, accuracy = calculateTrajectory(powerPercent, strength, rebirthMultiplier)
	launchProjectile(player, powerPercent, distance, accuracy, targetPosition)
end)

print("ThrowingSystem loaded!")
e|S|Spawning System
local replicatedstorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local PhysicsService = game:GetService("PhysicsService") -- ADDED

local brainrotsfolder = replicatedstorage:FindFirstChild("Brainrot pack1") or replicatedstorage:WaitForChild("Brainrot pack1")
local brainrots = brainrotsfolder:GetChildren()
local WeatherSystem = require(game.ReplicatedStorage:WaitForChild("WeatherSystem"))

-- Wait for collision groups to be set up
repeat task.wait(0.1) until pcall(function() 
	PhysicsService:GetCollisionGroupId("NPCs") 
end)
print("âœ… Collision groups detected, spawning system ready")

-- Rebirth requirements for each rarity
local RARITY_REQUIREMENTS = {
	["Common"] = 0,
	["Rare"] = 1,
	["Epic"] = 3,
	["Legendary"] = 5,
	["Mythic"] = 10,
	["Brainrot God"] = 25,
	["Secret"] = 50,
	["OG"] = 100,
}

-- Ensure RemoteEvents exist
local Remotes = game.ReplicatedStorage:FindFirstChild("RemoteEvents")
if not Remotes then
	Remotes = Instance.new("Folder", game.ReplicatedStorage)
	Remotes.Name = "RemoteEvents"
end

local function getRemote(name)
	local r = Remotes:FindFirstChild(name)
	if not r then
		r = Instance.new("RemoteEvent", Remotes)
		r.Name = name
	end
	return r
end

local Remotes            = game.ReplicatedStorage:WaitForChild("RemoteEvents")
local event              = Remotes:WaitForChild("randombrainrot")
local autospawn          = Remotes:WaitForChild("AutoSpawn")
local spawnSpecificEvent = Remotes:WaitForChild("SpawnSpecificBrainrot")

local PLATFORM_CENTER_X = 0
local PLATFORM_CENTER_Z = 0
local PLATFORM_RADIUS = 120
local PLATFORM_Y = 1

local AUTO_SPAWN_ENABLED = true
local AUTO_SPAWN_INTERVAL = 3 
local DESPAWN_TIME = {
	["Common"] = 120, ["Rare"] = 120, ["Epic"] = 120, ["Legendary"] = 120,
	["Mythic"] = 120, ["Secret"] = 120, ["OG"] = 120, ["Brainrot God"] = 120,
}
local MAX_BRAINROTS = 25 

local activeBrainrots = {}

local RARITY_COLORS = {
	["Common"] = Color3.fromRGB(0, 255, 0),
	["Rare"] = Color3.fromRGB(0, 100, 255),
	["Epic"] = Color3.fromRGB(150, 0, 255),
	["Legendary"] = Color3.fromRGB(255, 255, 0),
	["Mythic"] = Color3.fromRGB(255, 0, 0),
	["Brainrot God"] = "Rainbow",
	["Secret"] = Color3.fromRGB(30, 30, 30),
	["OG"] = "Split",
}

local MUTATION_COLORS = {
	-- Permanent
	["Gold"]        = Color3.fromRGB(255, 215, 0),
	["Diamond"]     = Color3.fromRGB(185, 242, 255),
	["Rainbow"]     = "Rainbow",
	-- Limited (weather-gated)
	["Bloodrot"]    = Color3.fromRGB(100, 0, 0),
	["Candy"]       = Color3.fromRGB(255, 105, 180),
	["Lava"]        = Color3.fromRGB(255, 80, 0),
	["Galaxy"]      = Color3.fromRGB(138, 43, 226),
	["Yin-Yang"]    = "YinYang",
	["Radioactive"] = Color3.fromRGB(0, 255, 50),
	["Wet"] = Color3.fromRGB(84, 130, 255)
}

local MUTATION_RATES = {
	-- Permanent mutations â€” always in the pool
	["Rainbow"]  = 5,
	["Diamond"]  = 102,
	["Gold"]     = 250,
	-- Limited mutations â€” 0 base rate; boosted by weather system
	["Bloodrot"]    = 0,
	["Candy"]       = 0,
	["Lava"]        = 0,
	["Galaxy"]      = 0,
	["Yin-Yang"]    = 0,
	["Radioactive"] = 0,
	["Wet"] = 0
}

local MUTATION_MULTIPLIERS = {
	-- Permanent
	["Gold"]        = 1.25,
	["Diamond"]     = 1.50,
	["Rainbow"]     = 10.0,
	-- Limited
	["Bloodrot"]    = 2.0,
	["Candy"]       = 4.0,
	["Lava"]        = 6.0,
	["Galaxy"]      = 7.0,
	["Yin-Yang"]    = 7.5,
	["Radioactive"] = 8.5,
	["Wet"] = 1.5
}

local RARITY_SPEEDS = {
	["Common"] = 24, 
	["Rare"] = 36, 
	["Epic"] = 48, 
	["Legendary"] = 60,
	["Mythic"] = 75, 
	["Brainrot God"] = 90,
	["BrainrotGod"] = 90,
	["Secret"] = 100, 
	["OG"] = 150,
}

local function getValidSpawnPosition()
	local x = math.random(-256, 256)
	local z = math.random(-256, 256)
	return Vector3.new(x, PLATFORM_Y + 5, z)
end

local function getMutation()
	local roll = math.random(1, 1000)
	if roll <= MUTATION_RATES["Rainbow"] then
		return "Rainbow"
	elseif roll <= MUTATION_RATES["Rainbow"] + MUTATION_RATES["Diamond"] then
		return "Diamond"
	elseif roll <= MUTATION_RATES["Rainbow"] + MUTATION_RATES["Diamond"] + MUTATION_RATES["Gold"] then
		return "Gold"
	end
	return nil
end

local function animateRainbow(textLabel)
	task.spawn(function()
		local hue = 0
		while textLabel and textLabel.Parent do
			hue = (hue + 0.01) % 1
			textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
			task.wait(0.05)
		end
	end)
end

local function animateRainbowModel(model)
	task.spawn(function()
		local hue = 0
		local parts = {}
		for _, descendant in pairs(model:GetDescendants()) do
			if descendant:IsA("BasePart") then table.insert(parts, descendant) end
		end
		while model and model.Parent do
			hue = (hue + 0.01) % 1
			local rainbowColor = Color3.fromHSV(hue, 1, 1)
			for _, part in pairs(parts) do
				if part and part.Parent then 
					part.Color = rainbowColor 
				end
			end
			task.wait(0.05)
		end
	end)
end

local function applyMonochromeFilter(brainrotModel)
	for _, descendant in pairs(brainrotModel:GetDescendants()) do
		if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
			local originalColor = descendant.Color
			local gray = (originalColor.R + originalColor.G + originalColor.B) / 3
			descendant.Color = Color3.new(gray, gray, gray)
			descendant.Material = Enum.Material.SmoothPlastic

			local surfaceAppearance = descendant:FindFirstChildOfClass("SurfaceAppearance")
			if surfaceAppearance then
				surfaceAppearance:Destroy()
			end
		elseif descendant:IsA("SpecialMesh") then
			descendant.TextureId = ""
		end
	end
end

local function applyMutationVisuals(brainrotModel, mutation)
	if not mutation then return end

	local function applyColorToPart(part, color, material, reflectance)
		if part:IsA("BasePart") or part:IsA("MeshPart") then
			part.Color = color
			if material then part.Material = material end
			if reflectance then part.Reflectance = reflectance end

			local surfaceAppearance = part:FindFirstChildOfClass("SurfaceAppearance")
			if surfaceAppearance then
				surfaceAppearance:Destroy()
			end
		end
	end

	if mutation == "Rainbow" then
		animateRainbowModel(brainrotModel)
		for _, descendant in pairs(brainrotModel:GetDescendants()) do
			if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
				local surfaceAppearance = descendant:FindFirstChildOfClass("SurfaceAppearance")
				if surfaceAppearance then
					surfaceAppearance:Destroy()
				end
			end
		end
	elseif mutation == "Gold" then
		for _, descendant in pairs(brainrotModel:GetDescendants()) do
			applyColorToPart(descendant, Color3.fromRGB(255, 215, 0), Enum.Material.SmoothPlastic, nil)
			if descendant:IsA("SpecialMesh") then
				descendant.TextureId = ""
			end
		end
	elseif mutation == "Diamond" then
		for _, descendant in pairs(brainrotModel:GetDescendants()) do
			applyColorToPart(descendant, Color3.fromRGB(185, 242, 255), Enum.Material.SmoothPlastic, 0.3)
			if descendant:IsA("SpecialMesh") then
				descendant.TextureId = ""
			end
		end
	end
end

local function animateGalaxy(model)
	task.spawn(function()
		local parts = {}
		for _, d in pairs(model:GetDescendants()) do
			if d:IsA("BasePart") then table.insert(parts, d) end
		end
		local t = 0
		while model and model.Parent do
			t += 0.02
			local brightness = 0.5 + 0.5 * math.sin(t)
			local col = Color3.fromRGB(
				math.floor(75  + 63  * brightness),
				math.floor(0   + 0   * brightness),
				math.floor(130 + 100 * brightness)
			)
			for _, p in pairs(parts) do
				if p and p.Parent then p.Color = col end
			end
			task.wait(0.05)
		end
	end)
end

local function animateYinYang(model)
	task.spawn(function()
		local parts = {}
		for _, d in pairs(model:GetDescendants()) do
			if d:IsA("BasePart") then table.insert(parts, d) end
		end
		local flip = false
		local timer = 0
		while model and model.Parent do
			timer += 0.05
			if timer >= 0.5 then
				timer = 0
				flip = not flip
				local col = flip and Color3.new(1,1,1) or Color3.new(0,0,0)
				for _, p in pairs(parts) do
					if p and p.Parent then p.Color = col end
				end
			end
			task.wait(0.05)
		end
	end)
end

local function animateRadioactive(model)
	task.spawn(function()
		local parts = {}
		for _, d in pairs(model:GetDescendants()) do
			if d:IsA("BasePart") then table.insert(parts, d) end
		end
		local t = 0
		while model and model.Parent do
			t += 0.08
			local brightness = 0.5 + 0.5 * math.sin(t)
			local g = math.floor(150 + 105 * brightness)
			local col = Color3.fromRGB(0, g, 0)
			for _, p in pairs(parts) do
				if p and p.Parent then p.Color = col end
			end
			task.wait(0.05)
		end
	end)
end

local function applyLimitedMutationVisuals(brainrotModel, mutation)
	if not mutation then return end
	local visualData = WeatherSystem.LIMITED_VISUALS[mutation]
	if not visualData then return end

	for _, d in pairs(brainrotModel:GetDescendants()) do
		if d:IsA("BasePart") or d:IsA("MeshPart") then
			local sa = d:FindFirstChildOfClass("SurfaceAppearance")
			if sa then sa:Destroy() end
			if visualData.material then
				d.Material = visualData.material
			end
			if visualData.reflectance then
				d.Reflectance = visualData.reflectance
			end
			if visualData.color and visualData.animated == false then
				d.Color = visualData.color
			end
		elseif d:IsA("SpecialMesh") then
			d.TextureId = ""
		end
	end

	if visualData.animated == "galaxy" then
		animateGalaxy(brainrotModel)
	elseif visualData.animated == "yinyang" then
		animateYinYang(brainrotModel)
	elseif visualData.animated == "radioactive" then
		animateRadioactive(brainrotModel)
	end
end

local function addNameTag(brainrot)
	local rarity = brainrot:GetAttribute("Rarity") or "Common"
	local mutation = brainrot:GetAttribute("Mutation")
	local isLocked = brainrot:GetAttribute("IsLocked") or false
	local anchorPart = brainrot:FindFirstChild("RootPart") or brainrot.PrimaryPart or brainrot:FindFirstChildWhichIsA("BasePart")

	if not anchorPart then return end

	local bb = Instance.new("BillboardGui")
	bb.Name = "StatsGUI"
	bb.Adornee = anchorPart
	bb.Size = UDim2.new(12, 0, 6, 0)
	bb.ExtentsOffset = Vector3.new(0, 2.5, 0) 
	bb.AlwaysOnTop = true
	bb.MaxDistance = 400 
	bb.Parent = brainrot

	local container = Instance.new("Frame")
	container.Size = UDim2.new(1, 0, 1, 0)
	container.BackgroundTransparency = 1
	container.Parent = bb

	local listLayout = Instance.new("UIListLayout")
	listLayout.Parent = container
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
	listLayout.Padding = UDim.new(0, 0)

	local function createLabel(text, layoutOrder, font, color, strokeColor, strokeTrans)
		local lbl = Instance.new("TextLabel")
		lbl.Text = text
		lbl.Size = UDim2.new(1, 0, 0.2, 0)
		lbl.BackgroundTransparency = 1
		lbl.TextScaled = true
		lbl.Font = font
		lbl.TextColor3 = color
		lbl.TextStrokeColor3 = strokeColor or Color3.new(0,0,0)
		lbl.TextStrokeTransparency = strokeTrans or 0.5
		lbl.LayoutOrder = layoutOrder
		lbl.Parent = container

		local constraint = Instance.new("UITextSizeConstraint")
		constraint.MaxTextSize = 35 
		constraint.MinTextSize = 2  
		constraint.Parent = lbl

		return lbl
	end

	if isLocked then
		createLabel("ðŸ”’ LOCKED", 0, Enum.Font.FredokaOne, Color3.fromRGB(255, 50, 50))
	end

	local maxDuration = DESPAWN_TIME[rarity] or 60
	local tLabel = createLabel("â³ " .. maxDuration .. "s", 1, Enum.Font.FredokaOne, Color3.new(1,1,1), Color3.new(0,0,0), 0)

	if mutation then
		local mutText = "â­ " .. mutation .. " â­"
		local mutColor = Color3.new(1,1,1)
		local mc = MUTATION_COLORS[mutation]
		if mc and mc ~= "Rainbow" then mutColor = mc end

		local mLabel = createLabel(mutText, 2, Enum.Font.SourceSansBold, mutColor, Color3.new(0,0,0), 0)

		-- ðŸ‘‡ ADD THIS LINE SO THE WEATHER SYSTEM CAN FIND IT! ðŸ‘‡
		mLabel.Name = "MutationLabel"

		if mutation and MUTATION_COLORS[mutation] == "Rainbow" then
			animateRainbow(mLabel)
		end
	end

	local rarityColor = RARITY_COLORS[rarity] or Color3.new(1,1,1)
	local nameColor = Color3.new(1,1,1)

	if rarityColor == "Rainbow" or rarityColor == "Split" then
		nameColor = Color3.new(1,1,1)
	elseif typeof(rarityColor) == "Color3" then
		nameColor = rarityColor
	end

	local nLabel = createLabel(brainrot.Name, 3, Enum.Font.SourceSansBold, nameColor)
	if rarityColor == "Rainbow" then 
		animateRainbow(nLabel) 
	end

	local rarityTextColor = Color3.new(1,1,1)

	if rarityColor == "Rainbow" then
		rarityTextColor = Color3.new(1,1,1)
	elseif rarityColor == "Split" then
		rarityTextColor = Color3.new(1,0,0)
	elseif typeof(rarityColor) == "Color3" then
		rarityTextColor = rarityColor
	end

	local rLabel = createLabel(rarity, 4, Enum.Font.SourceSansBold, rarityTextColor)

	if rarityColor == "Rainbow" then
		animateRainbow(rLabel)
	elseif rarityColor == "Split" then
		nLabel.TextColor3 = Color3.new(0,1,0)
		rLabel.TextColor3 = Color3.new(1,0,0) 
	end

	task.spawn(function()
		local startTime = os.time()
		local lastTimeLeft = maxDuration 

		while brainrot and brainrot.Parent do
			local elapsed = os.time() - startTime
			local timeLeft = maxDuration - elapsed
			if timeLeft < 0 then timeLeft = 0 end

			if timeLeft ~= lastTimeLeft then
				tLabel.Text = "â³ " .. timeLeft .. "s"
				lastTimeLeft = timeLeft

				if timeLeft <= 10 then
					tLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
				else
					tLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
				end
			end

			if timeLeft <= 0 then break end
			task.wait(0.1)
		end
	end)
end

local function enableCollisionDetection(brainrot)
	local rootPart = brainrot:FindFirstChild("RootPart") or brainrot.PrimaryPart or brainrot:FindFirstChildWhichIsA("BasePart")
	if not rootPart then
		warn("âš ï¸ No RootPart found for " .. brainrot.Name)
		return
	end

	for _, descendant in pairs(brainrot:GetDescendants()) do
		if descendant:IsA("BasePart") then
			descendant.CanTouch = true

			-- ADDED: Assign to NPCs collision group
			PhysicsService:SetPartCollisionGroup(descendant, "NPCs")

			if descendant ~= rootPart then
				local weld = Instance.new("WeldConstraint")
				weld.Part0 = rootPart
				weld.Part1 = descendant
				weld.Parent = descendant
			end
		end
	end
end

local function makeBrainrotWander(brainrot, speed)
	task.spawn(function()
		local rootPart = brainrot:FindFirstChild("RootPart") or brainrot.PrimaryPart
		if not rootPart then return end

		local bodyVelocity = Instance.new("BodyVelocity")
		bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
		bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		bodyVelocity.Parent = rootPart

		local bodyGyro = Instance.new("BodyGyro")
		bodyGyro.MaxTorque = Vector3.new(500000, 500000, 500000) 
		bodyGyro.P = 25000 
		bodyGyro.D = 1000  
		bodyGyro.Parent = rootPart

		local WADDLE_SPEED = 18    
		local WADDLE_AMOUNT = 0.3 

		while brainrot and brainrot.Parent do
			local randomAngle = math.random() * math.pi * 2
			local randomDistance = math.random(30, 80)

			local currentPos = rootPart.Position
			local offsetX = math.cos(randomAngle) * randomDistance
			local offsetZ = math.sin(randomAngle) * randomDistance

			local destinationX = currentPos.X + offsetX
			local destinationZ = currentPos.Z + offsetZ

			local destDX = destinationX - PLATFORM_CENTER_X
			local destDZ = destinationZ - PLATFORM_CENTER_Z
			local destDistance = math.sqrt(destDX * destDX + destDZ * destDZ)

			if destDistance > (PLATFORM_RADIUS - 15) then
				destinationX = currentPos.X - offsetX
				destinationZ = currentPos.Z - offsetZ
			end

			local destination = Vector3.new(destinationX, PLATFORM_Y + 3, destinationZ)
			local moveDuration = randomDistance / speed
			local startTime = tick()

			while tick() - startTime < moveDuration and brainrot and brainrot.Parent do
				currentPos = rootPart.Position
				local direction = (destination - currentPos) * Vector3.new(1, 0, 1)

				if direction.Magnitude > 3 then
					direction = direction.Unit * speed
					bodyVelocity.Velocity = Vector3.new(direction.X, 0, direction.Z)

					local currentTime = tick()
					local wobbleZ = math.sin(currentTime * WADDLE_SPEED) * WADDLE_AMOUNT
					local lookPos = currentPos + direction
					local baseCFrame = CFrame.new(currentPos, Vector3.new(lookPos.X, currentPos.Y, lookPos.Z))

					bodyGyro.CFrame = baseCFrame * CFrame.Angles(-0.1, 0, wobbleZ)
				else
					break 
				end
				task.wait(0.05)
			end
		end
	end)
end

local function removeBrainrot(brainrot)
	for i, tracked in ipairs(activeBrainrots) do
		if tracked == brainrot then
			table.remove(activeBrainrots, i)
			break
		end
	end
	if brainrot and brainrot.Parent then brainrot:Destroy() end
end

local function scheduleDespawn(brainrot)
	local rarity = brainrot:GetAttribute("Rarity") or "Common"
	local waitTime = DESPAWN_TIME[rarity] or 60
	task.delay(waitTime, function() removeBrainrot(brainrot) end)
end

local function spawnbrainrot()
	if #activeBrainrots >= MAX_BRAINROTS then
		print("âš ï¸ Brainrot cap reached (" .. MAX_BRAINROTS .. "), skipping spawn")
		return
	end

	local basicrarity = "Common"
	local randomnum = math.random(1, 1000000)
	if randomnum <= 850000  then basicrarity = "Common"
	elseif randomnum <= 950000 then basicrarity = "Rare"
	elseif randomnum <= 975000  then basicrarity = "Epic"
	elseif randomnum <=990000 then basicrarity = "Legendary"
	elseif randomnum <= 999000 then basicrarity = "Mythic"
	elseif randomnum <= 999900 then basicrarity = "Brainrot God"
	elseif randomnum <= 9999900 then basicrarity = "Secret"
	else basicrarity = "OG" end

	local validbrainrotlist = {}
	for i, brainrot in pairs(brainrots) do
		if brainrot:GetAttribute("Rarity") == basicrarity then
			table.insert(validbrainrotlist, brainrot)
		end
	end

	if #validbrainrotlist == 0 then return end 

	local brainrot = validbrainrotlist[math.random(1, #validbrainrotlist)]:Clone()

	local mutation = getMutation()
	if mutation then
		brainrot:SetAttribute("Mutation", mutation)
		brainrot:SetAttribute("MutationMult",MUTATION_MULTIPLIERS[mutation])
	end

	local requirement = RARITY_REQUIREMENTS[basicrarity] or 0
	brainrot:SetAttribute("RebirthRequirement", requirement)
	brainrot:SetAttribute("IsLocked", false)

	local spawnPosition = getValidSpawnPosition()
	if brainrot:IsA("Model") then
		brainrot:PivotTo(CFrame.new(spawnPosition))
	else
		brainrot.Position = spawnPosition
	end

	brainrot.Parent = workspace
	table.insert(activeBrainrots, brainrot)

	enableCollisionDetection(brainrot)

	if mutation then
		local limited = WeatherSystem.LIMITED_VISUALS[mutation]
		if limited then
			applyLimitedMutationVisuals(brainrot, mutation)
		else
			applyMutationVisuals(brainrot, mutation)
		end
	end

	addNameTag(brainrot)

	local rarity = brainrot:GetAttribute("Rarity")
	local speed = RARITY_SPEEDS[rarity]

	if not speed then
		warn("âš ï¸ Unknown rarity '" .. tostring(rarity) .. "' for " .. brainrot.Name .. " - using default speed of 24")
		speed = 24
	end

	print("ðŸŒ Speed for " .. brainrot.Name .. " (Rarity: '" .. rarity .. "'): " .. speed)

	makeBrainrotWander(brainrot, speed)
	scheduleDespawn(brainrot)
	print("ðŸŽ¯ Spawned: " .. brainrot.Name .. " (" .. basicrarity .. ")" .. (requirement > 0 and " ðŸ”’" or ""))
end

event.OnServerEvent:Connect(spawnbrainrot)

local function isDeveloper(player)
	if RunService:IsStudio() then return true end
	return player.UserId == game.CreatorId or player.UserId == 10378926133
end

spawnSpecificEvent.OnServerEvent:Connect(function(player, brainrotName)
	if not isDeveloper(player) then return end
	if #activeBrainrots >= MAX_BRAINROTS then return end

	for _, brainrot in pairs(brainrots) do
		if brainrot.Name:lower() == brainrotName:lower() then
			local clone = brainrot:Clone()
			local mutation = getMutation()
			if mutation then clone:SetAttribute("Mutation", mutation) end

			local rarity = clone:GetAttribute("Rarity") or "Common"
			local requirement = RARITY_REQUIREMENTS[rarity] or 0
			clone:SetAttribute("RebirthRequirement", requirement)
			clone:SetAttribute("IsLocked", requirement > 0)

			local spawnPosition = getValidSpawnPosition()
			if clone:IsA("Model") then clone:PivotTo(CFrame.new(spawnPosition))
			else clone.Position = spawnPosition end

			clone.Parent = workspace
			table.insert(activeBrainrots, clone)
			enableCollisionDetection(clone)

			if clone:GetAttribute("IsLocked") then
				applyMonochromeFilter(clone)
			elseif mutation then
				applyMutationVisuals(clone, mutation)
			end

			addNameTag(clone)

			local speed = RARITY_SPEEDS[rarity] or 8
			makeBrainrotWander(clone, speed)
			scheduleDespawn(clone)
			return
		end
	end
end)

if AUTO_SPAWN_ENABLED then
	task.spawn(function()
		print("ðŸ”„ Auto-spawn system started!")
		while true do
			task.wait(AUTO_SPAWN_INTERVAL)
			spawnbrainrot()
		end
	end)
end

print("âœ… Spawning System loaded with auto-spawn, rebirth locks, and collision groups!")
e|S|CarryUpgrade
-- Put this in ServerScriptService
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Create RemoteEvent if it doesn't exist
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local upgradeEvent = remoteEvents:FindFirstChild("UpgradeBrainrotCapacity")
if not upgradeEvent then
	upgradeEvent = Instance.new("RemoteEvent")
	upgradeEvent.Name = "UpgradeBrainrotCapacity"
	upgradeEvent.Parent = remoteEvents
end

-- Upgrade costs (increases with each level)
local BASE_COST = 500,000
local COST_MULTIPLIER = 50

-- Calculate upgrade cost based on current capacity
local function calculateUpgradeCost(currentCapacity)
	return math.floor(BASE_COST * (COST_MULTIPLIER ^ (currentCapacity - 1)))
end

-- Initialize player data
local function setupPlayer(player)
	-- Set default capacity if not already set
	if not player:GetAttribute("BrainrotCapacity") then
		player:SetAttribute("BrainrotCapacity", 1)
	end

	-- Set initial upgrade cost
	local currentCapacity = player:GetAttribute("BrainrotCapacity")
	player:SetAttribute("NextUpgradeCost", calculateUpgradeCost(currentCapacity))

	print("ðŸ“¦ " .. player.Name .. " initialized with capacity: " .. currentCapacity)
end

-- Handle upgrade request
upgradeEvent.OnServerEvent:Connect(function(player)
	local currentCapacity = player:GetAttribute("BrainrotCapacity") or 1
	local upgradeCost = player:GetAttribute("NextUpgradeCost") or 100

	-- Check if player has enough money
	local moneyRaw = player:FindFirstChild("MoneyRaw")
	if not moneyRaw then
		upgradeEvent:FireClient(player, false, "Money system not found!")
		return
	end

	-- Check if player can afford it
	if moneyRaw.Value < upgradeCost then
		upgradeEvent:FireClient(player, false, "Not enough money! Need $" .. upgradeCost)
		return
	end

	-- Check max capacity (optional)
	local MAX_CAPACITY = 10
	if currentCapacity >= MAX_CAPACITY then
		upgradeEvent:FireClient(player, false, "Maximum capacity reached!")
		return
	end

	-- Deduct money
	moneyRaw.Value = moneyRaw.Value - upgradeCost

	-- Increase capacity
	local newCapacity = currentCapacity + 1
	player:SetAttribute("BrainrotCapacity", newCapacity)

	-- Calculate new upgrade cost
	local newCost = calculateUpgradeCost(newCapacity)
	player:SetAttribute("NextUpgradeCost", newCost)

	-- Send success message
	upgradeEvent:FireClient(player, true, "Upgraded to capacity: " .. newCapacity)

	print("ðŸ’° " .. player.Name .. " upgraded capacity to " .. newCapacity .. " for $" .. upgradeCost)
end)

-- Setup existing players
for _, player in pairs(Players:GetPlayers()) do
	setupPlayer(player)
end

-- Setup new players
Players.PlayerAdded:Connect(setupPlayer)

print("âœ… Brainrot Capacity Upgrade System loaded!")
e|S|MoneyPlaceHolder
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local NumberFormat = require(ReplicatedStorage:WaitForChild("NumberFormat"))

local function setupLeaderstats(player)
	-- leaderstats folder
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then
		leaderstats = Instance.new("Folder")
		leaderstats.Name = "leaderstats"
		leaderstats.Parent = player
	end

	-- REAL money (not on leaderboard)
	local moneyRaw = player:FindFirstChild("MoneyRaw")
	if not moneyRaw then
		moneyRaw = Instance.new("NumberValue")
		moneyRaw.Name = "MoneyRaw"
		moneyRaw.Value = 0
		moneyRaw.Parent = player -- IMPORTANT: not inside leaderstats
	end

	-- DISPLAY money (on leaderboard)
	local moneyDisplay = leaderstats:FindFirstChild("Money")
	if not moneyDisplay then
		moneyDisplay = Instance.new("StringValue")
		moneyDisplay.Name = "Money" -- this is what the board shows
		moneyDisplay.Value = "0"
		moneyDisplay.Parent = leaderstats
	end

	local function updateDisplay()
		moneyDisplay.Value = NumberFormat.format(moneyRaw.Value)
	end

	updateDisplay()
	moneyRaw:GetPropertyChangedSignal("Value"):Connect(updateDisplay)

	-- Skyscraper Height
	local skyscraperHeight = leaderstats:FindFirstChild("Skyscraper Height")
	if not skyscraperHeight then
		skyscraperHeight = Instance.new("NumberValue")
		skyscraperHeight.Name = "Skyscraper Height"
		skyscraperHeight.Value = 1
		skyscraperHeight.Parent = leaderstats
	end

	-- Rebirths
	local rebirths = leaderstats:FindFirstChild("Rebirths")
	if not rebirths then
		rebirths = Instance.new("NumberValue")
		rebirths.Name = "Rebirths"
		rebirths.Value = 0
		rebirths.Parent = leaderstats
	end
end

Players.PlayerAdded:Connect(setupLeaderstats)
for _, player in ipairs(Players:GetPlayers()) do
	setupLeaderstats(player)
end
e|S|bigrahim
-- ServerScriptService/BrainrotSlotSystem
print("ðŸš€ BrainrotSlotSystem starting...")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- Validate tools against this folder
local BrainrotPackFolder = ReplicatedStorage:WaitForChild("Brainrot pack1", 10)
if not BrainrotPackFolder then
	warn("CRITICAL: 'Brainrot pack1' folder not found in ReplicatedStorage!")
end
local economyevent = game.ReplicatedStorage.RemoteEvents.EconomyEvent
-- ==========================================================
-- CONFIG
-- ==========================================================
local BASES_FOLDER_NAME = "BrainrotBases"
local TweenService = game:GetService("TweenService")
-- Rarity colours â€” same as spawning system
local RARITY_COLORS = {
	["Common"]       = Color3.fromRGB(0, 255, 0),
	["Rare"]         = Color3.fromRGB(0, 100, 255),
	["Epic"]         = Color3.fromRGB(150, 0, 255),
	["Legendary"]    = Color3.fromRGB(255, 255, 0),
	["Mythic"]       = Color3.fromRGB(255, 0, 0),
	["Brainrot God"] = "Rainbow",
	["Secret"]       = Color3.fromRGB(0, 0, 0),
	["OG"]           = "Split",
}

-- Mutation colors (matches spawning system)
local MUTATION_COLORS = {
	["Gold"]        = Color3.fromRGB(255, 215, 0),
	["Diamond"]     = Color3.fromRGB(185, 242, 255),
	["Rainbow"]     = "Rainbow",
	-- Limited (weather-gated)
	["Bloodrot"]    = Color3.fromRGB(100, 0, 0),
	["Candy"]       = Color3.fromRGB(255, 105, 180),
	["Lava"]        = Color3.fromRGB(255, 80, 0),
	["Galaxy"]      = Color3.fromRGB(138, 43, 226),
	["Yin-Yang"]    = "YinYang",
	["Radioactive"] = Color3.fromRGB(0, 255, 50),
}

-- Mutation multipliers for income (matches spawning system)
local MUTATION_MULTIPLIERS = {
	["Gold"]        = 1.25,
	["Diamond"]     = 1.5,
	["Rainbow"]     = 10,
	-- Limited
	["Bloodrot"]    = 2.0,
	["Candy"]       = 4.0,
	["Lava"]        = 6.0,
	["Galaxy"]      = 7.0,
	["Yin-Yang"]    = 7.5,
	["Radioactive"] = 8.5,
}
-- ================================================================
--  INVENTORY CAPACITY HELPER
-- ================================================================
local function countPlayerBrainrots(player)
	local count = 0
	local backpack = player:FindFirstChild("Backpack")
	if backpack then
		for _, tool in pairs(backpack:GetChildren()) do
			if tool:IsA("Tool") and tool:GetAttribute("Rarity") then
				count = count + 1
			end
		end
	end

	-- Check equipped tool
	if player.Character then
		local equippedTool = player.Character:FindFirstChildOfClass("Tool")
		if equippedTool and equippedTool:GetAttribute("Rarity") then
			count = count + 1
		end
	end

	return count
end
-- Income per second keyed by exact tool name (codev's table â€” most complete)
local BRAINROT_INCOME = {
	-- COMMON
	["Noobini Pizzanini"] = 1,
	["Lirili Larila"] = 3,
	["Tim Cheese"] = 5,
	["FluriFlura"] = 7,
	["Talpa Di Fero"] = 9,
	["Svinina Bombardino"] = 10,
	["Noobini Santanini"] = 11,
	["Racooni Jandelini"] = 12,
	["Pipi Kiwi"] = 13,
	["Tartaragno"] = 13,
	["Pipi Corni"] = 14,
	["Trippi Troppi"] = 15,
	["Gangster Footera"] = 30,
	["Bandito Bobritto"] = 35,
	["Boneca Ambalabu"] = 40,
	["Cacto Hipopotamo"] = 50,
	["Ta Ta Ta Ta Sahur"] = 55,
	["Tric Trac Baraboom"] = 65,
	["Frogo Elfo"] = 67,
	["Pipi Avocado"] = 70,
	["Pinealotto Fruttarino"] = 75,
	["Cappuccino Assassino"] = 75,
	["Bandito Axolito"] = 90,
	["Brr Brr Patapim"] = 100,
	["Avocadini Antilopini"] = 115,
	["Trulimero Trulicina"] = 125,
	["Bambini Crostini"] = 135,
	["Malame Amarele"] = 140,
	["Bananita Dolphinita"] = 150,
	["Perochello Lemonchello"] = 160,
	["Brri Brri Bicus Dicus Bombicus"] = 175,
	["Avocadini Guffo"] = 225,
	["Ti Ti Ti Sahur"] = 225,
	["Mangolini Parrocini"] = 235,
	["Frogatto Piratto"] = 240,
	["Salamino Penguino"] = 250,
	["Doi Doi Do"] = 260,
	["Penguin Tree"] = 270,
	["Wombo Rollo"] = 275,
	["Penguino Cocosino"] = 300,
	["Mummio Rappito"] = 325,
	["Chimpanzini Bananini"] = 300,
	["Tirilikalika Tirilikalako"] = 450,
	["Ballerina Cappuccina"] = 500,
	["Burbaloni Loliloli"] = 600,
	["Chef Crabracadabra"] = 600,
	["Lionel Cactuseli"] = 650,
	["Glorbo Fruttodrillo"] = 750,
	["Quivoli Ameleoni"] = 900,
	["Blueberrini Octopusini"] = 1000,
	["Caramello Filtrello"] = 1000,
	["Pipi Potato"] = 1100,
	["Strawberrelli Flamingelli"] = 1100,
	["Cocosini Mama"] = 1200,
	["Pandaccini Bananini"] = 1250,
	["Quackula"] = 1200,
	["Pi Pi Watermelon"] = 1300,
	["Signore Carapace"] = 1300,
	["Sigma Boy"] = 1350,
	["Chocco Bunny"] = 1400,
	["Puffaball"] = 1500,
	["Sigma Girl"] = 1800,
	["Buho de Fuego"] = 1800,
	["Frigo Camelo"] = 1900,
	["Orangutini Ananassini"] = 2000,
	["Rhino Toasterino"] = 2100,
	["Bombardiro Crocodilo"] = 2500,
	["Spioniro Golubiro"] = 3500,
	["Bangangini Gusini"] = 5000,
	["Zibra Zubra Zibralini"] = 6000,
	["Tigrilini Watermelini"] = 6500,
	["Avocadorilla"] = 7000,
	["Cavallo Virtuoso"] = 7500,
	["Gorillo Subwoofero"] = 7700,
	["Gorillo Watermelondrillo"] = 8000,
	["Stoppo Luminino"] = 8000,
	["Ganganzelli Trulala"] = 9000,
	["Lerulerulerule"] = 8700,
	["Tob Tobi Tobi"] = 8500,
	["Te Te Te Sahur"] = 9500,
	["Rhino Helicopterino"] = 11000,
	["Magi Ribbitini"] = 11500,
	["Tracoducotulu Delapeladustuz"] = 12000,
	["Jingle Jingle Sahur"] = 12200,
	["Los Noobinis"] = 12500,
	["Cachorrito Melonito"] = 13000,
	["Carloo"] = 13500,
	["Elefanto Frigo"] = 14000,
	["Carrotini Brainini"] = 15000,
	["Centrucci Nuclucci"] = 15500,
	["Jacko Spaventosa"] = 16200,
	["Toiletto Focaccino"] = 16000,
	["Bananito Bandito"] = 16500,
	["Tree Tree Tree Sahur"] = 17000,
	["Cocofanto Elefanto"] = 17500,
	["Antonio"] = 18500,
	["Girafa Celestre"] = 20000,
	["Gattatino Neonino"] = 35000,
	["Gattatino Nyanino"] = 35000,
	["Chihuanini Taconini"] = 45000,
	["Matteo"] = 50000,
	["Tralalero Tralala"] = 50000,
	["Los Crocodillitos"] = 55000,
	["Tigroligre Frutonni"] = 60000,
	["Espresso Signora"] = 70000,
	["Odin Din Din Dun"] = 75000,
	["Statutino Libertino"] = 75000,
	["Tipi Topi Taco"] = 75000,
	["Alessio"] = 85000,
	["Tralalita Tralala"] = 100000,
	["Tukanno Bananno"] = 100000,
	["Orcalero Orcala"] = 100000,
	["Extinct Ballerina"] = 125000,
	["Trenostruzzo Turbo 3000"] = 150000,
	["Urubini Flamenguini"] = 150000,
	["Capi Taco"] = 155000,
	["Gattito Tacoto"] = 160000,
	["Trippi Troppi Troppa Trippa"] = 175000,
	["Ballerino Lololo"] = 200000,
	["Bulbito Bandito Traktorito"] = 205000,
	["Los Tungtungtungcitos"] = 210000,
	["Ballerina Peppermintina"] = 215000,
	["Pakrahmatmamat"] = 215000,
	["Los Bombinitos"] = 220000,
	["Bombardini Tortinii"] = 225000,
	["Piccione Macchina"] = 225000,
	["Brr es Teh Patipum"] = 225000,
	["Tractoro Dinosauro"] = 230000,
	["Los Orcalitos"] = 235000,
	["Corn Corn Corn Sahur"] = 250000,
	["Squalanana"] = 250000,
	["Dug Dug Dug"] = 255000,
	["Yeti Claus"] = 257500,
	["Ginger Globo"] = 257500,
	["Los Tipi Tacos"] = 260000,
	["Frio Ninja"] = 265000,
	["Ginger Cisterna"] = 293500,
	["Pop Pop Sahur"] = 295000,
	["La Vacca Saturno Saturnita"] = 300000,
	["Los Matteos"] = 300000,
	["Bisonte Giuppitere"] = 300000,
	["Jackorilla"] = 315000,
	["Sammyni Spyderini"] = 325000,
	["Chimpanzini Spiderini"] = 325000,
	["Torrtuginni Dragonfrutini"] = 350000,
	["Unclito Samito"] = 350000,
	["Dul Dul Dul"] = 375000,
	["Blackhole Goat"] = 400000,
	["Chachechi"] = 400000,
	["Guerriro Digitale"] = 425000,
	["Agarrini la Palini"] = 425000,
	["Extinct Tralalero"] = 450000,
	["Fragola La La La"] = 450000,
	["Los Spyderinis"] = 450000,
	["La Cucaracha"] = 475000,
	["Los Tortus"] = 500000,
	["Los Tralaleritos"] = 750000,
	["Extinct Matteo"] = 500000,
	["Vulturino Skeletono"] = 500000,
	["Boatito Auratito"] = 525000,
	["Karkerkar Kurkur"] = 550000,
	["Orcalita Orcala"] = 575000,
	["Piccionetta Macchina"] = 600000,
	["Las Tralaleritas"] = 650000,
	["Job Job Job Sahur"] = 700000,
	["Las Vaquitas Saturnitas"] = 750000,
	["Los Combinasionas"] = 800000,
	["Trenzostruzzo Turbo 4000"] = 850000,
	["La Grande Combinasion"] = 10000000,
	["Graipuss Medussi"] = 1000000,
	["Anpali Babel"] = 1200000,
	["Mastodontico Telepiedone"] = 1200000,
	["Noo My Hotspot"] = 1500000,
	["La Sahur Combinasion"] = 2000000,
	["Nooo My Hotspot"] = 2000000,
	["La Karkerkar Combinasion"] = 17500000,
	["Pot Hotspot"] = 2500000,
	["Esok Sekolah"] = 3000000,
	["Chicleteira Bicicleteira"] = 3500000,
	["67"] = 7500000,
	["Los Nooo My Hotspotsitos"] = 5500000,
	["Nuclearo Dinossauro"] = 15000000,
	["Las Sis"] = 17500000,
	["Celularcini Viciosini"] = 22500000,
	["Los Bros"] = 24000000,
	["Tralaledon"] = 27500000,
	["La Esok Sekolah"] = 30000000,
	["Tang Tang Kelentang"] = 33500000,
	["Ketupat Kepat"] = 35000000,
	["Tictac Sahur"] = 37500000,
	["La Secret Combinasion"] = 125000000,
	["Ketchuru and Musturu"] = 42500000,
	["Garama and Madundung"] = 50000000,
	["Spaghetti Tualetti"] = 60000000,
	["Los Orcaleritos"] = 235000000,
	["Dragon Cannelloni"] = 200000000,
	-- OG
	["Strawberry Elephant"] = 350000000,
}

-- ==========================================================
-- SETUP
-- ==========================================================
local BASES_FOLDER = Workspace:WaitForChild(BASES_FOLDER_NAME, 5)
if not BASES_FOLDER then
	warn("âŒ BrainrotBases folder NOT FOUND in Workspace!")
	return
end
print("âœ“ Found BrainrotBases folder")

-- Track assigned bases
local assignedBases = {} -- [playerName] = baseModel
local availableBases = {} -- Queue of unassigned bases

-- Initialize available bases list
for _, base in pairs(BASES_FOLDER:GetChildren()) do
	if base:IsA("Model") then
		local ownerValue = base:FindFirstChild("Owner")
		if ownerValue and ownerValue:IsA("StringValue") and ownerValue.Value == "" then
			table.insert(availableBases, base)
		end
	end
end

print("ðŸ“Š Found " .. #availableBases .. " available bases for assignment")

-- Function to assign a base to a player
local function assignBaseToPlayer(player)
	-- Check if player already has a base
	if assignedBases[player.Name] then
		print("âœ“ " .. player.Name .. " already has base: " .. assignedBases[player.Name].Name)
		return assignedBases[player.Name]
	end

	-- Find an available base
	if #availableBases == 0 then
		warn("âš ï¸ No available bases to assign to " .. player.Name)
		return nil
	end

	-- Assign the first available base
	local base = table.remove(availableBases, 1)
	local ownerValue = base:FindFirstChild("Owner")

	if ownerValue and ownerValue:IsA("StringValue") then
		ownerValue.Value = player.Name
		assignedBases[player.Name] = base

		-- Set the spawn location
		local spawnLocation = base:FindFirstChild("SpawnLocation")
		if spawnLocation and spawnLocation:IsA("SpawnLocation") then
			-- Configure spawn location
			spawnLocation.Enabled = true
			spawnLocation.Duration = 0
			spawnLocation.Neutral = false
			spawnLocation.AllowTeamChangeOnTouch = false

			-- Set this as the player's respawn location
			player.RespawnLocation = spawnLocation

			print("âœ… Assigned " .. base.Name .. " to " .. player.Name .. " with spawn point")

			-- Wait for character to load, then teleport
			if player.Character then
				local humanoidRootPart = player.Character:WaitForChild("HumanoidRootPart", 5)
				if humanoidRootPart then
					humanoidRootPart.CFrame = spawnLocation.CFrame + Vector3.new(0, 3, 0)
				end
			else
				-- If character hasn't loaded yet, wait for it
				player.CharacterAdded:Connect(function(character)
					local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
					if humanoidRootPart then
						humanoidRootPart.CFrame = spawnLocation.CFrame + Vector3.new(0, 3, 0)
					end
				end)
			end
		else
			warn("âš ï¸ No SpawnLocation found in " .. base.Name)
		end

		return base
	end

	return nil
end

-- Function to unassign a base when player leaves
local function unassignBase(player)
	local base = assignedBases[player.Name]
	if base then
		local ownerValue = base:FindFirstChild("Owner")
		if ownerValue and ownerValue:IsA("StringValue") then
			ownerValue.Value = ""
		end

		-- Clear player's respawn location
		player.RespawnLocation = nil

		-- Return base to available pool
		table.insert(availableBases, base)
		assignedBases[player.Name] = nil

		print("ðŸ”“ Unassigned " .. base.Name .. " from " .. player.Name)
	end
end

-- Auto-assign bases when players join
Players.PlayerAdded:Connect(function(player)
	print("ðŸ‘¤ Player joined: " .. player.Name)
	assignBaseToPlayer(player)
end)

-- Clean up when players leave
Players.PlayerRemoving:Connect(function(player)
	print("ðŸ‘‹ Player leaving: " .. player.Name)
	unassignBase(player)
end)

-- Assign bases to any players already in the game (for testing in Studio)
for _, player in pairs(Players:GetPlayers()) do
	assignBaseToPlayer(player)
end

local remoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not remoteEvents then
	remoteEvents = Instance.new("Folder")
	remoteEvents.Name = "RemoteEvents"
	remoteEvents.Parent = ReplicatedStorage
end

local placeBrainrotEvent = remoteEvents:FindFirstChild("PlaceBrainrotEvent")
if not placeBrainrotEvent then
	placeBrainrotEvent = Instance.new("RemoteEvent")
	placeBrainrotEvent.Name = "PlaceBrainrotEvent"
	placeBrainrotEvent.Parent = remoteEvents
end

local collectIncomeEvent = remoteEvents:FindFirstChild("CollectIncomeEvent")
if not collectIncomeEvent then
	collectIncomeEvent = Instance.new("RemoteEvent")
	collectIncomeEvent.Name = "CollectIncomeEvent"
	collectIncomeEvent.Parent = remoteEvents
end

-- ==========================================================
-- SHARED STATE
-- slotData[slot]      â€“ income tracking per occupied slot
-- incomeLabels[slot]  â€“ direct reference to the TextLabel on that slot's
--                        CollectTrigger billboard (created during the scan,
--                        before any brainrot is placed, so we never have to
--                        walk the instance tree again)
-- ==========================================================
local slotData      = {}
local incomeLabels  = {}   -- [slot Model] = TextLabel

-- ==========================================================
-- BILLBOARD HELPERS  (colour rules match the spawning system)
-- ==========================================================
local function animateRainbow(textLabel)
	task.spawn(function()
		local hue = 0
		while textLabel and textLabel.Parent do
			hue = (hue + 0.01) % 1
			textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
			task.wait(0.05)
		end
	end)
end

-- Apply rainbow effect to all parts in a model
local function animateRainbowModel(model)
	task.spawn(function()
		local hue = 0
		local parts = {}

		-- Collect all parts
		for _, descendant in pairs(model:GetDescendants()) do
			if descendant:IsA("BasePart") then
				table.insert(parts, descendant)
			end
		end

		while model and model.Parent do
			hue = (hue + 0.01) % 1
			local rainbowColor = Color3.fromHSV(hue, 1, 1)

			for _, part in pairs(parts) do
				if part and part.Parent then
					part.Color = rainbowColor
				end
			end

			task.wait(0.05)
		end
	end)
end

local function animateGalaxy(model)
	task.spawn(function()
		local parts = {}
		for _, d in pairs(model:GetDescendants()) do
			if d:IsA("BasePart") then table.insert(parts, d) end
		end
		local t = 0
		while model and model.Parent do
			t += 0.02
			local brightness = 0.5 + 0.5 * math.sin(t)
			local col = Color3.fromRGB(
				math.floor(75  + 63  * brightness),
				0,
				math.floor(130 + 100 * brightness)
			)
			for _, p in pairs(parts) do
				if p and p.Parent then p.Color = col end
			end
			task.wait(0.05)
		end
	end)
end

local function animateYinYang(model)
	task.spawn(function()
		local parts = {}
		for _, d in pairs(model:GetDescendants()) do
			if d:IsA("BasePart") then table.insert(parts, d) end
		end
		local flip = false
		while model and model.Parent do
			flip = not flip
			local col = flip and Color3.new(1, 1, 1) or Color3.new(0, 0, 0)
			for _, p in pairs(parts) do
				if p and p.Parent then p.Color = col end
			end
			task.wait(0.5)
		end
	end)
end

local function animateRadioactive(model)
	task.spawn(function()
		local parts = {}
		for _, d in pairs(model:GetDescendants()) do
			if d:IsA("BasePart") then table.insert(parts, d) end
		end
		local t = 0
		while model and model.Parent do
			t += 0.08
			local brightness = 0.5 + 0.5 * math.sin(t)
			local g = math.floor(150 + 105 * brightness)
			local col = Color3.fromRGB(0, g, 0)
			for _, p in pairs(parts) do
				if p and p.Parent then p.Color = col end
			end
			task.wait(0.05)
		end
	end)
end

-- Apply mutation visual effects to the brainrot model
local function applyMutationVisuals(brainrotModel, mutation)
	if not mutation then return end

	-- Helper: strip SurfaceAppearance so color changes actually apply
	local function stripAndColor(part, color, material, reflectance)
		if part:IsA("BasePart") then
			local sa = part:FindFirstChildOfClass("SurfaceAppearance")
			if sa then sa:Destroy() end
			if color then part.Color = color end
			if material then part.Material = material end
			if reflectance then part.Reflectance = reflectance end
		elseif part:IsA("SpecialMesh") then
			part.TextureId = ""
		end
	end

	-- Strip SurfaceAppearances first for all animated mutations
	if mutation == "Rainbow" or mutation == "Galaxy" or mutation == "Yin-Yang" or mutation == "Radioactive" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			local sa = d:FindFirstChildOfClass("SurfaceAppearance")
			if sa then sa:Destroy() end
			if d:IsA("SpecialMesh") then d.TextureId = "" end
		end
	end

	if mutation == "Rainbow" then
		animateRainbowModel(brainrotModel)

	elseif mutation == "Gold" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(255, 215, 0), Enum.Material.SmoothPlastic, nil)
			if d:IsA("SpecialMesh") then d.TextureId = "" end
		end

	elseif mutation == "Diamond" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(185, 242, 255), Enum.Material.SmoothPlastic, 0.3)
			if d:IsA("SpecialMesh") then d.TextureId = "" end
		end

	elseif mutation == "Bloodrot" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(100, 0, 0), Enum.Material.SmoothPlastic, nil)
		end

	elseif mutation == "Candy" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(255, 105, 180), Enum.Material.SmoothPlastic, 0.1)
		end

	elseif mutation == "Lava" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(255, 80, 0), Enum.Material.Neon, nil)
		end

	elseif mutation == "Galaxy" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(138, 43, 226), Enum.Material.Neon, nil)
		end
		animateGalaxy(brainrotModel)

	elseif mutation == "Yin-Yang" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.new(1, 1, 1), Enum.Material.SmoothPlastic, nil)
		end
		animateYinYang(brainrotModel)

	elseif mutation == "Radioactive" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(0, 255, 50), Enum.Material.Neon, nil)
		end
		animateRadioactive(brainrotModel)
	end
end

local function getModelHeight(model)
	local _, size = model:GetBoundingBox()
	return size.Y
end

-- Nametag on the brainrot itself: Name / Rarity / Mutation (if any) / +$X/sec
-- Nametag on the brainrot itself: Name / Rarity / Mutation (if any) / +$X/sec
-- Modified to accept 'targetAdornee' (The Slot's DisplayPosition)
-- NEW: Separate prominent rarity display that's always visible
local function addRarityDisplay(brainrotModel, targetAdornee)
	local rarity = brainrotModel:GetAttribute("Rarity") or "Common"
	local modelHeight = getModelHeight(brainrotModel)

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "RarityDisplay"
	billboard.Adornee = targetAdornee
	billboard.Size = UDim2.new(6, 0, 1.5, 0)  -- Larger size
	billboard.StudsOffsetWorldSpace = Vector3.new(0, modelHeight + 4.5, 0)  -- Higher up
	billboard.AlwaysOnTop = true  -- Always visible
	billboard.MaxDistance = 500
	billboard.Parent = brainrotModel

	local rarityLabel = Instance.new("TextLabel")
	rarityLabel.Size = UDim2.new(1, 0, 1, 0)
	rarityLabel.BackgroundTransparency = 1
	rarityLabel.Text = "â­ " .. rarity .. " â­"
	rarityLabel.TextScaled = true
	rarityLabel.Font = Enum.Font.FredokaOne
	rarityLabel.TextStrokeTransparency = 0
	rarityLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	rarityLabel.Parent = billboard

	local constraint = Instance.new("UITextSizeConstraint")
	constraint.MaxTextSize = 40
	constraint.MinTextSize = 20
	constraint.Parent = rarityLabel

	-- Apply color
	local rarityColor = RARITY_COLORS[rarity] or Color3.fromRGB(255, 255, 255)
	if rarityColor == "Rainbow" then
		animateRainbow(rarityLabel)
	elseif rarityColor == "Split" then
		rarityLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
	else
		rarityLabel.TextColor3 = rarityColor
	end
end

-- Modified name tag (now without prominent rarity)
local function addSlotNameTag(brainrotModel, incomeRate, mutation, targetAdornee)
	local rarity = brainrotModel:GetAttribute("Rarity") or "Common"
	local modelHeight = getModelHeight(brainrotModel)
	local hasMutation = mutation ~= nil

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "NameTag"
	billboard.Adornee = targetAdornee 
	billboard.Size = UDim2.new(4, 0, hasMutation and 1.75 or 1.25, 0)
	billboard.StudsOffsetWorldSpace = Vector3.new(0, modelHeight + 2, 0)
	billboard.AlwaysOnTop = false
	billboard.MaxDistance = 400

	-- Name row
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, 0, hasMutation and 0.33 or 0.5, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = brainrotModel.Name
	nameLabel.TextSize = 14
	nameLabel.Font = Enum.Font.SourceSansBold
	nameLabel.TextStrokeTransparency = 0.5
	nameLabel.Parent = billboard

	-- Mutation row (if exists)
	local mutationLabel
	if hasMutation then
		mutationLabel = Instance.new("TextLabel")
		mutationLabel.Size = UDim2.new(1, 0, 0.33, 0)
		mutationLabel.Position = UDim2.new(0, 0, 0.33, 0)
		mutationLabel.BackgroundTransparency = 1
		mutationLabel.Text = "â­ " .. mutation .. " â­"
		mutationLabel.TextSize = 14
		mutationLabel.Font = Enum.Font.SourceSansBold
		mutationLabel.TextStrokeTransparency = 0.5
		mutationLabel.Parent = billboard
	end

	-- Income row
	local incomeLabel = Instance.new("TextLabel")
	incomeLabel.Size = UDim2.new(1, 0, hasMutation and 0.33 or 0.5, 0)
	incomeLabel.Position = UDim2.new(0, 0, hasMutation and 0.66 or 0.5, 0)
	incomeLabel.BackgroundTransparency = 1
	incomeLabel.Text = "+$" .. incomeRate .. "/sec"
	incomeLabel.TextSize = 14
	incomeLabel.Font = Enum.Font.SourceSansBold
	incomeLabel.TextStrokeTransparency = 0.5
	incomeLabel.Parent = billboard

	-- Apply colours
	local rarityColor = RARITY_COLORS[rarity] or Color3.fromRGB(255, 255, 255)
	if rarityColor == "Rainbow" then
		animateRainbow(nameLabel)
		animateRainbow(incomeLabel)
	elseif rarityColor == "Split" then
		nameLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
		incomeLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
	else
		nameLabel.TextColor3 = rarityColor
		incomeLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
	end

	if hasMutation and mutationLabel then
		local mutationColor = MUTATION_COLORS[mutation]
		if mutationColor == "Rainbow" then
			animateRainbow(mutationLabel)
		elseif mutationColor == "YinYang" then
			-- Alternate the label too
			task.spawn(function()
				local flip = false
				while mutationLabel and mutationLabel.Parent do
					flip = not flip
					mutationLabel.TextColor3 = flip and Color3.new(1,1,1) or Color3.new(0,0,0)
					task.wait(0.5)
				end
			end)
		elseif mutationColor then
			mutationLabel.TextColor3 = mutationColor
		end
	end

	billboard.Parent = brainrotModel 
end

-- "$0" billboard on the CollectTrigger.  Returns the TextLabel so we can
-- cache it and update cheaply every second.


-- ==========================================================
-- CORE LOGIC
-- ==========================================================
local function playerOwnsBase(player, slot)
	local base = slot.Parent
	if not base or not base:IsA("Model") then return false end
	local ownerValue = base:FindFirstChild("Owner")
	return ownerValue and ownerValue:IsA("StringValue") and ownerValue.Value == player.Name
end

-- Returns the tool only if it exists in Brainrot pack1
local function getEquippedBrainrot(player)
	if not player.Character then return nil end
	local tool = player.Character:FindFirstChildOfClass("Tool")
	if not tool or not BrainrotPackFolder then return nil end
	for _, item in pairs(BrainrotPackFolder:GetChildren()) do
		if item.Name == tool.Name then return tool end
	end
	return nil
end

-- PLACE  â€”  moves the tool into the slot (no clone, no destroy)
-- Helper to get Rebirths (Place this above the main function if you haven't already)
local function getRebirthMultiplier(player)
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats then
		local rebirths = leaderstats:FindFirstChild("Rebirths")
		if rebirths then
			-- Formula: 1x base + 0.5x per rebirth (e.g., 2 Rebirths = 2x income)
			return 1 + (rebirths.Value * 0.5) 
		end
	end
	return 1
end
-- Function to show ownership warning GUI with animation
local hideTask = nil 
local currentTween = nil 

local function showOwnershipWarning(player)
	local playerGui = player:WaitForChild("PlayerGui", 5)
	if not playerGui then return end

	local sg = playerGui:FindFirstChild("OwnershipGUI")
	if not sg then return end

	local f = sg:FindFirstChild("MainFrame")
	if not f then return end

	-- 1. CANCEL OLD TIMERS
	-- If the GUI is already waiting to go up, stop the timer so it stays down.
	if hideTask then
		task.cancel(hideTask)
		hideTask = nil
	end

	-- 2. STOP CURRENT MOTION
	if currentTween then
		currentTween:Cancel()
	end

	-- 3. RESET START POSITION (Only if hidden)
	if not sg.Enabled then
		sg.Enabled = true
		f.Position = UDim2.new(0.5, 0, -0.2, 0)
	end

	-- 4. DROP ANIMATION (TIGHTER ELASTIC)
	-- 0.8 seconds is the "sweet spot" for Elastic. 
	-- It snaps into place like a real spring.
	local dropInfo = TweenInfo.new(
		0.8, 
		Enum.EasingStyle.Elastic, 
		Enum.EasingDirection.Out
	)

	currentTween = TweenService:Create(f, dropInfo, {
		Position = UDim2.new(0.5, 0, 0.15, 0)
	})
	currentTween:Play()

	-- 5. WAIT & HIDE
	hideTask = task.spawn(function()
		-- CHANGED: Reduced wait time to 1.2 seconds (Stay on ground for less)
		task.wait(1.2)

		local upInfo = TweenInfo.new(
			0.4, -- Fast exit
			Enum.EasingStyle.Back, -- "Back" creates a nice anticipation effect
			Enum.EasingDirection.In
		)

		currentTween = TweenService:Create(f, upInfo, {
			Position = UDim2.new(0.5, 0, -0.2, 0)
		})
		currentTween:Play()
		currentTween.Completed:Wait()

		-- Fully hide
		sg.Enabled = false
		hideTask = nil
		currentTween = nil
	end)
end
-- THE MAIN FUNCTION
local function placeBrainrotOnSlot(player, slot)
	-- 1. Check Ownership
	if not playerOwnsBase(player, slot) then
		showOwnershipWarning(player)
		return false, "You don't own this base!"

	end

	local displayPart = slot:FindFirstChild("DisplayPosition")
	if not displayPart then
		return false, "Slot missing DisplayPosition!"
	end

	-- 2. DECIDE: Pickup or Place?
	local currentSlotData = slotData[slot]

	if currentSlotData then
		-- ==========================================
		--               PICKUP LOGIC
		-- ==========================================
		-- >>> SWAP CHECK (SLOT SYSTEM) <<<
		local currentCount = 0
		local eq = player.Character and player.Character:FindFirstChildOfClass("Tool")
		if player:FindFirstChild("Backpack") then
			for _, t in pairs(player.Backpack:GetChildren()) do
				if t:IsA("Tool") and t:GetAttribute("Rarity") then currentCount = currentCount + 1 end
			end
		end
		if eq and eq:GetAttribute("Rarity") then currentCount = currentCount + 1 end

		local maxCap = player:GetAttribute("BrainrotCapacity") or 1
		local isSwapping = false
		if currentCount >= maxCap then
			if eq and ReplicatedStorage:FindFirstChild("Brainrot pack1") and ReplicatedStorage["Brainrot pack1"]:FindFirstChild(eq.Name) then
				isSwapping = true -- Allow the pickup to proceed so we can swap
			else
				return false, "ðŸŽ’ Inventory Full! Equip a Brainrot to swap."
			end
		end
		-- >>> END SWAP CHECK <<<
		-- A. Auto-Collect Income (Don't lose money on pickup!)
		local timeElapsed = tick() - currentSlotData.lastUpdate
		local earned = math.ceil(timeElapsed * currentSlotData.incomeRate)
		local totalToGive = currentSlotData.accumulatedIncome + earned

		if totalToGive > 0 then
			local leaderstats = player:FindFirstChild("leaderstats")
			local money = leaderstats and leaderstats.Parent:FindFirstChild("MoneyRaw")
			if money then
				money.Value += totalToGive
				-- Update the visual label to $0
				if currentSlotData.incomeLabel then
					currentSlotData.incomeLabel.Text = "$0"
					currentSlotData.incomeLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
				end
				-- Optional: Fire client event for popup
				collectIncomeEvent:FireClient(player, true, "Collected on pickup!", totalToGive)
			end
		end

		-- B. Find the tool
		local brainrot = displayPart:FindFirstChildWhichIsA("Tool")
		if not brainrot then
			slotData[slot] = nil
			return false, "Glitch: Slot empty but data existed. Resetting."
		end

		-- C. Reset Tool Physics
		brainrot.Enabled = true
		for _, part in pairs(brainrot:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Anchored = false
				part.CanCollide = false 
			end
		end

		-- D. Give to Player
		-- D. Give to Player (Safely route to Backpack to prevent physics freeze)
		local backpack = player:FindFirstChild("Backpack")
		if backpack then
			brainrot.Parent = backpack
		else
			brainrot.Parent = player.Character
		end
		-- E. Clean up Data
		local tag = brainrot:FindFirstChild("NameTag")
		if tag then tag:Destroy() end

		slotData[slot] = nil 

		slot:SetAttribute("HasBrainrot", nil)
		slot:SetAttribute("BrainrotName", nil)
		slot:SetAttribute("IncomeRate", nil)
		slot:SetAttribute("Mutation", nil)
	-- >>> FIX: Force find the prompt to update text to "PLACE" <<<
		-- >>> PROMPT FIX: Slot is now EMPTY, so next action is PLACE <<<
		local prompt = slot:FindFirstChild("PlacePrompt", true)
		if prompt and prompt:IsA("ProximityPrompt") then 
			prompt.Enabled = false -- Forces the player's screen to refresh
			prompt.ActionText = "Place Brainrot" 
			prompt.Enabled = true
		end
		if isSwapping then
			-- Immediately trigger the Place logic for the newly equipped tool!
			return placeBrainrotOnSlot(player, slot)
		end

		return true, "Picked up " .. brainrot.Name .. "!"

	else
		-- ==========================================
		--               PLACE LOGIC
		-- ==========================================

		local brainrot = getEquippedBrainrot(player)
		if not brainrot then
			return false, "Equip a valid Brainrot first!"
		end

		-- A. Calculate Base Rate
		local baseIncome = BRAINROT_INCOME[brainrot.Name]
		if not baseIncome then
			warn("âš ï¸ '" .. brainrot.Name .. "' not in BRAINROT_INCOME. Defaulting to 1.")
			baseIncome = 1
		end

		-- B. Apply Rebirth Multiplier (for display purposes)
		local rebirthMult = getRebirthMultiplier(player)

		-- C. Read Mutation (if it exists from spawning system) for display
		local mutation = brainrot:GetAttribute("Mutation")
		local mutationMult = brainrot:GetAttribute("MutationMult") or 1
		if mutation then
			mutationMult = MUTATION_MULTIPLIERS[mutation] or 1
			print("âœ¨ READING MUTATION: " .. brainrot.Name .. " has " .. mutation .. "! (" .. mutationMult .. "x multiplier)")
		end

		-- D. Calculate display income rate (mutations will be applied during collection)
		local finalIncomeRate = math.ceil(baseIncome * rebirthMult * mutationMult)
		local brainrotName = brainrot.Name

		-- E. Move Tool
		brainrot.Parent = displayPart
		brainrot.Enabled = false

		-- F. Lock Physics
		for _, part in pairs(brainrot:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Anchored = true
				part.CanCollide = false
				if part.Name == "Handle" and part:FindFirstChild("TouchInterest") then
					part.TouchInterest:Destroy()
				end
			end
		end

		-- G. Position
		brainrot:PivotTo(displayPart.CFrame * CFrame.Angles(0, math.rad(90), 0))

		-- H. Add UI (with mutation info)
		-- H. Add UI (with mutation info)
addRarityDisplay(brainrot, displayPart)  -- ADD THIS NEW LINE
addSlotNameTag(brainrot, finalIncomeRate, mutation, displayPart)

		-- I. Apply mutation visual effects
		if mutation then
			applyMutationVisuals(brainrot, mutation)
		end

		-- I. Save Data (mutation will be read from tool during collection)
		slotData[slot] = {
			brainrotName      = brainrotName,
			baseIncome        = baseIncome,  -- Store base for recalculation
			incomeRate        = finalIncomeRate, -- Current calculated rate (for display)
			accumulatedIncome = 0,
			lastUpdate        = tick(),
			incomeLabel       = incomeLabels[slot],
			tool              = brainrot,    -- Store reference to the tool itself
		}

		slot:SetAttribute("HasBrainrot",  true)
		slot:SetAttribute("BrainrotName", brainrotName)
		slot:SetAttribute("IncomeRate",   finalIncomeRate)
		if mutation then
			slot:SetAttribute("Mutation", mutation)
		end

		local mutationText = mutation and (" [" .. mutation .. " " .. mutationMult .. "x]") or ""
		print("âœ… " .. player.Name .. " placed " .. brainrotName .. mutationText .. " (Rebirth: " .. rebirthMult .. "x, Final: $" .. finalIncomeRate .. "/sec)")
		-- >>> PROMPT FIX: Slot is now FULL, so next action is PICK UP <<<
		local prompt = slot:FindFirstChild("PlacePrompt", true)
		if prompt and prompt:IsA("ProximityPrompt") then 
			prompt.Enabled = false -- Forces the player's screen to refresh
			prompt.ActionText = "Pick up Brainrot" 
			prompt.Enabled = true
		end

		local mutationText = mutation and (" [" .. mutation .. " " .. mutationMult .. "x]") or ""
		return true, "Placed " .. brainrotName .. "! (+" .. finalIncomeRate .. "/sec)" .. (mutation and " [" .. mutation .. "!]" or "")
	end
end

-- COLLECT
local function collectIncome(player, slot)
	if not playerOwnsBase(player, slot) then
		showOwnershipWarning(player)
		return false, "You don't own this base!", 0

	end

	local data = slotData[slot]
	if not data then
		return false, "No brainrot in this slot!", 0
	end

	-- Get current multiplier dynamically
	local currentRebirthMult = getRebirthMultiplier(player)

	-- Get base income
	local baseIncome = data.baseIncome or BRAINROT_INCOME[data.brainrotName] or 1

	-- READ MUTATION FROM TOOL DYNAMICALLY
	local mutationMult = 1
	if data.tool and data.tool:IsDescendantOf(game) then
		local mutation = data.tool:GetAttribute("Mutation")
		if mutation then
			mutationMult = MUTATION_MULTIPLIERS[mutation] or 1
		end
	end

	-- Calculate the real rate right now (Base * Rebirth * Mutation)
	local currentRealRate = baseIncome * currentRebirthMult * mutationMult

	-- Accumulate since last tick using the REAL rate
	local now = tick()
	data.accumulatedIncome = data.accumulatedIncome + (now - data.lastUpdate) * currentRealRate
	data.lastUpdate = now

	local totalIncome = math.ceil(data.accumulatedIncome)
	if totalIncome <= 0 then
		return false, "No income to collect yet!", 0
	end

	-- Pay out
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then return false, "Leaderstats not found!", 0 end
	local money = leaderstats.Parent:FindFirstChild("MoneyRaw") or leaderstats:FindFirstChild("Cash") or leaderstats:FindFirstChild("Coins")
	if not money then return false, "Money stat not found!", 0 end

	money.Value = money.Value + totalIncome
	data.accumulatedIncome = data.accumulatedIncome - totalIncome

	-- Immediately refresh the billboard
	-- Immediately refresh the billboard
	-- Immediately refresh the billboard
	if data.incomeLabel then
		local amount = math.ceil(data.accumulatedIncome)
		if amount > 0 then
			data.incomeLabel.Parent.Visible = true
			data.incomeLabel.Text = "$" .. amount
		else
			data.incomeLabel.Parent.Visible = false
		end
	end

	print("ðŸ’° " .. player.Name .. " collected $" .. totalIncome .. " from " .. slot.Name)
	return true, "Collected $" .. totalIncome .. "!", totalIncome
end

-- ==========================================================
-- REMOTE EVENTS
-- ==========================================================
placeBrainrotEvent.OnServerEvent:Connect(function(player, slot)
	if typeof(slot) ~= "Instance" or not slot:IsDescendantOf(BASES_FOLDER) then return end
	local ok, msg = placeBrainrotOnSlot(player, slot)
	placeBrainrotEvent:FireClient(player, ok, msg)
end)

collectIncomeEvent.OnServerEvent:Connect(function(player, slot)
	if slot and typeof(slot) == "Instance" then
		local ok, msg, amount = collectIncome(player, slot)
		collectIncomeEvent:FireClient(player, ok, msg, amount)
	end
end)

-- ==========================================================
-- SCAN & DYNAMIC BINDING
-- ==========================================================
print("?? Scanning BrainrotBases and listening for new floors...")

local function setupSlot(slot)
	if not (slot:IsA("Model") and slot.Name:match("Slot")) then return end

	-- 1. CollectTrigger
	local collectTrigger = slot:FindFirstChild("CollectTrigger")
	if collectTrigger then
		local bb = collectTrigger:FindFirstChild("IncomeBillboard")
		local frame = bb and bb:FindFirstChild("Frame")
		local label = frame and frame:FindFirstChild("IncomeText")

		if label then
			incomeLabels[slot] = label
			label.Text = "$0"
			frame.Visible = false
		end

		collectTrigger.Touched:Connect(function(hit)
			local player = Players:GetPlayerFromCharacter(hit.Parent)
			if not player then return end
			local lastCollect = player:GetAttribute("LastCollectTime") or 0
			if tick() - lastCollect <= 0.5 then return end
			player:SetAttribute("LastCollectTime", tick())

			local ok, msg, amount = collectIncome(player, slot)
			if ok then collectIncomeEvent:FireClient(player, ok, msg, amount) end
		end)
	end

	-- 2. ProximityPrompt
	local placePrompt = slot:FindFirstChild("PlacePrompt")
	if not placePrompt then
		for _, part in pairs(slot:GetChildren()) do
			local found = part:FindFirstChild("PlacePrompt")
			if found then placePrompt = found; break end
		end
	end

	if placePrompt and placePrompt:IsA("ProximityPrompt") then
		placePrompt.Triggered:Connect(function(player)
			local ok, msg = placeBrainrotOnSlot(player, slot)
			placeBrainrotEvent:FireClient(player, ok, msg)
		end)
	end
end

-- Scan existing bases on startup
for _, base in pairs(BASES_FOLDER:GetChildren()) do
	if base:IsA("Model") then
		for _, child in pairs(base:GetChildren()) do
			setupSlot(child)
		end
	end
end

-- Listen for new floors being built so their slots work!
BASES_FOLDER.DescendantAdded:Connect(function(descendant)
	if descendant:IsA("Model") and descendant.Name:match("Slot") then
		-- A tiny yield ensures all children (like CollectTrigger) are fully loaded in the clone
		task.wait(0.1) 
		setupSlot(descendant)
	end
end)
-- ==========================================================
-- UPDATE LOOP  â€”  accumulate income & refresh billboards every second
-- ==========================================================
task.spawn(function()
    while true do
        task.wait(1)

        -- 1. Initialize totals ONLY for players who actually own a base
        local playerTotals = {} 
        for playerName, base in pairs(assignedBases) do
            playerTotals[playerName] = 0
        end

        -- 2. Calculate income from active slots
        for slot, data in pairs(slotData) do
            -- Find the owner of this slot
            local base = slot.Parent
            local ownerValue = base and base:FindFirstChild("Owner")
            local ownerName = ownerValue and ownerValue.Value
            local player = Players:FindFirstChild(ownerName)

            -- If the player is still in the game (and owns this slot)
            if player then
                local currentRealRate = 1 

                -- Get multipliers
                local rebirthMult = getRebirthMultiplier(player)

                -- Base income
                local baseIncome = data.baseIncome or BRAINROT_INCOME[data.brainrotName] or 1

                -- Mutation maultiplier
                local mutationMult = 1
                if data.tool and data.tool:IsDescendantOf(game) then
                    local mutation = data.tool:GetAttribute("Mutation")
                    if mutation then
                        mutationMult = MUTATION_MULTIPLIERS[mutation] or 1
                    end
                end

                -- Final Calc
                currentRealRate = baseIncome * rebirthMult * mutationMult

                -- ADD TO PLAYER TOTAL
                if playerTotals[player.Name] ~= nil then
                    playerTotals[player.Name] = playerTotals[player.Name] + currentRealRate
                end

                -- Accumulate income for the slot (Backend logic)
                local now = tick()
                data.accumulatedIncome = data.accumulatedIncome + (now - data.lastUpdate) * currentRealRate
                data.lastUpdate = now

                -- Update the small text on the slot itself
				-- Update the small text on the slot itself
				local label = data.incomeLabel
				if label then
					local amount = math.ceil(data.accumulatedIncome)

					if amount > 0 then
						-- Show the background frame and text
						label.Parent.Visible = true 
						label.Text = "$" .. amount

						if amount >= 100 then
							label.TextColor3 = Color3.fromRGB(255, 100, 255)   -- purple
						elseif amount >= 50 then
							label.TextColor3 = Color3.fromRGB(255, 215, 0)     -- gold
						else
							label.TextColor3 = Color3.fromRGB(100, 255, 100)   -- green
						end
					else
						-- Hide everything if 0
						label.Parent.Visible = false 
					end
				
                    -- >>> CHANGED LOGIC END <<<
                end
            end
        end

        -- 3. PRINT & UPDATE GUI ONLY FOR BASE OWNERS
        for playerName, totalMPS in pairs(playerTotals) do
            -- (Keep your existing MPS display logic here exactly as it was)
            local player = Players:FindFirstChild(playerName)
            if player and player.Character then
                local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local incomeGui = rootPart:FindFirstChild("MPSDisplay")
                    local textLabel
                    if not incomeGui then
                        incomeGui = Instance.new("BillboardGui")
                        incomeGui.Name = "MPSDisplay"
                        incomeGui.Size = UDim2.new(6, 0, 1.5, 0) 
                        incomeGui.StudsOffset = Vector3.new(0, 3.5, 0) 
                        incomeGui.AlwaysOnTop = true 
                        
                        textLabel = Instance.new("TextLabel")
                        textLabel.Parent = incomeGui
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.TextScaled = true 
                        textLabel.Font = Enum.Font.FredokaOne
                        textLabel.TextColor3 = Color3.fromRGB(85, 255, 127)
                        textLabel.TextStrokeTransparency = 0 
                        
                        incomeGui.Parent = rootPart
                    else
                        textLabel = incomeGui:FindFirstChild("TextLabel")
                    end

                    if textLabel then
                        textLabel.Text = "+$" .. totalMPS .. "/s"
                    end
                end
            end
        end
    end
end)

print("âœ… BrainrotSlotSystem fully loaded with mutation support!")


-- ==========================================================
-- UPDATE LOOP â€” accumulate income & refresh billboards every second
-- ==========================================================
task.spawn(function()
	while true do
		task.wait(1)

		-- 1. Initialize totals ONLY for players who actually own a base
		local playerTotals = {} 
		for playerName, base in pairs(assignedBases) do
			playerTotals[playerName] = 0
		end

		-- 2. Calculate income from active slots
		for slot, data in pairs(slotData) do
			-- Find the owner of this slot
			local base = slot.Parent
			local ownerValue = base and base:FindFirstChild("Owner")
			local ownerName = ownerValue and ownerValue.Value
			local player = Players:FindFirstChild(ownerName)

			-- If the player is still in the game (and owns this slot)
			if player then
				local currentRealRate = 1 

				-- Get multipliers
				local rebirthMult = getRebirthMultiplier(player)

				-- Base income
				local baseIncome = data.baseIncome or BRAINROT_INCOME[data.brainrotName] or 1

				-- Mutation multiplier
				local mutationMult = 1
				if data.tool and data.tool:IsDescendantOf(game) then
					local mutation = data.tool:GetAttribute("Mutation")
					if mutation then
						mutationMult = MUTATION_MULTIPLIERS[mutation] or 1
					end
				end

				-- Final Calc
				currentRealRate = baseIncome * rebirthMult * mutationMult

				-- ADD TO PLAYER TOTAL
				-- We only add if they are in our 'assignedBases' list (sanity check)
				if playerTotals[player.Name] ~= nil then
					playerTotals[player.Name] = playerTotals[player.Name] + currentRealRate
				end

				-- Accumulate income for the slot (Backend logic)
				local now = tick()
				data.accumulatedIncome = data.accumulatedIncome + (now - data.lastUpdate) * currentRealRate
				data.lastUpdate = now

				-- Update the small text on the slot itself
				local label = data.incomeLabel
				if label then
					local amount = math.ceil(data.accumulatedIncome)
					label.Text = "$" .. amount

					if amount >= 100 then
						label.TextColor3 = Color3.fromRGB(255, 100, 255)   -- purple
					elseif amount >= 50 then
						label.TextColor3 = Color3.fromRGB(255, 215, 0)     -- gold
					else
						label.TextColor3 = Color3.fromRGB(100, 255, 100)   -- green
					end
				end
			end
		end

		-- 3. PRINT & UPDATE GUI ONLY FOR BASE OWNERS
		for playerName, totalMPS in pairs(playerTotals) do
			

			local player = Players:FindFirstChild(playerName)
			if player and player.Character then
				local rootPart = player.Character:FindFirstChild("HumanoidRootPart")

				if rootPart then
					local incomeGui = rootPart:FindFirstChild("MPSDisplay")
					local textLabel

					if not incomeGui then
						-- CREATE IT ONLY ONCE
						incomeGui = Instance.new("BillboardGui")
						incomeGui.Name = "MPSDisplay"
						incomeGui.Size = UDim2.new(6, 0, 1.5, 0) 
						incomeGui.StudsOffset = Vector3.new(0, 3.5, 0) 
						incomeGui.AlwaysOnTop = true 

						textLabel = Instance.new("TextLabel")
						textLabel.Parent = incomeGui
						textLabel.Size = UDim2.new(1, 0, 1, 0)
						textLabel.BackgroundTransparency = 1
						textLabel.TextScaled = true 
						textLabel.Font = Enum.Font.FredokaOne
						textLabel.TextColor3 = Color3.fromRGB(85, 255, 127) -- Money Green
						textLabel.TextStrokeTransparency = 0 -- Black outline

						incomeGui.Parent = rootPart
					else
						textLabel = incomeGui:FindFirstChild("TextLabel")
					end

					if textLabel then
						textLabel.Text = "+$" .. totalMPS .. "/s"
					end
				end
			end
		end
	end
end)
e|S|Rebirth
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local rebirthevent = ReplicatedStorage.RemoteEvents:WaitForChild("rebirthevent")

	-- CONFIGURATION
	local BASE_REBIRTH_COST = 100000 -- First rebirth cost
	local COST_MULTIPLIER = 1.5      -- Multiplier per rebirth (exponential growth)

	-- Cost formula options (choose one by uncommenting):
	local function calculateCost(rebirthCount)
		-- OPTION 1: Exponential (recommended for simulators)
		-- Gets expensive quickly: 100k, 150k, 225k, 337.5k, 506.25k...
		return math.floor(BASE_REBIRTH_COST * (COST_MULTIPLIER ^ rebirthCount))

		-- OPTION 2: Linear
		-- Steady increase: 100k, 200k, 300k, 400k...
		-- return BASE_REBIRTH_COST * (rebirthCount + 1)

		-- OPTION 3: Quadratic
		-- Moderate scaling: 100k, 200k, 400k, 800k, 1.6M...
		-- return BASE_REBIRTH_COST * ((rebirthCount + 1) ^ 2)

		-- OPTION 4: Fibonacci-style
		-- Unique progression
		-- if rebirthCount == 0 then return BASE_REBIRTH_COST end
		-- if rebirthCount == 1 then return BASE_REBIRTH_COST * 2 end
		-- return calculateCost(rebirthCount - 1) + calculateCost(rebirthCount - 2)
	end

	rebirthevent.OnServerEvent:Connect(function(player)
		local leaderstats = player:FindFirstChild("leaderstats")
		if not leaderstats then return end

		local moneyRaw = player:FindFirstChild("MoneyRaw")
		local rebirths = leaderstats:FindFirstChild("Rebirths")

		if not moneyRaw or not rebirths then return end

		-- Calculate current cost based on rebirth count
		local currentCost = calculateCost(rebirths.Value)

		-- Check if player can afford it
		if moneyRaw.Value >= currentCost then
			-- Reset money and increment rebirths
			moneyRaw.Value = 0
			rebirths.Value = rebirths.Value + 1

			print(player.Name .. " rebirthed! Now at: " .. rebirths.Value .. " rebirths")

			-- Send success back to client (for UI feedback)
			rebirthevent:FireClient(player, true, rebirths.Value)
		else
			-- Send failure back to client
			warn(player.Name .. " tried to rebirth but needs $" .. currentCost .. " (has $" .. moneyRaw.Value .. ")")
			rebirthevent:FireClient(player, false, currentCost)
		end
	end)
e|S|Selling System
-- Put this in ServerScriptService/ShopSystem
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Sell prices based on individual brainrot name
local SELL_PRICES = {
	-- COMMON
	["Tralalero Tralala"] = 10000000,
	["Spioniro Golubiro"] = 750000,
	["Quivioli Ameleonni"] = 225000,
	["Strawberrelli Flamingelli"] = 275000,
	["Strawberry Elephant"] = 500000000000,
	["Ti Ti Ti Sahur"] = 37500,
	["Spaghetti Tualetti"] = 50000000000,
	["Salamino Penguino"] = 400000,
	["Rhino Toasterino"] = 450000,
	["Tric Trac Baraboom"] = 9000,
	["Torrtuginni Dragonfrutini"] = 120000000,
	["Sammyni Spyderini"] = 100000000,
	["Urubini Flamenguini"] = 35000000,
	["Unclito Samito"] = 20000000,
	["Trippi Troppi"] = 2000,
	["Te Te Te Sahur"] = 4000000,
	["Svinina Bombardino"] = 1200,
	["Ta Ta Ta Ta Sahur"] = 7500,
	["Sigma Girl"] = 340000,
	["Trulimero Trulicina"] = 20000,
	["Trenostruzzo Turbo 3000"] = 35000000,
	["Talpa Di Fero"] = 1000,
	["Tim Cheese"] = 500,
	["Trippi Troppi Troppa Trippa"] = 30000000,
	["Taco Lucky Block"] = 500000,
	["Tralaledon"] = 15000000000,
	["Tigrilini Watermelini"] = 1700000,
	["Zibra Zubra Zibralini"] = 1000000,
	["Tracoducotulu Delapeladustuz"] = 4200000,
	["Tralalita Tralala"] = 20000000,
	["Tigroligre Frutonni"] = 14000000,
	["Sigma Boy"] = 325000,
	["To to to Sahur"] = 550000000,
	["Tipi Topi Taco"] = 17500000,
	["Pot Hotspot"] = 500000000,
	["Tukanno Bananno"] = 22500000,
	["Tung Tung Tung Sahur"] = 2500000,
	["Secret Lucky Block"] = 750000000,
	["67"] = 2600000000,
	["Admin Lucky Block"] = 1000000000,
	["Agarrini la Palini"] = 160000000,
	["Alessio"] = 18000000,
	["Antonio"] = 6000000,
	["Avocadini Antilopini"] = 17500,
	["Avocadini Guffo"] = 35000,
	["Avocadorilla"] = 2000000,
	["Ballerina Cappuccina"] = 100000,
	["Ballerino Lololo"] = 45000000,
	["Bambini Crostini"] = 225000,
	["Bananita Dolphinita"] = 25000,
	["Bandito Axolito"] = 12500,
	["Bandito Bobritto"] = 4500,
	["Bisonte Giuppitere"] = 75000000,
	["Blackhole Goat"] = 140000000,
	["Blueberrinni Octopusini"] = 250000,
	["Bombardiro Crocodilo"] = 500000,
	["Bombombini Gusini"] = 1000000,
	["Boneca Ambalabu"] = 5000,
	["Brainrot God Lucky Block"] = 5000000,
	["Brr Brr Patapim"] = 15000,
	["Brr es Teh Patipum"] = 65000000,
	["Brri Brri Bicus Dicus Bombicus"] = 30000,
	["Bulbito Bandito Traktorito"] = 48000000,
	["Burbaloni Loliloli"] = 100000,
	["Cacasito Satalito"] = 125000,
	["Cacto Hipopotamo"] = 6500,
	["Cappuccino Assassino"] = 10000,
	["Caramello Filtrello"] = 255000,
	["Carloo"] = 4500000,
	["Carrotini Brainini"] = 4700000,
	["Cavallo Virtuoso"] = 2500000,
	["Celularcini Viciosini"] = 10000000000,
	["Chachechi"] = 150000000,
	["Chef Crabracadabra"] = 150000,
	["Chicleteira Bicicleteira"] = 3500000,
	["Chihuanini Taconini"] = 8500000,
	["Chimpanzini Bananini"] = 50000,
	["Cocofanto Elefanto"] = 5000000,
	["Crabbo Limonetta"] = 1250000,
	["Dragon Cannelloni"] = 100000000000,
	["Dug dug dug"] = 255000,
	["Dul Dul Dul"] = 130000000,
	["Esok Sekolah"] = 3000000,
	["Espresso Signora"] = 15000000,
	["Extinct Ballerina"] = 30000000,
	["Extinct Matteo"] = 250000000,
	["Extinct Tralalero"] = 175000000,
	["Fluriflura"] = 750,
	["Fragola La La La"] = 180000000,
	["Frigo Camelo"] = 350000,
	["Ganganzelli Trulala"] = 3500000,
	["Gangster Footera"] = 4000,
	["Garama and Madundung"] = 40000000000,
	["Gattatino Nyanino"] = 7500000,
	["Gattito Tacoto"] = 40000000,
	["Girafa Celestre"] = 7500000,
	["Glorbo Fruttodrillo"] = 200000,
	["Gorillo Watermelondrillo"] = 3000000,
	["Graipuss Medussi"] = 400000000,
	["Guerriro Digitale"] = 1000000000,
	["Job Job Job Sahur"] = 350000000,
	["Karkerkar Kurkur"] = 550000,
	["Ketchuru and Musturu"] = 30000000000,
	["Ketupat Kepat"] = 25000000000,
	["La Cucaracha"] = 220000000,
	["La Extinct Grande"] = 235000000,
	["La Grande Combinasion"] = 750000000,
	["La Karkerkar Combinasion"] = 7500000000,
	["La Sahur Combinasion"] = 550000000,
	["La Vacca Saturno Saturnita"] = 110000000,
	["Las Capuchinas"] = 185000,
	["Las Sis"] = 8000000000,
	["Las Tralaleritas"] = 650000,
	["Las Vaquitas Saturnitas"] = 60000,
	["Lerulerulerule"] = 3500000,
	["Lionel Cactuseli"] = 175000,
	["LirilÃ¬ LarilÃ "] = 250,
	["Los Bombinitos"] = 60000000,
	["Los Bros"] = 12000000000,
	["Los Chicleteiras"] = 4500000,
	["Los Combinasionas"] = 15000000,
	["Los Crocodillitos"] = 12500000,
	["Los Hotspotsitos"] = 25000000,
	["Los Matteos"] = 100000000,
	["Los Noobinis"] = 4300000,
	["Los Nooo My Hotspotsitos"] = 3500000000,
	["Los Orcalitos"] = 45000000,
	["Los Spyderinis"] = 200000000,
	["Los Tacoritas"] = 16500000,
	["Los Tipi Tacos"] = 260000,
	["Los Tralaleritos"] = 300000000,
	["Los Tungtungtungcitos"] = 50000000,
	["Matteo"] = 10000000,
	["Mythic Lucky Block"] = 2500000,
	["Noobini Pizzanini"] = 25,
	["Nuclearo Dinossauro"] = 5000000000,
	["Odin Din Din Dun"] = 16000000,
	["Orangutini Ananassini"] = 400000,
	["Orcalero Orcala"] = 25000000,
	["Pakrahmatmamat"] = 55000000,
	["Pandaccini Bananini"] = 300000,
	["Penguino Cocosino"] = 45000,
	["Perochello Lemonchello"] = 27500,
	["Piccione Macchina"] = 65000000,
	["Pipi Avocado"] = 9500,
	["Pipi Corni"] = 1700,
	["Pipi Kiwi"] = 1500,
	["Pipi Potato"] = 265000,
}

	-- Reference to brainrot folder
	local BrainrotPackFolder = ReplicatedStorage:WaitForChild("Brainrot pack1", 10)

	-- Create RemoteEvent for selling
	local remoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
	if not remoteEvents then
		remoteEvents = Instance.new("Folder")
		remoteEvents.Name = "RemoteEvents"
		remoteEvents.Parent = ReplicatedStorage
	end

	local sellBrainrotEvent = remoteEvents:FindFirstChild("SellBrainrotEvent")
	if not sellBrainrotEvent then
		sellBrainrotEvent = Instance.new("RemoteEvent")
		sellBrainrotEvent.Name = "SellBrainrotEvent"
		sellBrainrotEvent.Parent = remoteEvents
	end

	-- Function to check if player has a valid brainrot equipped
	local function getEquippedBrainrot(player)
		if not player.Character then return nil end
		local tool = player.Character:FindFirstChildOfClass("Tool")
		if not tool or not BrainrotPackFolder then return nil end

		-- Verify it's actually a brainrot from our pack
		for _, item in pairs(BrainrotPackFolder:GetChildren()) do
			if item.Name == tool.Name then
				return tool
			end
		end
		return nil
	end

	-- Function to sell brainrot
	local function sellBrainrot(player)
		local brainrot = getEquippedBrainrot(player)

		if not brainrot then
			return false, "You need to hold a Brainrot to sell!", 0
		end

		-- Get sell price by brainrot name
		local brainrotName = brainrot.Name
		local sellPrice = SELL_PRICES[brainrotName]

		if not sellPrice then
			warn("âš ï¸ '" .. brainrotName .. "' not found in SELL_PRICES. Defaulting to $1.")
			sellPrice = 1
		end

		local rarity = brainrot:GetAttribute("Rarity") or "Unknown"

		-- Give player money
		local moneyRaw = player:FindFirstChild("MoneyRaw")
		if not moneyRaw then
			return false, "Money system not found!", 0
		end

		moneyRaw.Value = moneyRaw.Value + sellPrice

		-- Destroy the brainrot tool
		brainrot:Destroy()

		print("ðŸ’° " .. player.Name .. " sold " .. brainrotName .. " (" .. rarity .. ") for $" .. sellPrice)

		return true, "Sold " .. brainrotName .. " for $" .. sellPrice .. "!", sellPrice, brainrotName, rarity
	end

	-- Handle sell requests
	sellBrainrotEvent.OnServerEvent:Connect(function(player)
		print("ðŸ”” Sell request from " .. player.Name)
		local success, message, amount, name, rarity = sellBrainrot(player)
		print("ðŸ“¤ Sending result to client:", success, message, amount)
		sellBrainrotEvent:FireClient(player, success, message, amount, name, rarity)
	end)

	-- Setup shop ProximityPrompts in workspace
	local function setupShopPrompt(shopPart)
		local prompt = Instance.new("ProximityPrompt")
		prompt.Name = "ShopPrompt"
		prompt.ActionText = "Sell Brainrot"
		prompt.ObjectText = "Shop"
		prompt.MaxActivationDistance = 10
		prompt.HoldDuration = 0
		prompt.RequiresLineOfSight = false
		prompt.Parent = shopPart

		prompt.Triggered:Connect(function(player)
			local success, message, amount, name, rarity = sellBrainrot(player)
			sellBrainrotEvent:FireClient(player, success, message, amount, name, rarity)
		end)

		print("âœ… Shop prompt added to " .. shopPart:GetFullName())
	end

	-- Auto-find and setup shop parts (any part named "BrainrotSellLocation" or with "IsBrainrotShop" attribute)
	for _, obj in pairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") then
			if obj.Name == "BrainrotSellLocation" or obj:GetAttribute("IsBrainrotShop") == true then
				setupShopPrompt(obj)
			end
		end
	end

	print("âœ… Shop System loaded!")
e|S|CheckMoney
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local PurchaseEvent = ReplicatedStorage.RemoteEvents:WaitForChild("Purchasecoil") -- Use one event for the transaction
local ServerStorage = game:GetService("ServerStorage")

-- Configuration Table (Easy to add more items later!)
local ItemPrices = {
	["SpeedCoil"] = 500,
	["SuperSpeedCoil"] = 800 
}

PurchaseEvent.OnServerEvent:Connect(function(player, itemName)
	local price = ItemPrices[itemName]
	local tool = ServerStorage:WaitForChild(itemName)
	-- 1. Validate the item exists
	if not price then return end 

	-- 2. Secure Money Check
	local leaderstats = player:WaitForChild("leaderstats")
	local money = leaderstats.Parent:WaitForChild("MoneyRaw")

	if money.Value >= price then
		-- 3. The Transaction
		money.Value = money.Value - price -- Subtract money
		tool:Clone().Parent = player.Backpack -- Give the tool

		-- 4. Tell the Client it succeeded
		PurchaseEvent:FireClient(player, true, itemName)
		print(player.Name .. " bought " .. itemName)
	else
		-- 5. Tell the Client it failed
		PurchaseEvent:FireClient(player, false, "Insufficient Funds")
	end
end)
e|S|BaseUpgradeSystem
print("ðŸ—ï¸ BaseUpgradeSystem (Replicate Mode) starting...")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")

-- Ensure Remotes Exist
local remoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder", ReplicatedStorage)
remoteEvents.Name = "RemoteEvents"

local upgradeBaseEvent = remoteEvents:FindFirstChild("UpgradeBaseEvent") or Instance.new("RemoteEvent", remoteEvents)
upgradeBaseEvent.Name = "UpgradeBaseEvent"

local incomingEvent = remoteEvents:FindFirstChild("UpgradeBase") or Instance.new("RemoteEvent", remoteEvents)
incomingEvent.Name = "UpgradeBase"

-- ==========================================================
-- âš™ï¸ CONFIGURATION
-- ==========================================================
local BASES_FOLDER_NAME = "BrainrotBases"
local TEMPLATE_NAME = "SecondFloorReplicate" -- Name of the model to clone

local UPGRADE_CONFIG = {
	BaseCost = 1000,
	Multiplier = 1.5,
	Exponent = 1.3
}

-- ðŸ—ï¸ FLOOR POSITIONING CONFIGURATION
-- Controls the position of new floors relative to the base center

-- Vertical spacing (Y-axis)
-- Positive number = gap between floors
-- Negative number = floors overlap/squish together
-- 0 = floors touch perfectly (edge to edge)
local FLOOR_SPACING = -24.75

-- Horizontal offset (X-axis)
-- Positive = shift right, Negative = shift left
-- 0 = centered on base X position
local FLOOR_OFFSET_X = 4.8

-- Horizontal offset (Z-axis)
-- Positive = shift forward, Negative = shift backward
-- 0 = centered on base Z position
local FLOOR_OFFSET_Z = 5

-- ==========================================================
-- VARIABLES
-- ==========================================================
local BASES_FOLDER = Workspace:WaitForChild(BASES_FOLDER_NAME, 5)
local FLOOR_TEMPLATE = Workspace:WaitForChild(TEMPLATE_NAME, 5)

if not BASES_FOLDER or not FLOOR_TEMPLATE then
	warn("âŒ CRITICAL ERROR: Could not find 'BrainrotBases' folder or 'SecondFloorReplicate' model!")
	return
end

-- Track data
local baseData = {} 
-- Structure: 
-- baseData[baseModel] = {
--     Level = 1,
--     TopFloorModel = baseModel (Initially the base itself)
-- }

-- ==========================================================
-- ðŸ§® MATH HELPER FUNCTIONS
-- ==========================================================

local function calculateUpgradeCost(currentLevel)
	local cost = UPGRADE_CONFIG.BaseCost 
		* (UPGRADE_CONFIG.Multiplier ^ (currentLevel - 1)) 
		* (currentLevel ^ UPGRADE_CONFIG.Exponent)
	return math.floor(cost)
end

local function getBaseInfo(base)
	if not baseData[base] then
		baseData[base] = {
			Level = 1,
			TopFloorModel = base
		}
	end
	return baseData[base]
end

-- ==========================================================
-- ðŸŽ¨ VISUALS
-- ==========================================================

local function updateSignVisuals(base)
	local info = getBaseInfo(base)
	local cost = calculateUpgradeCost(info.Level)
	local text = "Upgrade to Floor " .. (info.Level + 1) .. "\n$" .. cost

	local upgradeSign = base:FindFirstChild("UpgradeSign")
	if upgradeSign then
		-- Update SurfaceGui
		local surfaceGui = upgradeSign:FindFirstChildWhichIsA("SurfaceGui", true)
		if surfaceGui then
			local label = surfaceGui:FindFirstChildWhichIsA("TextLabel", true)
			if label then label.Text = text end
		end

		-- Update ProximityPrompt
		local prompt = upgradeSign:FindFirstChildWhichIsA("ProximityPrompt", true)
		if prompt then
			prompt.ObjectText = "$" .. cost
			prompt.ActionText = "Upgrade (Lvl " .. (info.Level + 1) .. ")"
			prompt.Enabled = true
		end
	end
end

-- ==========================================================
-- ðŸ—ï¸ CORE UPGRADE LOGIC
-- ==========================================================

local function findBaseOwnedBy(player)
	for _, base in pairs(BASES_FOLDER:GetChildren()) do
		local ownerVal = base:FindFirstChild("Owner")
		if ownerVal and ownerVal.Value == player.Name then
			return base
		end
	end
	return nil
end

local function upgradeBase(player, base)
	local info = getBaseInfo(base)
	local cost = calculateUpgradeCost(info.Level)

	-- 1. Check Money
	local leaderstats = player:FindFirstChild("leaderstats")
	local money = leaderstats and (leaderstats.Parent:FindFirstChild("MoneyRaw") or leaderstats:FindFirstChild("Cash"))

	if not money then return false, "No money found!" end
	if money.Value < cost then return false, "Need $"..cost end

	-- 2. Prepare the New Floor
	local currentTop = info.TopFloorModel
	local newFloor = FLOOR_TEMPLATE:Clone()
	local nextLevel = info.Level + 1

	-- 3. Calculate Stacking Position
	local currentCF, currentSize = currentTop:GetBoundingBox()
	local newCF, newSize = newFloor:GetBoundingBox()
	local baseCF = base:GetBoundingBox() -- This is the "Anchor" rotation

	-- Calculate Height: Top of old floor + Half height of new floor + Floor Spacing
	local stackY = (currentSize.Y / 2) + (newSize.Y / 2) + FLOOR_SPACING

	-- Calculate Target Position with offsets:
	-- X = Base center + X offset
	-- Y = Calculated stack height above current top floor
	-- Z = Base center + Z offset
	local targetY = currentCF.Position.Y + stackY
	local targetPos = Vector3.new(
		baseCF.Position.X + FLOOR_OFFSET_X, 
		targetY, 
		baseCF.Position.Z + FLOOR_OFFSET_Z
	)

	-- ---------------------------------------------------------
	-- ðŸ”¥ CRITICAL FIX: FORCE ROTATION TO MATCH BASE ðŸ”¥
	-- ---------------------------------------------------------
	newFloor:PivotTo(CFrame.new(targetPos) * baseCF.Rotation)

	-- 4. Clean up the New Floor
	newFloor.Name = base.Name .. "_Floor" .. nextLevel
	for _, child in pairs(newFloor:GetChildren()) do
		if child.Name == "UpgradeSign" or child:IsA("Script") then
			child:Destroy()
		elseif child.Name == "Owner" then
			-- Don't destroy it! Set it to the player who owns the base so slots work.
			if child:IsA("StringValue") then
				child.Value = player.Name
			end
		end
	end

	newFloor.Parent = BASES_FOLDER

	-- 5. Finalize Transaction
	money.Value -= cost
	info.Level = nextLevel
	info.TopFloorModel = newFloor

	local skyHeight = leaderstats:FindFirstChild("Skyscraper Height")
	if skyHeight then skyHeight.Value = nextLevel end

	updateSignVisuals(base)

	print("âœ… " .. player.Name .. " stacked floor " .. nextLevel .. " (Offset: X=" .. FLOOR_OFFSET_X .. ", Y=" .. FLOOR_SPACING .. ", Z=" .. FLOOR_OFFSET_Z .. ")")
	return true, "Upgraded to Floor " .. nextLevel .. "!", nextLevel
end

-- ==========================================================
-- ðŸ“¡ EVENT LISTENERS
-- ==========================================================

incomingEvent.OnServerEvent:Connect(function(player)
	local playerBase = findBaseOwnedBy(player)
	if not playerBase then
		upgradeBaseEvent:FireClient(player, false, "You don't own a base!")
		return
	end

	-- Debounce check could go here
	local success, msg = upgradeBase(player, playerBase)
	upgradeBaseEvent:FireClient(player, success, msg)
end)

-- Initialize Signs on Load
for _, base in pairs(BASES_FOLDER:GetChildren()) do
	if base:IsA("Model") then
		updateSignVisuals(base)
	end
end
e|S|WeatherChangeSystem
local Remotes             = game.ReplicatedStorage:WaitForChild("RemoteEvents")
local weatherChangedEvent = Remotes:WaitForChild("WeatherChanged")
local getWeatherFunc      = Remotes:WaitForChild("GetCurrentWeather")
local WeatherSystem       = require(game.ReplicatedStorage:WaitForChild("WeatherSystem"))
local rainEvent           = Remotes:WaitForChild("StartRain") -- Fixed capitalization to match standard naming
local RunService          = game:GetService("RunService")

-- Mutation colors (must match Spawning System)
local MUTATION_COLORS = {
	["Gold"]        = Color3.fromRGB(255, 215, 0),
	["Diamond"]     = Color3.fromRGB(185, 242, 255),
	["Rainbow"]     = "Rainbow",
	["Bloodrot"]    = Color3.fromRGB(100, 0, 0),
	["Candy"]       = Color3.fromRGB(255, 105, 180),
	["Lava"]        = Color3.fromRGB(255, 80, 0),
	["Galaxy"]      = Color3.fromRGB(138, 43, 226),
	["Yin-Yang"]    = "YinYang",
	["Radioactive"] = Color3.fromRGB(0, 255, 50),
	["Wet"] = Color3.fromRGB(84, 130, 255)
}

-- Mutation multipliers (must match Spawning System)
local MUTATION_MULTIPLIERS = {
	["Gold"]        = 1.25,
	["Diamond"]     = 1.50,
	["Rainbow"]     = 10.0,
	["Bloodrot"]    = 2.0,
	["Candy"]       = 4.0,
	["Lava"]        = 6.0,
	["Galaxy"]      = 7.0,
	["Yin-Yang"]    = 7.5,
	["Radioactive"] = 8.5,
	["Wet"] = 1.5
}

-- Ensure WeatherSystem is fully loaded before accessing its properties
local EVENT_DURATION = WeatherSystem.EVENT_DURATION or 15
local CLEAR_DURATION = WeatherSystem.CLEAR_DURATION or 15

local function isDeveloper(player)
	if RunService:IsStudio() then return true end
	return player.UserId == game.CreatorId or player.UserId == 10378926133
end

local function getNextEvent()
	local events = WeatherSystem.WEATHER_EVENTS
	local idx = math.random(1, #events)
	local attempts = 0
	while idx == WeatherSystem._lastEventIndex and attempts < 10 do
		idx = math.random(1, #events)
		attempts += 1
	end
	WeatherSystem._lastEventIndex = idx
	return events[idx]
end

-- ============================================================
--  HELPER: Clean up mutations when weather changes
-- ============================================================
-- ============================================================
--  HELPER: Clean up mutations when weather changes
-- ============================================================


-- ============================================================
--  HELPER: set weather and broadcast
-- ============================================================
-- ============================================================
--  MUTATION STACKING HELPERS
-- ============================================================
local PERM_MUTATIONS = { ["Gold"]=true, ["Diamond"]=true, ["Rainbow"]=true }
local LIMITED_MUTATIONS = { ["Bloodrot"]=true, ["Candy"]=true, ["Lava"]=true, ["Galaxy"]=true, ["Yin-Yang"]=true, ["Radioactive"]=true, ["Wet"]=true }

local function getParsedMutations(mutationString)
	local perm, limited
	if not mutationString then return nil, nil end
	for p in pairs(PERM_MUTATIONS) do
		if string.find(mutationString, p) then perm = p end
	end
	for l in pairs(LIMITED_MUTATIONS) do
		if string.find(mutationString, l) then limited = l end
	end
	return perm, limited
end

local function calculateCombinedMultiplier(perm, limited)
	local bonus = 0
	if perm then bonus += (MUTATION_MULTIPLIERS[perm] or 0) end
	if limited then bonus += (MUTATION_MULTIPLIERS[limited] or 0) end
	return 1 + bonus
end

local function updateBrainrotMutationAndVisuals(luckyRot, perm, limited, visualData)
	-- Combine the names (e.g. "Gold, Radioactive")
	local newMutString
	if perm and limited then newMutString = perm .. ", " .. limited
	elseif perm then newMutString = perm
	elseif limited then newMutString = limited end

	luckyRot:SetAttribute("Mutation", newMutString)
	luckyRot:SetAttribute("MutationMult", calculateCombinedMultiplier(perm, limited))

	-- 1. UPDATE OVERHEAD LABEL
	local statsGUI = luckyRot:FindFirstChild("StatsGUI")
	if statsGUI then
		local lbl = statsGUI:FindFirstChild("MutationLabel")
		if not lbl then
			lbl = Instance.new("TextLabel")
			lbl.Name = "MutationLabel"
			lbl.Size = UDim2.new(1, 0, 0.2, 0)
			lbl.BackgroundTransparency = 1
			lbl.Font = Enum.Font.SourceSansBold
			lbl.TextScaled = true
			lbl.TextStrokeColor3 = Color3.new(0, 0, 0)
			lbl.TextStrokeTransparency = 0
			lbl.LayoutOrder = 2

			local constraint = Instance.new("UITextSizeConstraint")
			constraint.MaxTextSize = 35
			constraint.MinTextSize = 2
			constraint.Parent = lbl

			lbl.Parent = statsGUI
		end

		lbl.Text = "â­ " .. newMutString .. " â­"

		-- Color priority: Limited overwrites Perm on the label
		local mc = nil
		if limited and MUTATION_COLORS[limited] then mc = MUTATION_COLORS[limited]
		elseif perm and MUTATION_COLORS[perm] then mc = MUTATION_COLORS[perm] end

		if mc and typeof(mc) == "Color3" then lbl.TextColor3 = mc
		else lbl.TextColor3 = Color3.new(1,1,1) end
	end

	-- 2. APPLY VISUALS (Only applies Weather visual overrides)
	if visualData then
		for _, d in pairs(luckyRot:GetDescendants()) do
			if d:IsA("BasePart") or d:IsA("MeshPart") then
				local sa = d:FindFirstChildOfClass("SurfaceAppearance")
				if sa then sa:Destroy() end
				if visualData.material then d.Material = visualData.material end
				if visualData.reflectance then d.Reflectance = visualData.reflectance end
				if visualData.color and visualData.animated == false then d.Color = visualData.color end
			elseif d:IsA("SpecialMesh") then
				d.TextureId = ""
			end
		end

		-- Check if the specific limited mutation is still active before continuing the loop
		if visualData.animated == "galaxy" then
			task.spawn(function()
				local parts = {}
				for _, d in pairs(luckyRot:GetDescendants()) do
					if d:IsA("BasePart") then table.insert(parts, d) end
				end
				local t = 0
				while luckyRot and luckyRot.Parent and string.find(luckyRot:GetAttribute("Mutation") or "", limited) do
					t += 0.02
					local brightness = 0.5 + 0.5 * math.sin(t)
					local col = Color3.fromRGB(math.floor(75 + 63 * brightness), 0, math.floor(130 + 100 * brightness))
					for _, p in pairs(parts) do if p and p.Parent then p.Color = col end end
					task.wait(0.05)
				end
			end)
		elseif visualData.animated == "yinyang" then
			task.spawn(function()
				local parts = {}
				for _, d in pairs(luckyRot:GetDescendants()) do
					if d:IsA("BasePart") then table.insert(parts, d) end
				end
				local flip = false
				while luckyRot and luckyRot.Parent and string.find(luckyRot:GetAttribute("Mutation") or "", limited) do
					flip = not flip
					local col = flip and Color3.new(1, 1, 1) or Color3.new(0, 0, 0)
					for _, p in pairs(parts) do if p and p.Parent then p.Color = col end end
					task.wait(0.5)
				end
			end)
		elseif visualData.animated == "radioactive" then
			task.spawn(function()
				local parts = {}
				for _, d in pairs(luckyRot:GetDescendants()) do
					if d:IsA("BasePart") then table.insert(parts, d) end
				end
				local t = 0
				while luckyRot and luckyRot.Parent and string.find(luckyRot:GetAttribute("Mutation") or "", limited) do
					t += 0.08
					local brightness = 0.5 + 0.5 * math.sin(t)
					local g = math.floor(150 + 105 * brightness)
					local col = Color3.fromRGB(0, g, 0)
					for _, p in pairs(parts) do if p and p.Parent then p.Color = col end end
					task.wait(0.05)
				end
			end)
		end
	end
end

-- ============================================================
--  MAIN WEATHER CHANGE FUNCTION
-- ============================================================
local function setWeather(weatherName, duration)
	local data = WeatherSystem.WEATHER_TYPES[weatherName]
	local newLimitedMutation = data and data.mutation
	local visualData = nil

	-- Safely get visual data (Checking both possible locations)
	if newLimitedMutation then
		if WeatherSystem.LIMITED_VISUALS and WeatherSystem.LIMITED_VISUALS[newLimitedMutation] then
			visualData = WeatherSystem.LIMITED_VISUALS[newLimitedMutation]
		elseif data.visualData then
			visualData = data.visualData
		end
	end

	WeatherSystem._currentWeather = weatherName
	WeatherSystem._weatherEndTime = tick() + duration

	print(string.format("ðŸŒ¦ï¸ Weather changed â†’ %s (lasts %ds)", data.displayName, duration))
	weatherChangedEvent:FireAllClients(weatherName, data.displayName, data.color, data.description, duration)

	if weatherName == "Rain" then
		rainEvent:FireAllClients(false)
	else
		rainEvent:FireAllClients(true)
	end

	-- ==========================================
	-- 1. SWAP EXISTING MUTATIONS ON WEATHER CHANGE
	-- ==========================================
	if newLimitedMutation then
		for _, obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("Model") and obj:GetAttribute("Rarity") then
				local currentMut = obj:GetAttribute("Mutation")
				local perm, limited = getParsedMutations(currentMut)

				-- If it has an OLD limited mutation, REPLACE it with the NEW one immediately
				if limited and limited ~= newLimitedMutation then
					print("ðŸ”„ Swapped " .. limited .. " to " .. newLimitedMutation .. " on " .. obj.Name)
					updateBrainrotMutationAndVisuals(obj, perm, newLimitedMutation, visualData)
				end
			end
		end
	end

	-- ==========================================
	-- 2. RANDOM MUTATION LOOP
	-- ==========================================
	if weatherName ~= "Clear" and newLimitedMutation then
		task.spawn(function()
			local endTime = tick() + duration

			while tick() < endTime do
				task.wait(math.random(15, 30) / 10) 

				if tick() >= endTime or WeatherSystem._currentWeather ~= weatherName then 
					break 
				end

				local availableBrainrots = {}
				for _, obj in ipairs(workspace:GetDescendants()) do
					if obj:IsA("Model") and obj:GetAttribute("Rarity") then
						local currentMut = obj:GetAttribute("Mutation")
						local perm, limited = getParsedMutations(currentMut)

						-- Only mutate it if it DOES NOT already have a limited weather mutation
						if not limited then
							table.insert(availableBrainrots, obj)
						end
					end
				end

				if #availableBrainrots > 0 then
					local luckyRot = availableBrainrots[math.random(1, #availableBrainrots)]
					local currentMut = luckyRot:GetAttribute("Mutation")
					local perm, _ = getParsedMutations(currentMut)

					-- Combine the new limited mutation with the existing perm mutation (if any)
					updateBrainrotMutationAndVisuals(luckyRot, perm, newLimitedMutation, visualData)

					if announceRemote then
						announceRemote:FireAllClients(luckyRot.Name, newLimitedMutation, data.color)
					end
				end
			end
		end)
	end
end
local forceWeatherEvent = Remotes:WaitForChild("ForceWeather")
forceWeatherEvent.OnServerEvent:Connect(function(player, weatherName)
	if not isDeveloper(player) then return end
	if WeatherSystem.WEATHER_TYPES[weatherName] then
		setWeather(weatherName, EVENT_DURATION)
	end
end)

-- ============================================================
--  WEATHER CYCLE LOOP
-- ============================================================



task.spawn(function()
	print("ðŸŒ¤ï¸ Weather system started!")

	setWeather("Clear", CLEAR_DURATION)
	task.wait(CLEAR_DURATION)  -- was hardcoded to 30 â€” now uses your module value

	while true do
		local nextEvent = getNextEvent()
		setWeather(nextEvent, EVENT_DURATION)
		task.wait(EVENT_DURATION)

		setWeather("Clear", CLEAR_DURATION)
		task.wait(CLEAR_DURATION)
	end
end)



print("âœ… WeatherController loaded.")
e|S|RemoteSetup
-- RemoteSetup (Script) -- place in ServerScriptService
-- Runs FIRST to guarantee all RemoteEvents exist before any LocalScript loads.
-- Set RunContext to "Server" or just leave it as a normal Script.

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Ensure the folder exists
local Remotes = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not Remotes then
	Remotes = Instance.new("Folder")
	Remotes.Name = "RemoteEvents"
	Remotes.Parent = ReplicatedStorage
end

local function ensureRemoteEvent(name)
	if not Remotes:FindFirstChild(name) then
		local r = Instance.new("RemoteEvent")
		r.Name = name
		r.Parent = Remotes
	end
end

local function ensureRemoteFunction(name)
	if not Remotes:FindFirstChild(name) then
		local r = Instance.new("RemoteFunction")
		r.Name = name
		r.Parent = Remotes
	end
end

-- Spawn system remotes (your existing script uses these)
ensureRemoteEvent("randombrainrot")
ensureRemoteEvent("AutoSpawn")
ensureRemoteEvent("SpawnSpecificBrainrot")

-- Weather system remotes
ensureRemoteEvent("WeatherChanged")
ensureRemoteFunction("GetCurrentWeather")
ensureRemoteEvent("ForceWeather")

print("âœ… RemoteSetup: All RemoteEvents pre-created.")


-- Add this to the end of e|S|remotesetup
local WeatherSystem = require(game:GetService("ReplicatedStorage"):WaitForChild("WeatherSystem")) -- Adjust path to your module
local forceWeather = Remotes:WaitForChild("ForceWeather")

forceWeather.OnServerEvent:Connect(function(player, weatherName)
	-- [Add admin check here to prevent non-admins from using this]

	print("â˜ï¸ Admin " .. player.Name .. " requested weather: " .. weatherName)

	if weatherName == "Clear" then
		-- 1. Reset Logic variables
		WeatherSystem.CurrentWeather = "Clear"
		WeatherSystem.Multiplier = 1
		WeatherSystem.ActiveMutation = nil

		-- 2. Visual reset
		if WeatherSystem.ResetAtmosphere then
			WeatherSystem.ResetAtmosphere()
		end

		-- 3. Notify clients so UI and Watchers update
		Remotes.WeatherChanged:FireAllClients("Clear")
		print("â˜€ï¸ Weather Logic & Visuals fully reset.")
	else
		-- Start the logic for a specific event
		if WeatherSystem.StartEvent then
			WeatherSystem.StartEvent(weatherName)
		end
	end
end)
e|S|MoneyHandler
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local addMoneyEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("AddMoneyRequest")

-- ðŸ› ï¸ Helper: Check Developer Status
local function isDeveloper(player)
	-- Always allow in Studio
	if RunService:IsStudio() then
		return true
	end

	-- Allow if you are the owner OR if your ID matches
	return player.UserId == game.CreatorId or player.UserId == 10378926133 -- Put your ID here
end

local function onAddMoneyRequest(player, amount, targetUsername)
	-- ðŸ›¡ï¸ SECURITY: Check if player is developer
	if not isDeveloper(player) then
		warn("âŒ Security: " .. player.Name .. " attempted to add money but is not a developer")
		return
	end

	-- Validate the input
	if type(amount) ~= "number" or amount <= 0 then
		warn("âŒ Invalid amount requested by " .. player.Name .. ": " .. tostring(amount))
		return
	end

	-- Determine target player (default to requester if no username provided)
	local targetPlayer = player
	if targetUsername and targetUsername ~= "" then
		-- Find the target player by name
		for _, p in Players:GetPlayers() do
			if string.lower(p.Name) == string.lower(targetUsername) then
				targetPlayer = p
				break
			end
		end
	end

	-- Find and update the target player's money
	local leaderstats = targetPlayer:FindFirstChild("leaderstats")
	local money = leaderstats and leaderstats.Parent:FindFirstChild("MoneyRaw")

	if money then
		money.Value = money.Value + amount
		print("âœ… Added " .. amount .. " money to " .. targetPlayer.Name .. (targetPlayer ~= player and " (requested by " .. player.Name .. ")" or ""))
	else
		warn("âŒ Could not find Money leaderstat for " .. targetPlayer.Name)
	end
end

-- Connect the remote event
addMoneyEvent.OnServerEvent:Connect(onAddMoneyRequest)
e|S|Concentrator System
-- ================================================================
--  WeatherConcentratorSystem  (ServerScriptService)
--
--  Two-slot fusion system.  Players approach the WeatherConcentrator
--  and trigger the ProximityPrompt while holding a Brainrot tool.
--
--  Slot flow:
--    1st trigger  â†’  brainrot pivots to  concentratorModel.Left
--    2nd trigger  â†’  brainrot pivots to  concentratorModel.Right
--    Both filled  â†’  fusion fires (mutations stacked, 50/50 one
--                    is deleted, Gemini names the result)
--
--  SETUP CHECKLIST
--  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--  1. Enable HttpService        (Game Settings â†’ Security)
--  2. Enable DataStoreService   (Game Settings â†’ Security)
--  3. Place a Model called "WeatherConcentrator" in Workspace
--       â””â”€ PrimaryPart  (BasePart â€” the glowing pedestal)
--          â”œâ”€ Left       (BasePart â€” where the first brainrot lands)
--          â”œâ”€ Right      (BasePart â€” where the second brainrot lands)
--          â””â”€ ProximityPrompt  (direct child of PrimaryPart)
--             If absent, one is created automatically.
--  4. Paste your Gemini API key into CONFIG.GEMINI_API_KEY.
-- ================================================================

local Players           = game:GetService("Players")
local HttpService       = game:GetService("HttpService")
local DataStoreService  = game:GetService("DataStoreService")
local TweenService      = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local WeatherSystem = require(ReplicatedStorage:WaitForChild("WeatherSystem"))

local hum = game.ReplicatedStorage.Sounds["Electric Crackle"]
local flash = game.ReplicatedStorage.Sounds.shinji_electric_lightning_impactframes
-- ================================================================
--  CONFIG
-- ================================================================
local CONFIG = {
	GEMINI_API_KEY  = "AIzaSyCizTajdzKJzX613YWD3HlV6FdtfAF-v-Y",
	GEMINI_MODEL    = "gemini-3-flash",

	COST_SECONDS    = 45,
	MIN_COST        = 500,

	BASE_DISCOVERY_REWARD = 5000,
	DEPTH_MULTIPLIER      = 3.0,

	PLAYER_COOLDOWN          = 8,
	CONCENTRATOR_MODEL_NAME  = "WeatherConcentrator",
	DS_DISCOVERIES           = "ConcentratorDiscoveries_v2",
}
-- ================================================================
--  INVENTORY CAPACITY HELPER
-- ================================================================
local function countPlayerBrainrots(player)
	local count = 0
	local backpack = player:FindFirstChild("Backpack")
	if backpack then
		for _, tool in pairs(backpack:GetChildren()) do
			if tool:IsA("Tool") and tool:GetAttribute("Rarity") then
				count = count + 1
			end
		end
	end

	-- Check equipped tool
	if player.Character then
		local equippedTool = player.Character:FindFirstChildOfClass("Tool")
		if equippedTool and equippedTool:GetAttribute("Rarity") then
			count = count + 1
		end
	end

	return count
end
-- ================================================================
--  INCOME TABLE
-- ================================================================
local BRAINROT_INCOME = {
	["Noobini Pizzanini"]=1,["Lirili Larila"]=3,["Tim Cheese"]=5,
	["FluriFlura"]=7,["Talpa Di Fero"]=9,["Svinina Bombardino"]=10,
	["Noobini Santanini"]=11,["Racooni Jandelini"]=12,["Pipi Kiwi"]=13,
	["Tartaragno"]=13,["Pipi Corni"]=14,["Trippi Troppi"]=15,
	["Gangster Footera"]=30,["Bandito Bobritto"]=35,["Boneca Ambalabu"]=40,
	["Cacto Hipopotamo"]=50,["Ta Ta Ta Ta Sahur"]=55,["Tric Trac Baraboom"]=65,
	["Frogo Elfo"]=67,["Pipi Avocado"]=70,["Pinealotto Fruttarino"]=75,
	["Cappuccino Assassino"]=75,["Bandito Axolito"]=90,["Brr Brr Patapim"]=100,
	["Avocadini Antilopini"]=115,["Trulimero Trulicina"]=125,["Bambini Crostini"]=135,
	["Malame Amarele"]=140,["Bananita Dolphinita"]=150,["Perochello Lemonchello"]=160,
	["Brri Brri Bicus Dicus Bombicus"]=175,["Avocadini Guffo"]=225,
	["Ti Ti Ti Sahur"]=225,["Mangolini Parrocini"]=235,["Frogatto Piratto"]=240,
	["Salamino Penguino"]=250,["Doi Doi Do"]=260,["Penguin Tree"]=270,
	["Wombo Rollo"]=275,["Penguino Cocosino"]=300,["Mummio Rappito"]=325,
	["Chimpanzini Bananini"]=300,["Tirilikalika Tirilikalako"]=450,
	["Ballerina Cappuccina"]=500,["Burbaloni Loliloli"]=600,
	["Chef Crabracadabra"]=600,["Lionel Cactuseli"]=650,
	["Glorbo Fruttodrillo"]=750,["Quivoli Ameleoni"]=900,
	["Blueberrini Octopusini"]=1000,["Caramello Filtrello"]=1000,
	["Pipi Potato"]=1100,["Strawberrelli Flamingelli"]=1100,
	["Cocosini Mama"]=1200,["Pandaccini Bananini"]=1250,["Quackula"]=1200,
	["Pi Pi Watermelon"]=1300,["Signore Carapace"]=1300,["Sigma Boy"]=1350,
	["Chocco Bunny"]=1400,["Puffaball"]=1500,["Sigma Girl"]=1800,
	["Buho de Fuego"]=1800,["Frigo Camelo"]=1900,
	["Orangutini Ananassini"]=2000,["Rhino Toasterino"]=2100,
	["Bombardiro Crocodilo"]=2500,["Spioniro Golubiro"]=3500,
	["Bangangini Gusini"]=5000,["Zibra Zubra Zibralini"]=6000,
	["Tigrilini Watermelini"]=6500,["Avocadorilla"]=7000,
	["Cavallo Virtuoso"]=7500,["Gorillo Subwoofero"]=7700,
	["Gorillo Watermelondrillo"]=8000,["Stoppo Luminino"]=8000,
	["Ganganzelli Trulala"]=9000,["Lerulerulerule"]=8700,
	["Tob Tobi Tobi"]=8500,["Te Te Te Sahur"]=9500,
	["Rhino Helicopterino"]=11000,["Magi Ribbitini"]=11500,
	["Tracoducotulu Delapeladustuz"]=12000,["Jingle Jingle Sahur"]=12200,
	["Los Noobinis"]=12500,["Cachorrito Melonito"]=13000,["Carloo"]=13500,
	["Elefanto Frigo"]=14000,["Carrotini Brainini"]=15000,
	["Centrucci Nuclucci"]=15500,["Jacko Spaventosa"]=16200,
	["Toiletto Focaccino"]=16000,["Bananito Bandito"]=16500,
	["Tree Tree Tree Sahur"]=17000,["Cocofanto Elefanto"]=17500,
	["Antonio"]=18500,["Girafa Celestre"]=20000,
	["Gattatino Neonino"]=35000,["Gattatino Nyanino"]=35000,
	["Chihuanini Taconini"]=45000,["Matteo"]=50000,
	["Tralalero Tralala"]=50000,["Los Crocodillitos"]=55000,
	["Tigroligre Frutonni"]=60000,["Espresso Signora"]=70000,
	["Odin Din Din Dun"]=75000,["Statutino Libertino"]=75000,
	["Tipi Topi Taco"]=75000,["Alessio"]=85000,
	["Tralalita Tralala"]=100000,["Tukanno Bananno"]=100000,
	["Orcalero Orcala"]=100000,["Extinct Ballerina"]=125000,
	["Trenostruzzo Turbo 3000"]=150000,["Urubini Flamenguini"]=150000,
	["Capi Taco"]=155000,["Gattito Tacoto"]=160000,
	["Trippi Troppi Troppa Trippa"]=175000,["Ballerino Lololo"]=200000,
	["Bulbito Bandito Traktorito"]=205000,["Los Tungtungtungcitos"]=210000,
	["Ballerina Peppermintina"]=215000,["Pakrahmatmamat"]=215000,
	["Los Bombinitos"]=220000,["Bombardini Tortinii"]=225000,
	["Piccione Macchina"]=225000,["Brr es Teh Patipum"]=225000,
	["Tractoro Dinosauro"]=230000,["Los Orcalitos"]=235000,
	["Corn Corn Corn Sahur"]=250000,["Squalanana"]=250000,
	["Dug Dug Dug"]=255000,["Yeti Claus"]=257500,["Ginger Globo"]=257500,
	["Los Tipi Tacos"]=260000,["Frio Ninja"]=265000,
	["Ginger Cisterna"]=293500,["Pop Pop Sahur"]=295000,
	["La Vacca Saturno Saturnita"]=300000,["Los Matteos"]=300000,
	["Bisonte Giuppitere"]=300000,["Jackorilla"]=315000,
	["Sammyni Spyderini"]=325000,["Chimpanzini Spiderini"]=325000,
	["Torrtuginni Dragonfrutini"]=350000,["Unclito Samito"]=350000,
	["Dul Dul Dul"]=375000,["Blackhole Goat"]=400000,["Chachechi"]=400000,
	["Guerriro Digitale"]=425000,["Agarrini la Palini"]=425000,
	["Extinct Tralalero"]=450000,["Fragola La La La"]=450000,
	["Los Spyderinis"]=450000,["La Cucaracha"]=475000,["Los Tortus"]=500000,
	["Los Tralaleritos"]=750000,["Extinct Matteo"]=500000,
	["Vulturino Skeletono"]=500000,["Boatito Auratito"]=525000,
	["Karkerkar Kurkur"]=550000,["Orcalita Orcala"]=575000,
	["Piccionetta Macchina"]=600000,["Las Tralaleritas"]=650000,
	["Job Job Job Sahur"]=700000,["Las Vaquitas Saturnitas"]=750000,
	["Los Combinasionas"]=800000,["Trenzostruzzo Turbo 4000"]=850000,
	["La Grande Combinasion"]=10000000,["Graipuss Medussi"]=1000000,
	["Anpali Babel"]=1200000,["Mastodontico Telepiedone"]=1200000,
	["Noo My Hotspot"]=1500000,["La Sahur Combinasion"]=2000000,
	["Nooo My Hotspot"]=2000000,["La Karkerkar Combinasion"]=17500000,
	["Pot Hotspot"]=2500000,["Esok Sekolah"]=3000000,
	["Chicleteira Bicicleteira"]=3500000,["67"]=7500000,
	["Los Nooo My Hotspotsitos"]=5500000,["Nuclearo Dinossauro"]=15000000,
	["Las Sis"]=17500000,["Celularcini Viciosini"]=22500000,
	["Los Bros"]=24000000,["Tralaledon"]=27500000,
	["La Esok Sekolah"]=30000000,["Tang Tang Kelentang"]=33500000,
	["Ketupat Kepat"]=35000000,["Tictac Sahur"]=37500000,
	["La Secret Combinasion"]=125000000,["Ketchuru and Musturu"]=42500000,
	["Garama and Madundung"]=50000000,["Spaghetti Tualetti"]=60000000,
	["Los Orcaleritos"]=235000000,["Dragon Cannelloni"]=200000000,
	["Strawberry Elephant"]=350000000,
}

-- ================================================================
--  MUTATION MULTIPLIERS
-- ================================================================
local MUTATION_MULTIPLIERS = {
	["Gold"]=1.25, ["Diamond"]=1.50, ["Rainbow"]=10.0,
	["Bloodrot"]=2.0, ["Candy"]=4.0, ["Lava"]=6.0,
	["Galaxy"]=7.0, ["Yin-Yang"]=7.5, ["Radioactive"]=8.5, ["Wet"]=1.5,
}

local function getTotalMultiplier(mutList)
	local bonus = 0
	for _, name in ipairs(mutList) do
		bonus = bonus + (MUTATION_MULTIPLIERS[name] or 0)
	end
	return 1 + bonus
end

-- ================================================================
--  REMOTE EVENTS
-- ================================================================
local Remotes = ReplicatedStorage:WaitForChild("RemoteEvents")
local function getOrCreate(name, class)
	local r = Remotes:FindFirstChild(name)
	if not r then
		r = Instance.new(class or "RemoteEvent")
		r.Name   = name
		r.Parent = Remotes
	end
	return r
end

local ConcentratorResult    = getOrCreate("ConcentratorResult")
local ConcentratorBroadcast = getOrCreate("ConcentratorBroadcast")
local ConcentratorInfo      = getOrCreate("ConcentratorInfo", "RemoteFunction")

-- ================================================================
--  DATASTORE
-- ================================================================
local discoveryStore = DataStoreService:GetDataStore(CONFIG.DS_DISCOVERIES)
local discoveryCache = {}

local function recipeKey(mutList)
	local s = table.clone(mutList)
	table.sort(s)
	return table.concat(s, "|")
end

local function checkDiscovery(mutList)
	local key = recipeKey(mutList)
	if discoveryCache[key] then
		return true, discoveryCache[key].discoverer, discoveryCache[key].blendedName
	end
	local ok, data = pcall(discoveryStore.GetAsync, discoveryStore, key)
	if ok and data then
		discoveryCache[key] = data
		return true, data.discoverer, data.blendedName
	end
	return false, nil, nil
end

local function recordDiscovery(mutList, playerName, blendedName)
	local key  = recipeKey(mutList)
	local data = {
		discoverer  = playerName,
		depth       = #mutList,
		blendedName = blendedName,
		timestamp   = os.time(),
	}
	local ok, err = pcall(discoveryStore.SetAsync, discoveryStore, key, data)
	if ok then
		discoveryCache[key] = data
	else
		warn("âŒ DataStore write failed for key " .. key .. ": " .. tostring(err))
	end
	return ok
end

local function calcDiscoveryBonus(depth)
	return math.floor(CONFIG.BASE_DISCOVERY_REWARD * (CONFIG.DEPTH_MULTIPLIER ^ (depth - 1)))
end

-- ================================================================
--  GEMINI â€” blend mutation names into a creative label
-- ================================================================
local GEMINI_URL
local blendCache = {}

local function buildGeminiURL()
	return string.format(
		"https://generativelanguage.googleapis.com/v1beta/models/%s:generateContent?key=%s",
		CONFIG.GEMINI_MODEL,
		CONFIG.GEMINI_API_KEY
	)
end

local function isLazyOutput(output, mutList)
	local lower = output:lower()
	local matchCount = 0
	for _, m in ipairs(mutList) do
		for word in m:gmatch("%a+") do
			if #word > 3 then
				if lower:match("%f[%a]" .. word:lower() .. "%f[%A]") then
					matchCount += 1
					break
				end
			end
		end
	end
	local threshold = math.floor(#mutList / 2)
	return matchCount > threshold
end

local function callGemini(basePrompt, rejectedAnswer)
	GEMINI_URL = GEMINI_URL or buildGeminiURL()
	local fullPrompt = basePrompt
	if rejectedAnswer then
		fullPrompt = basePrompt
			.. "\n\nâš ï¸ Your previous answer was REJECTED because it contained one or more of the input words verbatim."
			.. "\nRejected answer: \"" .. rejectedAnswer .. "\""
			.. "\nYou MUST produce something completely different that shares NO words with the inputs."
	end
	local payload = HttpService:JSONEncode({
		systemInstruction = {
			parts = { {
				text = "You are a creative mutation name generator for a silly Italian meme game. "
					.. "Output ONLY the invented name â€” no explanation, no punctuation at the end, nothing else. "
					.. "Never use the input words or their direct translations in any language."
			} }
		},
		contents = { { parts = { { text = fullPrompt } } } },
		generationConfig = { maxOutputTokens = 30, temperature = 1.1 },
	})
	local httpOk, raw = pcall(
		HttpService.PostAsync, HttpService,
		GEMINI_URL, payload, Enum.HttpContentType.ApplicationJson, false
	)
	if not httpOk then
		warn("âš ï¸ Gemini HTTP error: " .. tostring(raw))
		return nil
	end
	print("   [Gemini RAW] " .. tostring(raw):sub(1, 500))
	local parseOk, parsed = pcall(HttpService.JSONDecode, HttpService, raw)
	if not parseOk or not parsed then
		warn("âš ï¸ Gemini JSON parse failed")
		return nil
	end
	if parsed.error then
		warn(string.format("âš ï¸ Gemini API error %s: %s",
			tostring(parsed.error.code), tostring(parsed.error.message)))
		return nil
	end
	local cand = parsed.candidates and parsed.candidates[1]
	if not cand then
		warn("âš ï¸ Gemini returned no candidates")
		if parsed.promptFeedback then
			warn("   promptFeedback: " .. HttpService:JSONEncode(parsed.promptFeedback))
		end
		return nil
	end
	if cand.finishReason and cand.finishReason ~= "STOP" then
		warn("âš ï¸ Gemini finishReason: " .. tostring(cand.finishReason))
	end
	local part = cand.content and cand.content.parts and cand.content.parts[1]
	if not part then return nil end
	local text = (part.text or ""):gsub("[\n\r]", ""):match("^%s*(.-)%s*$")
	if not text or text == "" then return nil end
	return text
end

local function blendMutationNames(mutList)
	local key = recipeKey(mutList)
	if blendCache[key] then return blendCache[key] end
	if #mutList == 1 then
		blendCache[key] = mutList[1]
		return mutList[1]
	end
	local listed = table.concat(mutList, " + ")
	local prompt = string.format(
		[[Fuse these mutation concepts into ONE invented name: %s Rules: - 1 to 4 words. Italian or Latin phonetics are encouraged where natural. - Must feel like a brand-new standalone mutation name â€” evocative, not a description. - You are completely banned from using any input words or their direct translations. Good fusion examples: "Lava" + "Radioactive" â†’ "Toxic Inferno" "Gold" + "Rainbow" â†’ "Gilded Prism" "Galaxy" + "Wet" â†’ "Nebula Tide" "Bloodrot" + "Candy" + "Lava" â†’ "Sugared Hellfire" "Diamond" + "Yin-Yang" â†’ "Crystallo Equilibrio"]],
		listed
	)
	local MAX_ATTEMPTS = 3
	local result, lastBad = nil, nil
	for attempt = 1, MAX_ATTEMPTS do
		local output = callGemini(prompt, attempt > 1 and lastBad or nil)
		if output then
			if isLazyOutput(output, mutList) then
				lastBad = output
				task.wait(0.5)
			else
				result = output
				print(string.format("âœ¨ Gemini blended [%s] â†’ '%s'", listed, result))
				break
			end
		else
			task.wait(0.5)
		end
	end
	if not result then
		local depthLabel = ({[2]="Duplice",[3]="Triplice",[4]="Quadruplice",[5]="Quintuplice"})[#mutList] or "Multiplo"
		result = depthLabel .. " Fusione"
	end
	blendCache[key] = result
	return result
end

-- ================================================================
--  MUTATION ATTRIBUTE HELPERS
-- ================================================================
-- ================================================================
--  MUTATION ATTRIBUTE HELPERS
-- ================================================================
local function getMutations(tool)
	-- Grab either the stacked array or the base string
	local raw = tool:GetAttribute("Mutations") or tool:GetAttribute("Mutation") or ""

	local list = {}
	-- Split by commas and remove extra spaces
	for m in raw:gmatch("[^,]+") do
		local clean = m:match("^%s*(.-)%s*$")
		if clean ~= "" then 
			table.insert(list, clean) 
		end
	end
	return list
end

local function saveMutations(tool, mutList)
	tool:SetAttribute("Mutations", table.concat(mutList, ", "))
end

-- ================================================================
--  VISUAL HELPERS
-- ================================================================
local ANIM_PRIORITY = {
	"Rainbow","Radioactive","Galaxy","Yin-Yang",
	"Lava","Candy","Wet","Bloodrot","Diamond","Gold",
}
local STATIC_VISUAL = {
	["Gold"]     = { col = Color3.fromRGB(255,215,0),   mat = Enum.Material.SmoothPlastic, ref = nil },
	["Diamond"]  = { col = Color3.fromRGB(185,242,255), mat = Enum.Material.SmoothPlastic, ref = 0.3 },
	["Bloodrot"] = { col = Color3.fromRGB(100,0,0),     mat = Enum.Material.SmoothPlastic, ref = nil },
	["Candy"]    = { col = Color3.fromRGB(255,105,180), mat = Enum.Material.SmoothPlastic, ref = 0.1 },
	["Lava"]     = { col = Color3.fromRGB(255,80,0),    mat = Enum.Material.Neon,          ref = nil },
	["Wet"]      = { col = Color3.fromRGB(84,130,255),  mat = Enum.Material.Neon,          ref = nil },
}
local LABEL_COLORS = {
	["Gold"]        = Color3.fromRGB(255,215,0),
	["Diamond"]     = Color3.fromRGB(185,242,255),
	["Bloodrot"]    = Color3.fromRGB(100,0,0),
	["Candy"]       = Color3.fromRGB(255,105,180),
	["Lava"]        = Color3.fromRGB(255,80,0),
	["Galaxy"]      = Color3.fromRGB(138,43,226),
	["Radioactive"] = Color3.fromRGB(0,255,50),
	["Wet"]         = Color3.fromRGB(84,130,255),
}

local function inList(val, list)
	for _, v in ipairs(list) do if v == val then return true end end
	return false
end

local function stripAppearances(model)
	for _, d in pairs(model:GetDescendants()) do
		if d:IsA("BasePart") or d:IsA("MeshPart") then
			local sa = d:FindFirstChildOfClass("SurfaceAppearance")
			if sa then sa:Destroy() end
		elseif d:IsA("SpecialMesh") then
			d.TextureId = ""
		end
	end
end

local function applyStackedVisuals(model, mutList)
	stripAppearances(model)
	local parts = {}
	for _, d in pairs(model:GetDescendants()) do
		if d:IsA("BasePart") then parts[#parts + 1] = d end
	end
	local chosen = nil
	for _, anim in ipairs(ANIM_PRIORITY) do
		if inList(anim, mutList) then chosen = anim; break end
	end
	if chosen == "Rainbow" then
		task.spawn(function()
			local hue = 0
			while model and model.Parent do
				hue = (hue + 0.01) % 1
				local c = Color3.fromHSV(hue, 1, 1)
				for _, p in ipairs(parts) do if p and p.Parent then p.Color = c end end
				task.wait(0.05)
			end
		end)
	elseif chosen == "Radioactive" then
		task.spawn(function()
			local t = 0
			while model and model.Parent do
				t += 0.08
				local g = math.floor(150 + 105 * (0.5 + 0.5 * math.sin(t)))
				local c = Color3.fromRGB(0, g, 0)
				for _, p in ipairs(parts) do
					if p and p.Parent then p.Color = c; p.Material = Enum.Material.Neon end
				end
				task.wait(0.05)
			end
		end)
	elseif chosen == "Galaxy" then
		task.spawn(function()
			local t = 0
			while model and model.Parent do
				t += 0.02
				local b = 0.5 + 0.5 * math.sin(t)
				local c = Color3.fromRGB(math.floor(75 + 63 * b), 0, math.floor(130 + 100 * b))
				for _, p in ipairs(parts) do
					if p and p.Parent then p.Color = c; p.Material = Enum.Material.Neon end
				end
				task.wait(0.05)
			end
		end)
	elseif chosen == "Yin-Yang" then
		task.spawn(function()
			local flip = false
			while model and model.Parent do
				flip = not flip
				local c = flip and Color3.new(1,1,1) or Color3.new(0,0,0)
				for _, p in ipairs(parts) do if p and p.Parent then p.Color = c end end
				task.wait(0.5)
			end
		end)
	else
		local v = chosen and STATIC_VISUAL[chosen]
		if v then
			for _, p in ipairs(parts) do
				if p and p.Parent then
					p.Color    = v.col
					p.Material = v.mat
					if v.ref then p.Reflectance = v.ref end
				end
			end
		end
	end
end

-- ================================================================
--  BILLBOARD UPDATE
-- ================================================================
local function animateRainbowLabel(lbl)
	task.spawn(function()
		local hue = 0
		while lbl and lbl.Parent do
			hue = (hue + 0.01) % 1
			lbl.TextColor3 = Color3.fromHSV(hue, 1, 1)
			task.wait(0.05)
		end
	end)
end

local function updateMutationBillboard(brainrotModel, blendedLabel, mutList)
	local statsGUI = brainrotModel:FindFirstChild("StatsGUI")
	if not statsGUI then return end
	local old = statsGUI:FindFirstChild("MutationLabel")
	if old then old:Destroy() end
	local labelColor = Color3.new(1,1,1)
	local doRainbow, doYinYang = false, false
	for _, anim in ipairs(ANIM_PRIORITY) do
		if inList(anim, mutList) then
			if   anim == "Rainbow"  then doRainbow = true
			elseif anim == "Yin-Yang" then doYinYang = true
			else
				local c = LABEL_COLORS[anim]
				if c then labelColor = c end
			end
			break
		end
	end
	local lbl = Instance.new("TextLabel")
	lbl.Name                   = "MutationLabel"
	lbl.Size                   = UDim2.new(1, 0, 0.2, 0)
	lbl.BackgroundTransparency = 1
	lbl.Font                   = Enum.Font.SourceSansBold
	lbl.TextScaled             = true
	lbl.Text                   = "â­ " .. blendedLabel .. " â­"
	lbl.TextColor3             = labelColor
	lbl.TextStrokeColor3       = Color3.new(0,0,0)
	lbl.TextStrokeTransparency = 0
	lbl.LayoutOrder            = 2
	local c = Instance.new("UITextSizeConstraint")
	c.MaxTextSize = 35
	c.MinTextSize = 2
	c.Parent      = lbl
	lbl.Parent = statsGUI
	if doRainbow then
		animateRainbowLabel(lbl)
	elseif doYinYang then
		task.spawn(function()
			local flip = false
			while lbl and lbl.Parent do
				flip = not flip
				lbl.TextColor3 = flip and Color3.new(1,1,1) or Color3.new(0,0,0)
				task.wait(0.5)
			end
		end)
	end
end

-- ================================================================
--  CONCENTRATOR MODEL
-- ================================================================
local concentratorModel = workspace:FindFirstChild(CONFIG.CONCENTRATOR_MODEL_NAME, true)
if not concentratorModel then
	warn("âš ï¸ WeatherConcentrator model not found in Workspace! System inactive.")
	return
end
print("âœ“ Found concentrator model: " .. concentratorModel:GetFullName())

local pedestal = concentratorModel.PrimaryPart
if not pedestal then
	pedestal = concentratorModel:FindFirstChildWhichIsA("BasePart", true)
	if pedestal then
		warn("âš ï¸ No PrimaryPart set â€” falling back to '" .. pedestal.Name .. "'")
	else
		warn("âš ï¸ WeatherConcentrator has no BasePart at all! System inactive.")
		return
	end
end
print("âœ“ Using pedestal part: " .. pedestal:GetFullName())

-- The two placement anchors â€” must be Parts named "Left" and "Right"
-- that are direct children of concentratorModel.
local leftAnchor  = pedestal:WaitForChild("left",  10)
local rightAnchor = pedestal:WaitForChild("right", 10)
if not leftAnchor  then warn("âš ï¸ No 'Left'  part found in WeatherConcentrator!") end
if not rightAnchor then warn("âš ï¸ No 'Right' part found in WeatherConcentrator!") end

local pedesLight = pedestal:FindFirstChildOfClass("PointLight")
if not pedesLight then
	pedesLight = Instance.new("PointLight")
	pedesLight.Brightness = 5
	pedesLight.Range      = 20
	pedesLight.Parent     = pedestal
	
end
pedesLight.Enabled = false
local function refreshConcentratorGlow()
	local data = WeatherSystem.WEATHER_TYPES[WeatherSystem.getCurrentWeather()]
	local col  = (data and data.color) or Color3.fromRGB(200, 200, 255)
	TweenService:Create(pedesLight, TweenInfo.new(1.5), { Color = col }):Play()
	TweenService:Create(pedestal,   TweenInfo.new(1.5), { Color = col }):Play()
end
refreshConcentratorGlow()

task.spawn(function()
	while pedestal and pedestal.Parent do
		TweenService:Create(pedesLight,
			TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
			{ Brightness = 1.5 }):Play()
		task.wait(1)
		TweenService:Create(pedesLight,
			TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
			{ Brightness = 0.8 }):Play()
		task.wait(1)
	end
end)

-- ================================================================
--  BRAINROT PACK REFERENCE
-- ================================================================
local brainrotPack = ReplicatedStorage:FindFirstChild("Brainrot pack1")

local function isValidBrainrot(tool)
	if not brainrotPack then return false end
	for _, item in pairs(brainrotPack:GetChildren()) do
		if item.Name == tool.Name then return true end
	end
	return false
end

-- ================================================================
--  SLOT STATE
--
--  Each slot holds:  { tool = Tool, player = Player }
--  or nil when empty.
-- ================================================================
local slots = {
	left  = nil,   -- { tool, player }
	right = nil,   -- { tool, player }
}

-- Keep a lock so two simultaneous triggers can't race into the same slot.
local slotLock = false

-- ================================================================
--  SLOT HELPERS
-- ================================================================

-- Smoothly move a tool's Handle (or PrimaryPart) to an anchor's CFrame.
local function pivotToolToAnchor(tool, anchor)
	-- Unequip from character and park in Workspace so it becomes a free model.
	tool.Parent = workspace

	local handle = tool:FindFirstChild("Handle") or tool.PrimaryPart
	if handle then
		-- Use PivotTo when the tool has a PrimaryPart, otherwise just set CFrame.
		if tool.PrimaryPart then
			tool:PivotTo(anchor.CFrame)
		else
			handle.CFrame = anchor.CFrame
		end
	else
		-- Fallback: move every BasePart to the anchor position.
		for _, part in ipairs(tool:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CFrame = anchor.CFrame
				break   -- only move the first one so the model stays intact
			end
		end
	end
end

-- Return the tool sitting in a slot to its owner's backpack (cancels placement).
local function returnToolToPlayer(slotData)
	if not slotData then return end
	local tool   = slotData.tool
	local player = slotData.player
	if tool and tool.Parent and player and player.Parent then
		local bp = player:FindFirstChildOfClass("Backpack")
		if bp then
			tool.Parent = bp
		end
	end
end

-- Clear both slots and optionally refund tools.
local function clearSlots(refund)
	if refund then
		returnToolToPlayer(slots.left)
		returnToolToPlayer(slots.right)
	end
	slots.left  = nil
	slots.right = nil
end

-- ================================================================
--  PLAYER COOLDOWN
-- ================================================================
local cooldownMap = {}
local function isOnCooldown(player)
	local last = cooldownMap[player.UserId] or 0
	return (tick() - last) < CONFIG.PLAYER_COOLDOWN
end
local function getCooldownRemaining(player)
	local last = cooldownMap[player.UserId] or 0
	return math.max(0, math.ceil(CONFIG.PLAYER_COOLDOWN - (tick() - last)))
end

-- ================================================================
--  FUSION  (called once both slots are filled)
-- ================================================================
local function executeFusion()
	local leftData  = slots.left
	local rightData = slots.right

	-- Immediately clear the state so new placements can begin.
	slots.left  = nil
	slots.right = nil

	local toolA   = leftData.tool
	local toolB   = rightData.tool

	-- 50 / 50: which tool survives, which is consumed?
	local survivor, consumed
	if math.random() < 0.5 then
		survivor = toolA;  consumed = toolB
		print("ðŸŽ² Fusion: LEFT survives, RIGHT consumed")
	else
		survivor = toolB;  consumed = toolA
		print("ðŸŽ² Fusion: RIGHT survives, LEFT consumed")
	end

	-- Collect mutations from both tools, merge into survivor.
	local mutA = getMutations(toolA)
	local mutB = getMutations(toolB)

	-- Stack mutations: start from survivor's list, then add unique ones from consumed.
	local baseMuts = (survivor == toolA) and mutA or mutB
	local addMuts  = (survivor == toolA) and mutB or mutA

	local mergedMuts = table.clone(baseMuts)
	for _, m in ipairs(addMuts) do
		local dup = false
		for _, existing in ipairs(mergedMuts) do
			if existing == m then dup = true; break end
		end
		if not dup then
			table.insert(mergedMuts, m)
		end
	end

	-- Destroy the consumed tool now.
	consumed:Destroy()

	-- Async: Gemini naming + DataStore + give survivor back.
	task.spawn(function()
		local alreadyFound, _, storedName = checkDiscovery(mergedMuts)
		local blendedLabel
		if alreadyFound and storedName and storedName ~= "" then
			blendedLabel = storedName
			blendCache[recipeKey(mergedMuts)] = storedName
		else
			blendedLabel = blendMutationNames(mergedMuts)
		end

		saveMutations(survivor, mergedMuts)
		survivor:SetAttribute("Mutation",     blendedLabel)
		survivor:SetAttribute("MutationMult", getTotalMultiplier(mergedMuts))

		applyStackedVisuals(survivor, mergedMuts)
		updateMutationBillboard(survivor, blendedLabel, mergedMuts)

		-- Determine which player gets the survivor back.
		-- If the survivor's original owner is still in game, give it to them.
		-- Otherwise give it to the other player.
		local survivorOwner  = (survivor == toolA) and leftData.player  or rightData.player
		local consumedPlayer = (survivor == toolA) and rightData.player or leftData.player

		local function returnTo(player)
			if player and player.Parent then
				local bp = player:FindFirstChildOfClass("Backpack")
				if bp then survivor.Parent = bp end
			end
		end

		-- Discovery bonus
		local discoveryBonus = nil
		if not alreadyFound then
			local depth = #mergedMuts
			discoveryBonus = calcDiscoveryBonus(depth)
			recordDiscovery(mergedMuts, survivorOwner.Name, blendedLabel)

			-- Give the bonus to whoever owns the survivor.
			local ls = survivorOwner:FindFirstChild("leaderstats")
			local money =
				(ls and ls.Parent:FindFirstChild("MoneyRaw")) or
				(ls and ls:FindFirstChild("Cash")) or
				(ls and ls:FindFirstChild("Coins"))
			if money then money.Value += discoveryBonus end

			ConcentratorBroadcast:FireAllClients(
				survivorOwner.Name, blendedLabel,
				survivor.Name, discoveryBonus, depth
			)
			print(string.format("ðŸ† FIRST DISCOVERY: '%s' by %s  depth=%d  bonus=$%d",
				blendedLabel, survivorOwner.Name, depth, discoveryBonus))
		end

		returnTo(survivorOwner)

		local totalMult = getTotalMultiplier(mergedMuts)
		local msg
		if discoveryBonus then
			msg = string.format("ðŸŒŸ FIRST DISCOVERY! '%s' fused â€” $%d bonus!",
				blendedLabel, discoveryBonus)
		else
			msg = string.format("âœ¨ Fusion complete! '%s'  (%.2fx income)",
				blendedLabel, totalMult)
		end

		-- Notify both players.
		ConcentratorResult:FireClient(survivorOwner, true, msg, discoveryBonus)
		if consumedPlayer ~= survivorOwner then
			ConcentratorResult:FireClient(consumedPlayer, true,
				"ðŸ’¨ Your brainrot was consumed in the fusion!", nil)
		end

		-- Flash pedestal.
		task.spawn(function()
			for _ = 1, 5 do
				TweenService:Create(pedesLight, TweenInfo.new(0.1), { Brightness = 1.5 }):Play()
				task.wait(0.15)
				TweenService:Create(pedesLight, TweenInfo.new(0.1), { Brightness = 0.8 }):Play()
				task.wait(0.15)
			end
		end)

		print(string.format("âš¡ FUSION | %s + %s â†’ %s | mult: %.2fx | depth: %d",
			toolA.Name, toolB.Name,
			table.concat(mergedMuts, "+"), totalMult, #mergedMuts))
	end)
end

-- ================================================================
--  MAIN TRIGGER â€” places brainrot into the next open slot
-- ================================================================
-- ================================================================
--  MAIN CRAFT FUNCTION (PHASE 1: PLACEMENT FIX)
-- ================================================================

-- ================================================================
--  MAIN CRAFT FUNCTION (PHASE 2: 50/50 DELETION)
-- ================================================================

-- ================================================================
--  PHASE 1: PLACEMENT & PICKUP LOGIC (LEFT & RIGHT SLOTS)
-- ================================================================

local placedBrainrots = { left = nil, right = nil }

local leftSpot = pedestal:FindFirstChild("left")
local rightSpot = pedestal:FindFirstChild("right")
local mainPrompt = pedestal:FindFirstChildWhichIsA("ProximityPrompt")

if not leftSpot or not rightSpot then
	warn("âš ï¸ Pedestal is missing 'left' or 'right' parts!")
end

-- Helper: Check if main prompt should be enabled
local function updateMainPrompt()
	if not mainPrompt then return end

	if placedBrainrots.left and placedBrainrots.right then
		mainPrompt.Enabled = false
		mainPrompt.ActionText = "Concentrate Mutations"
		mainPrompt.Enabled = true
	else
		mainPrompt.Enabled = false -- Hide it until both slots are full
	end
end

-- Setup default text for left/right slots
for _, spot in pairs({leftSpot, rightSpot}) do
	if spot then
		local slotPrompt = spot:FindFirstChildWhichIsA("ProximityPrompt")
		if not slotPrompt then
			slotPrompt = Instance.new("ProximityPrompt")
			slotPrompt.Parent = spot
		end
		slotPrompt.ActionText = "Place Brainrot"
		slotPrompt.MaxActivationDistance = 8
	end
end
updateMainPrompt() -- Hide main prompt initially

local function handleSlotInteraction(player, sideStr, spotPart)
	local prompt = spotPart:FindFirstChildWhichIsA("ProximityPrompt")
	local currentTool = placedBrainrots[sideStr]

	if currentTool then
		-- ==========================================
		-- PICK UP LOGIC
		-- ==========================================
		-- >>> NEW: SWAP LOGIC (CAPACITY EXPLOIT FIX) <<<
		local currentCount = 0
		local eq = player.Character and player.Character:FindFirstChildOfClass("Tool")
		if player:FindFirstChild("Backpack") then
			for _, t in pairs(player.Backpack:GetChildren()) do
				if t:IsA("Tool") and t:GetAttribute("Rarity") then currentCount = currentCount + 1 end
			end
		end
		if eq and eq:GetAttribute("Rarity") then currentCount = currentCount + 1 end

		local maxCap = player:GetAttribute("BrainrotCapacity") or 1
		if currentCount >= maxCap then
			-- Check if they are holding a valid brainrot to swap
			if eq and ReplicatedStorage:FindFirstChild("Brainrot pack1") and ReplicatedStorage["Brainrot pack1"]:FindFirstChild(eq.Name) then
				-- 1. Unfreeze pedestal tool and put in backpack
				for _, part in pairs(currentTool:GetDescendants()) do
					if part:IsA("BasePart") then part.Anchored = false; part.CanCollide = false end
				end
				currentTool.Parent = player:FindFirstChild("Backpack") or player.Character

				-- 2. Freeze equipped tool and put on pedestal
				eq.Parent = concentratorModel
				for _, part in pairs(eq:GetDescendants()) do
					if part:IsA("BasePart") then part.Anchored = true; part.CanCollide = false end
				end
				local targetCFrame = spotPart:IsA("Attachment") and spotPart.WorldCFrame or spotPart.CFrame
				eq:PivotTo(targetCFrame)
				placedBrainrots[sideStr] = eq

				ConcentratorResult:FireClient(player, true, "Swapped " .. eq.Name .. "!", nil)
				return -- Exit! Swap is complete.
			else
				ConcentratorResult:FireClient(player, false, "ðŸŽ’ Inventory Full! Equip a Brainrot to swap.", nil)
				return
			end
		end
		-- >>> END OF SWAP LOGIC <<<
		-- 1. Unfreeze tool
		for _, part in pairs(currentTool:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Anchored = false
				part.CanCollide = false
			end
		end

		-- 2. Give back to player (Backpack is safer than Character)
		currentTool.Parent = player:FindFirstChild("Backpack") or player.Character
		placedBrainrots[sideStr] = nil

		-- 3. Update Text
		if prompt then
			prompt.Enabled = false
			prompt.ActionText = "Place Brainrot"
			prompt.Enabled = true
		end

		ConcentratorResult:FireClient(player, true, "Picked up " .. currentTool.Name, nil)

	else
		-- ==========================================
		-- PLACE LOGIC
		-- ==========================================
		local character = player.Character
		if not character then return end

		local tool = character:FindFirstChildOfClass("Tool")
		local pack = ReplicatedStorage:FindFirstChild("Brainrot pack1")

		if not tool or not pack then
			ConcentratorResult:FireClient(player, false, "ðŸŽ’ Equip a Brainrot in your hand first!", nil)
			return
		end

		-- Verify it's a valid brainrot
		local validBrainrot = false
		for _, item in pairs(pack:GetChildren()) do
			if item.Name == tool.Name then validBrainrot = true; break end
		end

		if not validBrainrot then
			ConcentratorResult:FireClient(player, false, "ðŸŽ’ Equip a valid Brainrot!", nil)
			return
		end

		-- 1. Freeze tool
		tool.Parent = concentratorModel
		for _, part in pairs(tool:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Anchored = true
				part.CanCollide = false
			end
		end

		-- 2. Position tool
		local targetCFrame = spotPart:IsA("Attachment") and spotPart.WorldCFrame or spotPart.CFrame
		tool:PivotTo(targetCFrame)

		placedBrainrots[sideStr] = tool

		-- 3. Update Text
		if prompt then
			prompt.Enabled = false
			prompt.ActionText = "Pick up Brainrot"
			prompt.Enabled = true
		end

		ConcentratorResult:FireClient(player, true, "Placed " .. tool.Name .. "!", nil)
	end

	-- Check if we should turn on the main Concentrate button
	updateMainPrompt()
end

-- Connect the Left and Right prompts
if leftSpot then
	leftSpot:FindFirstChildWhichIsA("ProximityPrompt").Triggered:Connect(function(player)
		handleSlotInteraction(player, "left", leftSpot)
	end)
end

if rightSpot then
	rightSpot:FindFirstChildWhichIsA("ProximityPrompt").Triggered:Connect(function(player)
		handleSlotInteraction(player, "right", rightSpot)
	end)
end

-- ================================================================
--  PHASE 2: FUSION LOGIC (THE MAIN PEDESTAL PROMPT)
-- ================================================================

-- ================================================================
--  PHASE 2: FUSION LOGIC (THE MAIN PEDESTAL PROMPT)
-- ================================================================

local function tryConcentrate(player)
	-- Double check both slots are full just in case
	local brainrot1 = placedBrainrots.left
	local brainrot2 = placedBrainrots.right

	if not brainrot1 or not brainrot2 then return end

	-- VERIFY: Check if both tools are still physically on the pedestal
	if brainrot1.Parent == concentratorModel and brainrot2.Parent == concentratorModel then

		ConcentratorResult:FireClient(player, true, "Beginning concentration...", nil)

		-- =========================================================
		-- ðŸ” DEBUG 1: WHAT DO THEY HAVE RIGHT WHEN BUTTON IS PRESSED?
		-- =========================================================
		print("\n=======================================================")
		print("ðŸ” [DEBUG 1] FUSION INITIATED!")
		print("ðŸ§  Brainrot1 (Left):", brainrot1.Name)
		print("   -> Attribute 'Mutations' (Stack):", tostring(brainrot1:GetAttribute("Mutations")))
		print("   -> Attribute 'Mutation' (Base):", tostring(brainrot1:GetAttribute("Mutation")))
		print("ðŸ§  Brainrot2 (Right):", brainrot2.Name)
		print("   -> Attribute 'Mutations' (Stack):", tostring(brainrot2:GetAttribute("Mutations")))
		print("   -> Attribute 'Mutation' (Base):", tostring(brainrot2:GetAttribute("Mutation")))

		-- Secure mutations early
		local muts1 = getMutations(brainrot1)
		local muts2 = getMutations(brainrot2)

		print("ðŸ” [DEBUG 2] AFTER PARSING getMutations():")
		print("   -> muts1 count:", #muts1, " | contents: [" .. table.concat(muts1, ", ") .. "]")
		print("   -> muts2 count:", #muts2, " | contents: [" .. table.concat(muts2, ", ") .. "]")
		print("=======================================================\n")

		-- ==========================================
		-- 1. START HUM & EFFECTS (3 Seconds)
		-- ==========================================
		local activeHum = hum:Clone()
		activeHum.Parent = pedestal
		activeHum.Volume = 0.5 
		activeHum:Play()

		TweenService:Create(activeHum, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Volume = 10}):Play()

		local glow, emitter, platformLight
		if concentratorModel:FindFirstChild("effectspart") then
			glow = concentratorModel.effectspart:FindFirstChild("Glow")
			emitter = concentratorModel.effectspart:FindFirstChild("ParticleEmitter")
			if glow then glow.Enabled = true end
			if emitter then emitter.Enabled = true end
		end

		if concentratorModel:FindFirstChild("Platform") and concentratorModel.Platform:FindFirstChild("PointLight") then
			platformLight = concentratorModel.Platform.PointLight
			platformLight.Enabled = true
			TweenService:Create(platformLight, TweenInfo.new(1.5), {Brightness = 5}):Play()
		end

		task.wait(3)

		-- ==========================================
		-- 2. START FLASH SOUND & STOP HUM
		-- ==========================================
		activeHum:Stop()
		activeHum:Destroy()

		local activeFlash = flash:Clone()
		activeFlash.Parent = pedestal
		activeFlash.Volume = 5
		activeFlash:Play()

		if platformLight then
			platformLight.Brightness = 50 
			platformLight.Range = 40      
		end

		-- 50/50 Chance Roll
		local rng = math.random(1, 100)
		local victim, survivor
		local victimSide, survivorSide

		if rng <= 50 then
			victim = brainrot1
			survivor = brainrot2
			victimSide = "left"
			survivorSide = "right"
		else
			victim = brainrot2
			survivor = brainrot1
			victimSide = "right"
			survivorSide = "left"
		end

		-- =========================================================
		-- ðŸ” DEBUG 3: COMBINING THE TABLES
		-- =========================================================
		print("\n=======================================================")
		print("ðŸ” [DEBUG 3] SURVIVOR SELECTED:", survivor.Name)

		local survivorMutations = (survivor == brainrot1) and muts1 or muts2
		local victimMutations   = (survivor == brainrot1) and muts2 or muts1

		print("   -> Survivor Base Muts: [" .. table.concat(survivorMutations, ", ") .. "]")
		print("   -> Victim Muts to Add: [" .. table.concat(victimMutations, ", ") .. "]")

		local finalMutations = table.clone(survivorMutations)
		for _, mut in ipairs(victimMutations) do
			local isDup = false
			for _, existing in ipairs(finalMutations) do
				if existing == mut then isDup = true; break end
			end
			if not isDup then
				table.insert(finalMutations, mut)
				print("   -> âž• Successfully added:", mut)
			else
				print("   -> â­ï¸ Skipped duplicate:", mut)
			end
		end

		print("ðŸ” [DEBUG 4] FINAL MUTATION LIST:")
		print("   -> Total Count:", #finalMutations)
		print("   -> Contents: [" .. table.concat(finalMutations, ", ") .. "]")
		print("=======================================================\n")

		-- Save the new massive table back to the survivor tool
		saveMutations(survivor, finalMutations)

		local newMultiplier = getTotalMultiplier(finalMutations)
		survivor:SetAttribute("MutationMult", newMultiplier)

		-- Update the Visuals WHILE HIDDEN IN THE FLASH
		applyStackedVisuals(survivor, finalMutations)

		local tempLabel = #finalMutations > 0 and table.concat(finalMutations, " + ") or "Upgraded!"
		survivor:SetAttribute("Mutation", tempLabel)
		updateMutationBillboard(survivor, tempLabel, finalMutations)

		-- CLEAN UP & COOLDOWN EFFECTS
		victim:Destroy()

		placedBrainrots[victimSide] = nil
		local emptySpot = (victimSide == "left") and leftSpot or rightSpot
		local emptyPrompt = emptySpot:FindFirstChildWhichIsA("ProximityPrompt")
		if emptyPrompt then
			emptyPrompt.Enabled = false
			emptyPrompt.ActionText = "Place Brainrot"
			emptyPrompt.Enabled = true
		end

		ConcentratorResult:FireClient(player, true, survivor.Name .. " survived! New Multiplier: " .. newMultiplier .. "x", nil)
		updateMainPrompt()

		-- 3. LET FLASH DIE DOWN & TURN OFF EFFECTS
		task.wait(0.5)

		local fadeDuration = 1.5
		TweenService:Create(activeFlash, TweenInfo.new(fadeDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Volume = 0}):Play()

		if platformLight then
			local fadeOut = TweenService:Create(platformLight, TweenInfo.new(fadeDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Brightness = 0, Range = 20})
			fadeOut:Play()

			fadeOut.Completed:Connect(function()
				platformLight.Enabled = false
			end)
		end

		task.wait(fadeDuration)
		activeFlash:Destroy()

		if glow then glow.Enabled = false end
		if emitter then emitter.Enabled = false end
		if emitter then emitter.Enabled = false end

	else
		warn("âš ï¸ A Brainrot went missing before fusion! Resetting pedestal.")
	end
end

-- Connect the Main Pedestal prompt
if mainPrompt then
	mainPrompt.Triggered:Connect(function(player)
		tryConcentrate(player)
	end)
end

-- ================================================================
--  REMOTE FUNCTION  â€” client cost preview (kept for UI compatibility)
-- ================================================================
ConcentratorInfo.OnServerInvoke = function(player)
	local char   = player.Character
	local tool   = char and char:FindFirstChildOfClass("Tool")
	local mutList = tool and getMutations(tool) or {}
	return {
		activeMutation = nil,
		weatherDisplay = "N/A",
		currentDepth   = #mutList,
		leftFilled     = placedBrainrots.left  ~= nil,
		rightFilled    = placedBrainrots.right ~= nil,
	}
end

-- ================================================================
--  WEATHER CHANGE WATCHER  (keeps pedestal colour in sync)
-- ================================================================
task.spawn(function()
	local last = WeatherSystem.getCurrentWeather()
	while true do
		task.wait(2)
		local cur = WeatherSystem.getCurrentWeather()
		if cur ~= last then
			last = cur
			refreshConcentratorGlow()
		end
	end
end)

-- ================================================================
--  CLEANUP
-- ================================================================
Players.PlayerRemoving:Connect(function(p)
	cooldownMap[p.UserId] = nil

	-- If a player leaves, check if they own the tool on the left pedestal
	if placedBrainrots.left then
		-- In a real game, you might want to save this to their DataStore,
		-- but for now, we destroy it to prevent it from getting stuck forever.
		placedBrainrots.left:Destroy()
		placedBrainrots.left = nil
		if leftSpot and leftSpot:FindFirstChildWhichIsA("ProximityPrompt") then
			leftSpot:FindFirstChildWhichIsA("ProximityPrompt").ActionText = "Place Brainrot"
		end
	end

	-- Do the same for the right pedestal
	if placedBrainrots.right then
		placedBrainrots.right:Destroy()
		placedBrainrots.right = nil
		if rightSpot and rightSpot:FindFirstChildWhichIsA("ProximityPrompt") then
			rightSpot:FindFirstChildWhichIsA("ProximityPrompt").ActionText = "Place Brainrot"
		end
	end

	updateMainPrompt()
end)

print("âœ… WeatherConcentratorSystem loaded!")
print("   Concentrator: " .. concentratorModel:GetFullName())
print("   Left anchor:  " .. (leftSpot  and leftSpot:GetFullName()  or "MISSING"))
print("   Right anchor: " .. (rightSpot and rightSpot:GetFullName() or "MISSING"))
e|S|FlyServer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local flyEvent = ReplicatedStorage:FindFirstChild("AdminFlyEvent") or Instance.new("RemoteEvent", ReplicatedStorage)
flyEvent.Name = "AdminFlyEvent"

local playersWithPerms = {}

flyEvent.OnServerEvent:Connect(function(admin, targetName)
	for _, p in pairs(game.Players:GetPlayers()) do
		if string.sub(p.Name:lower(), 1, #targetName) == targetName:lower() then

			if playersWithPerms[p.UserId] then
				-- PLAYER ALREADY HAS PERMS: Remove them
				playersWithPerms[p.UserId] = nil
				flyEvent:FireClient(p, false) -- Send 'false' to disable
				print("ðŸš« SERVER: Removed fly perms from " .. p.Name)
			else
				-- PLAYER DOES NOT HAVE PERMS: Give them
				playersWithPerms[p.UserId] = true
				flyEvent:FireClient(p, true) -- Send 'true' to enable
				print("âœ… SERVER: Gave fly perms to " .. p.Name)
			end
			break
		end
	end
end)

-- Clean up table when players leave
game.Players.PlayerRemoving:Connect(function(player)
	playersWithPerms[player.UserId] = nil
end)

e|S|CollisionSetup
-- Put this in ServerScriptService/CollisionGroupsSetup
-- Run this BEFORE any other scripts that spawn objects

local PhysicsService = game:GetService("PhysicsService")

print("ðŸ”§ Setting up collision groups...")

-- Create collision groups
local groups = {"NPCs", "Environment", "Projectiles", "Players"}

for _, groupName in ipairs(groups) do
	local success = pcall(function()
		PhysicsService:CreateCollisionGroup(groupName)
	end)
	if success then
		print("âœ… Created collision group: " .. groupName)
	else
		print("âš ï¸ Collision group already exists: " .. groupName)
	end
end

-- Set collision rules
-- Format: CollisionGroupSetCollidable(group1, group2, shouldCollide)

-- NPCs (Brainrots) don't collide with Environment (trees/rocks)
PhysicsService:CollisionGroupSetCollidable("NPCs", "Environment", false)

-- NPCs don't collide with each other (prevents crowding/pushing)
PhysicsService:CollisionGroupSetCollidable("NPCs", "NPCs", false)

-- Projectiles collide with NPCs (can hit brainrots)
PhysicsService:CollisionGroupSetCollidable("Projectiles", "NPCs", true)

-- Projectiles don't collide with Environment (pass through trees)
PhysicsService:CollisionGroupSetCollidable("Projectiles", "Environment", false)

-- Projectiles don't collide with Players (pass through thrower)
PhysicsService:CollisionGroupSetCollidable("Projectiles", "Players", false)

-- Environment collides with Players (can't walk through trees)
PhysicsService:CollisionGroupSetCollidable("Environment", "Players", true)

-- NPCs don't collide with Players (brainrots walk through you)
PhysicsService:CollisionGroupSetCollidable("NPCs", "Players", false)

print("âœ… Collision rules configured!")
print("   - NPCs walk through Environment & Players")
print("   - Projectiles hit NPCs but pass through Environment")
print("   - Players collide with Environment")
e|S|EnvironmentSetup
-- Put this in ServerScriptService/EnvironmentSetup
-- This automatically assigns all parts in an "Environment" folder to the Environment collision group

local PhysicsService = game:GetService("PhysicsService")
local Workspace = game:GetService("Workspace")

-- Wait for Environment folder (create it if it doesn't exist)
local environmentFolder = Workspace:FindFirstChild("Environment")
if not environmentFolder then
	environmentFolder = Instance.new("Folder")
	environmentFolder.Name = "Environment"
	environmentFolder.Parent = Workspace
	print("ðŸ“ Created Environment folder in Workspace")
end

-- Function to assign all parts in a model to Environment group
local function setupEnvironmentObject(object)
	if object:IsA("Model") or object:IsA("Folder") then
		for _, descendant in pairs(object:GetDescendants()) do
			if descendant:IsA("BasePart") then
				PhysicsService:SetPartCollisionGroup(descendant, "Environment")
			end
		end
	elseif object:IsA("BasePart") then
		PhysicsService:SetPartCollisionGroup(object, "Environment")
	end
end

-- Setup existing objects
for _, object in pairs(environmentFolder:GetChildren()) do
	setupEnvironmentObject(object)
	print("ðŸŒ³ Setup environment object: " .. object.Name)
end

-- Watch for new objects added to Environment folder
environmentFolder.ChildAdded:Connect(function(object)
	task.wait(0.1) -- Wait for all descendants to load
	setupEnvironmentObject(object)
	print("ðŸŒ³ New environment object added: " .. object.Name)
end)

print("âœ… Environment Setup loaded!")
print("ðŸ“‹ To add decorations:")
print("   1. Put trees, rocks, buildings in Workspace/Environment folder")
print("   2. They'll automatically be set to Environment collision group")
print("   3. Brainrots will walk through them, projectiles will too")
e|S|TradeHandler
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players           = game:GetService("Players")
local ServerStorage     = game:GetService("ServerStorage")

-- TradeInventory folder (optional, but kept since you referenced it)
local tradeInv = ServerStorage:FindFirstChild("TradeInventory")
if not tradeInv then
	tradeInv = Instance.new("Folder")
	tradeInv.Name = "TradeInventory"
	tradeInv.Parent = ServerStorage
end

local remotes = Instance.new("Folder")
remotes.Name  = "TradeRemotes"
remotes.Parent= ReplicatedStorage

local function makeRemote(name)
	local r  = Instance.new("RemoteEvent")
	r.Name   = name
	r.Parent = remotes
	return r
end

local sendRequest    = makeRemote("SendTradeRequest")   -- clientâ†’server: targetName
local respondRequest = makeRemote("RespondToRequest")   -- clientâ†’server: accepted
local confirmTrade   = makeRemote("ConfirmTrade")       -- clientâ†’server: {itemId,...}
local cancelTrade    = makeRemote("CancelTrade")        -- clientâ†’server
local tradeNotify    = makeRemote("TradeNotify")        -- serverâ†’client: eventType, data

-- state tables
local activeTrades      = {}  -- [player] = partner
local pendingRequests   = {}  -- [targetPlayer] = requester
local confirmedPlayers  = {}  -- [player] = {itemIds}
local countdownThreads  = {}  -- [player] = thread

local function clearConfirm(p1, p2)
	confirmedPlayers[p1] = nil
	confirmedPlayers[p2] = nil
	if countdownThreads[p1] then
		task.cancel(countdownThreads[p1])
		countdownThreads[p1] = nil
	end
	if countdownThreads[p2] then
		task.cancel(countdownThreads[p2])
		countdownThreads[p2] = nil
	end
end

local function endTrade(p1, p2)
	clearConfirm(p1, p2)
	activeTrades[p1] = nil
	activeTrades[p2] = nil
end

-- Find a specific tool instance by ItemId
local function findToolById(player, id)
	local function search(container)
		if not container then return nil end
		for _, item in ipairs(container:GetChildren()) do
			if item:IsA("Tool") and item:GetAttribute("ItemId") == id then
				return item
			end
		end
	end

	local personalInv = tradeInv:FindFirstChild(player.UserId)
	return search(player.Backpack)
		or search(player.Character)
		or (personalInv and search(personalInv))
end

local function transferTools(from, to, itemIds)
	if not itemIds then return end
	for _, id in ipairs(itemIds) do
		local found = findToolById(from, id)
		if found then
			found.Parent = to.Backpack
		end
	end
end

local function doTradeTransfer(p1, p2, tools1, tools2)
	transferTools(p1, p2, tools1)
	transferTools(p2, p1, tools2)
end

local function startCountdown(p1, p2, tools1, tools2)
	local thread = task.spawn(function()
		for i = 5, 1, -1 do
			if activeTrades[p1] ~= p2 or activeTrades[p2] ~= p1 then return end
			tradeNotify:FireClient(p1, "Countdown", i)
			tradeNotify:FireClient(p2, "Countdown", i)
			task.wait(1)
		end
		if activeTrades[p1] ~= p2 or activeTrades[p2] ~= p1 then return end

		doTradeTransfer(p1, p2, tools1, tools2)
		tradeNotify:FireClient(p1, "TradeComplete", nil)
		tradeNotify:FireClient(p2, "TradeComplete", nil)
		endTrade(p1, p2)
	end)
	countdownThreads[p1] = thread
	countdownThreads[p2] = thread
end

sendRequest.OnServerEvent:Connect(function(requester, targetName)
	local target = Players:FindFirstChild(targetName)
	if not target or target == requester then return end
	if pendingRequests[target] then return end
	pendingRequests[target] = requester
	tradeNotify:FireClient(target, "Request", requester.DisplayName)
end)

respondRequest.OnServerEvent:Connect(function(responder, accepted)
	local requester = pendingRequests[responder]
	if not requester then return end
	pendingRequests[responder] = nil

	if accepted then
		activeTrades[responder] = requester
		activeTrades[requester] = responder
		tradeNotify:FireClient(requester, "Accepted", responder.DisplayName)
		tradeNotify:FireClient(responder, "Accepted", requester.DisplayName)
	else
		tradeNotify:FireClient(requester, "Declined", responder.DisplayName)
	end
end)

confirmTrade.OnServerEvent:Connect(function(player, offeredItemIds)
	local partner = activeTrades[player]
	if not partner then return end

	-- cancel any existing countdown for this pair
	if countdownThreads[player] then
		task.cancel(countdownThreads[player])
		countdownThreads[player] = nil
	end

	confirmedPlayers[player] = offeredItemIds or {}
	tradeNotify:FireClient(partner, "PartnerConfirmed", nil)

	if confirmedPlayers[partner] then
		local tools1 = confirmedPlayers[player]
		local tools2 = confirmedPlayers[partner]
		clearConfirm(player, partner)
		startCountdown(player, partner, tools1, tools2)
	end
end)

cancelTrade.OnServerEvent:Connect(function(player)
	local partner = activeTrades[player]
	clearConfirm(player, partner or player)
	endTrade(player, partner or player)
	if partner then
		tradeNotify:FireClient(partner, "Cancelled", nil)
	end
	for target, req in pairs(pendingRequests) do
		if req == player then
			pendingRequests[target] = nil
		end
	end
end)

Players.PlayerRemoving:Connect(function(player)
	local partner = activeTrades[player]
	if partner then
		clearConfirm(player, partner)
		activeTrades[partner] = nil
		tradeNotify:FireClient(partner, "Cancelled", nil)
	end
	activeTrades[player]    = nil
	pendingRequests[player] = nil
end)

print("âœ… TradeHandler loaded")
|S|CodeRead
--=============================================================================
--Efficient compression algorithm--
--=============================================================================
--Uses this directory:
--////////////////////////////
--m = Model
--P = Part
--M = MeshPart
-- F = Folder
--G = ScreenGui / BillboardGui / SurfaceGui
--B = ImageButton / TextButton / TextBox
--p = ProximityPrompt
--S = Script
--L = LocalScript
--M = ModuleScript
--///////////////////////////////////
--The following rule exists for repetitive directories:
--If something is repeated more than 3 times i.e. model-model-model-part-script
--3mp|ScriptName
--//////////////////////////////////
--you will also need the ps1 script
--Figure it out if you use macbook
--ps1 script on discord
--//This script is fire//
local HttpService = game:GetService("HttpService")

-- Root service tokens
local ROOT_TOKENS = {
	Workspace = "w",
	ServerScriptService = "e",
	ReplicatedStorage = "r",
	StarterGui = "g",
	StarterPlayerScripts = "s",
	StarterCharacterScripts = "c"
}

-- Class tokens
local CLASS_TOKENS = {
	Model = "m",
	Part = "P",
	MeshPart = "M",
	Folder = "F",
	ScreenGui = "G",
	BillboardGui = "G",
	SurfaceGui = "G",
	ImageButton = "B",
	TextButton = "B",
	TextBox = "B",
	ProximityPrompt = "p"
}

-- Script type tokens
local SCRIPT_TYPE_TOKENS = {
	Script = "S",
	LocalScript = "L",
	ModuleScript = "M"
}

local function encodePath(obj)
	local segments = {}
	local current = obj.Parent

	while current and current ~= game do
		table.insert(segments, 1, current)
		current = current.Parent
	end

	local encoded = {}
	local i = 1

	while i <= #segments do
		local segment = segments[i]
		local className = segment.ClassName

		local token = ROOT_TOKENS[className] or CLASS_TOKENS[className]

		if token then
			local count = 1
			local j = i + 1

			while j <= #segments do
				local nextToken = ROOT_TOKENS[segments[j].ClassName] or CLASS_TOKENS[segments[j].ClassName]
				if nextToken == token then
					count += 1
					j += 1
				else
					break
				end
			end

			if count >= 3 then
				table.insert(encoded, tostring(count) .. token)
			elseif count == 2 then
				table.insert(encoded, token .. token)
			else
				table.insert(encoded, token)
			end

			i = j
		else
			-- Unknown class â†’ skip (keeps system compact)
			i += 1
		end
	end

	return table.concat(encoded)
end

local function exportOptimized()
	local exportDate = os.date("%Y-%m-%d_%H-%M")
	local finalContent = "EXPORT:" .. exportDate .. "\n"

	for _, obj in ipairs(game:GetDescendants()) do
		if obj:IsA("LuaSourceContainer") then
			local pathCode = encodePath(obj)
			local scriptType = SCRIPT_TYPE_TOKENS[obj.ClassName] or "?"
			local header = pathCode .. "|" .. scriptType .. "|" .. obj.Name

			finalContent ..= header .. "\n"
			finalContent ..= obj.Source .. "\n"
		end
	end

	print("Sending structurally encoded bundle...")
	local success, result = pcall(function()
		return HttpService:PostAsync(
			"http://127.0.0.1:8080/export",
			finalContent,
			Enum.HttpContentType.TextPlain
		)
	end)

	if success then
		print("Export complete.")
	else
		warn("Export failed: " .. result)
	end
end

exportOptimized()

|S|SpeedUp
--!strict
-- simplified speed coil by s_snaker

local BOOST = 16

local tool = script.Parent
local oldSpeed -- speed before equipping is saved in functions
local humanoid -- has to be a global so it can be used in onUnequip()
local sound = game.ReplicatedStorage.Sounds["Flash Step"]
function onEquip()
	sound.PlaybackSpeed = 1
	sound.Volume = 1

	humanoid = tool.Parent:FindFirstChild("Humanoid")
	if (humanoid ~= nil) then
		sound:Play()

		oldSpeed = humanoid.WalkSpeed
		humanoid.WalkSpeed = oldSpeed + BOOST
	end
end

function onUnequip()
	humanoid.WalkSpeed = oldSpeed
end

tool.Equipped:Connect(onEquip)
tool.Unequipped:Connect(onUnequip)
|S|Script
--!strict
-- simplified speed coil by s_snaker

local BOOST = 320


local tool = script.Parent
local oldSpeed -- speed before equipping is saved in functions
local humanoid -- has to be a global so it can be used in onUnequip()
local sound = game.ReplicatedStorage.Sounds["Flash Step"]
function onEquip()
	humanoid = tool.Parent:FindFirstChild("Humanoid")
	sound.PlaybackSpeed = 1.25
	sound.Volume = 4

	if (humanoid ~= nil) then

		sound:Play()

		oldSpeed = humanoid.WalkSpeed
		humanoid.WalkSpeed = oldSpeed + BOOST
	end
end

function onUnequip()
	humanoid.WalkSpeed = oldSpeed
end

tool.Equipped:Connect(onEquip)
tool.Unequipped:Connect(onUnequip)
P|S|Script
function shiftColor(p)
	--coroutine.resume(coroutine.create(function(p)
		function u(n,i)
			if math.abs(n) < i then
				return n
			end
			return (Vector3.new(n,0,0).unit.x)*i
		end
		local new = Vector3.new(10/math.random(10,100),10/math.random(10,100),10/math.random(10,100))
		local dif = new - p.Mesh.VertexColor
		repeat
			local d = Vector3.new(u(dif.x,0.01),u(dif.y,0.01),u(dif.z,0.01))
			p.Mesh.VertexColor = p.Mesh.VertexColor + d
			dif = dif - d
			wait()
		until math.abs(dif.x) <= 0.03 and math.abs(dif.y) <= 0.03 and math.abs(dif.z) <= 0.03
	--end),p)
end

while true do
	wait()
	shiftColor(script.Parent)
end

P|S|Script
while true do 
i = 0
for n=1,0,-0.05 do 
i = i + 0.05
script.Parent.SparkleColor = Color3.new(i, 0, n)
wait() 
end  
i = 0
for n=1,0,-0.05 do 
i = i + 0.05
script.Parent.SparkleColor = Color3.new(n, i, 0)
wait()
end   
i = 0
for n=1,0,-0.05 do 
i = i + 0.05
script.Parent.SparkleColor = Color3.new(0, n, i)
wait() 
end 
end 
G|L|LocalScript
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
script.Parent.Visible = false
local player = Players.LocalPlayer
local leaderstats = player:WaitForChild("leaderstats")
local money = leaderstats.Parent:WaitForChild("MoneyRaw")
local rebirths = leaderstats:WaitForChild("Rebirths")

local frame = script.Parent
local rebirthButton = frame:WaitForChild("RebirthButton")
local costLabel = frame:WaitForChild("CostContainer"):WaitForChild("CostLabel")
local progressBar = frame:WaitForChild("ProgressBarFrame")
local fillBar = progressBar:WaitForChild("FillBar")
local progressText = progressBar:WaitForChild("ProgressText")
local statusLabel = frame:WaitForChild("StatusLabel")
local currentRebirthsLabel = frame:WaitForChild("CurrentRebirthsLabel")
local rewardLabel = frame:WaitForChild("RewardContainer"):WaitForChild("RewardLabel")

-- Configuration (must match server)
local BASE_REBIRTH_COST = 100000
local COST_MULTIPLIER = 1.5

local function calculateCost(rebirthCount)
	return math.floor(BASE_REBIRTH_COST * (COST_MULTIPLIER ^ rebirthCount))
end

local function formatNumber(num)
	if num >= 1000000000 then
		return string.format("%.2fB", num / 1000000000)
	elseif num >= 1000000 then
		return string.format("%.2fM", num / 1000000)
	elseif num >= 1000 then
		return string.format("%.2fK", num / 1000)
	else
		return tostring(num)
	end
end

local function updateUI()
	local currentCost = calculateCost(rebirths.Value)
	local nextRebirthBonus = rebirths.Value + 1

	-- Update cost label
	costLabel.Text = "ðŸ’° Cost: $" .. formatNumber(currentCost)

	-- Update current rebirths
	currentRebirthsLabel.Text = "Current Rebirths: " .. rebirths.Value

	-- Update reward label
	rewardLabel.Text = "ðŸŽ Next Rebirth Bonus\n+" .. nextRebirthBonus .. "x Multiplier"

	-- Update benefit label in confirmation

	-- Update progress bar
	local progress = math.min(money.Value / currentCost, 1)
	progressText.Text = "$" .. formatNumber(money.Value) .. " / $" .. formatNumber(currentCost)

	-- Animate fill bar
	local targetSize = UDim2.new(progress, 0, 1, 0)
	local fillTween = TweenService:Create(fillBar, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = targetSize
	})
	fillTween:Play()

	-- Update button state
	if money.Value >= currentCost then
		-- Can afford rebirth - enable button
		rebirthButton.BackgroundColor3 = Color3.fromRGB(255, 170, 0)
		rebirthButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		local buttonStroke = rebirthButton:FindFirstChild("UIStroke")
		if buttonStroke then
			buttonStroke.Color = Color3.fromRGB(255, 200, 0)
		end
		local buttonGradient = rebirthButton:FindFirstChild("UIGradient")
		if buttonGradient then
			buttonGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 190, 50)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 140, 0))
			}
		end

		statusLabel.Text = "âœ… Ready to rebirth!"
		statusLabel.TextColor3 = Color3.fromRGB(100, 255, 150)

		-- Change fill bar color to green
		fillBar.BackgroundColor3 = Color3.fromRGB(100, 255, 150)
		local fillGradient = fillBar:FindFirstChild("UIGradient")
		if fillGradient then
			fillGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(120, 255, 170)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(80, 220, 130))
			}
		end
	else
		-- Cannot afford - disable button
		rebirthButton.BackgroundColor3 = Color3.fromRGB(120, 120, 130)
		rebirthButton.TextColor3 = Color3.fromRGB(180, 180, 190)
		local buttonStroke = rebirthButton:FindFirstChild("UIStroke")
		if buttonStroke then
			buttonStroke.Color = Color3.fromRGB(100, 100, 110)
		end
		local buttonGradient = rebirthButton:FindFirstChild("UIGradient")
		if buttonGradient then
			buttonGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(140, 140, 150)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 100, 110))
			}
		end

		local needed = currentCost - money.Value
		statusLabel.Text = "âŒ Need $" .. formatNumber(needed) .. " more"
		statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)

		-- Keep fill bar blue
		fillBar.BackgroundColor3 = Color3.fromRGB(80, 200, 255)
		local fillGradient = fillBar:FindFirstChild("UIGradient")
		if fillGradient then
			fillGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 220, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 160, 255))
			}
		end
	end
end

-- Update UI when values change
money.Changed:Connect(updateUI)
rebirths.Changed:Connect(updateUI)

-- Initial update
updateUI()
GB|L|LocalScript
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local rebirthevent = ReplicatedStorage.RemoteEvents:WaitForChild("rebirthevent")
local rebirthButton = script.Parent

-- Button click - rebirth immediately (no confirmation)
rebirthButton.MouseButton1Click:Connect(function()
	print("Rebirth button clicked!") -- Debug

	-- Check if button is enabled using attribute (set by the UI update script)
	if rebirthButton:GetAttribute("Disabled") == true then
		print("Button is disabled") -- Debug
		return
	end

	print("Firing rebirth event to server") -- Debug

	-- Fire rebirth event immediately
	rebirthevent:FireServer()
end)

-- Listen for server response
rebirthevent.OnClientEvent:Connect(function(success, data)
	if success then
		print("Successfully rebirthed! New rebirth count: " .. data)
		-- Optional: Play success sound, effects, etc.
	else
		print("Rebirth failed! Need: $" .. data)
		-- Optional: Play error sound
	end
end)
GB|L|LocalScript
local TweenService = game:GetService("TweenService")

local closeButton = script.Parent
local mainFrame = closeButton.Parent
local openButton = mainFrame.Parent.Parent.RebirthOpen:WaitForChild("RebirthOpenButton")

closeButton.MouseButton1Click:Connect(function()
	-- Hide confirmation frame if it's open
	

	-- Animate main frame closing
	local closeTween = TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0)
	})
	closeTween:Play()
	closeTween.Completed:Wait()
	mainFrame.Visible = false

	-- Show open button
	openButton.Visible = true
	openButton.Size = UDim2.new(0, 0, 0, 0)
	local openTween = TweenService:Create(openButton, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 70, 0, 70)
	})
	openTween:Play()

	-- Button press animation
	closeButton.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
	wait(0.1)
	closeButton.BackgroundColor3 = Color3.fromRGB(220, 70, 70)
end)

-- Hover effects
closeButton.MouseEnter:Connect(function()
	local hoverTween = TweenService:Create(closeButton, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 45, 0, 45),
		BackgroundColor3 = Color3.fromRGB(255, 100, 100)
	})
	hoverTween:Play()
end)

closeButton.MouseLeave:Connect(function()
	local leaveTween = TweenService:Create(closeButton, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 40, 0, 40),
		BackgroundColor3 = Color3.fromRGB(220, 70, 70)
	})
	leaveTween:Play()
end)
F|S|Part_1
-- [[ CHUNK START ]] --
------------------------------------------------------------
-- PATH: ServerScriptService.tradeserver
-- TYPE: Script
------------------------------------------------------------
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MarketplaceService = game:GetService("MarketplaceService")

local getPassesFunc = ReplicatedStorage:FindFirstChild("GetPasses")
if not getPassesFunc then
	getPassesFunc = Instance.new("RemoteFunction")
	getPassesFunc.Name = "GetPasses"
	getPassesFunc.Parent = ReplicatedStorage
end

local PYTHON_URL = "http://127.0.0.1:8080/get-passes/"

local function fetchPasses(player)
	print("ðŸ”´ [1] Lua requesting Manual List...")

	local response
	local success, err = pcall(function()
		response = HttpService:GetAsync(PYTHON_URL .. player.UserId)
	end)

	if not success then
		warn("Connection Error: " .. err)
		return {}
	end

	local data = HttpService:JSONDecode(response)
	local rawItems = data.passes or {}
	local finalItems = {}

	print("ðŸŸ¢ [2] Python sent " .. #rawItems .. " IDs. Verifying...")

	for _, item in ipairs(rawItems) do
		local id = item.id

		-- STRICTLY CHECK AS GAMEPASS
		local infoSuccess, info = pcall(function()
			return MarketplaceService:GetProductInfo(id, Enum.InfoType.GamePass)
		end)

		if infoSuccess and info then
			print("   -> LOADED: " .. info.Name .. " (" .. (info.PriceInRobux or 0) .. " R$)")

			table.insert(finalItems, {
				id = id,
				name = info.Name,
				price = info.PriceInRobux or 0,
				type = "GamePass"
			})
		else
			warn("   -> FAILED to verify ID: " .. id .. " (Check if it's really a GamePass?)")
		end
	end

	print("ðŸŸ¢ [3] Sending " .. #finalItems .. " items to Booth.")
	return finalItems
end

getPassesFunc.OnServerInvoke = function(player)
	return fetchPasses(player)
end


------------------------------------------------------------
-- PATH: ServerScriptService.ThrowingSystem
-- TYPE: Script
------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local StarterPack = game:GetService("StarterPack")
local RunService = game:GetService("RunService")

-- EVENTS
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local bounceNotificationEvent = remoteEvents:WaitForChild("BounceNotif")
local capacityFullEvent = remoteEvents:WaitForChild("CapacityFullEvent") -- NEW EVENT
local throwMemeEvent = remoteEvents:WaitForChild("ThrowMemeEvent")

-- Constants
local MAX_DISTANCE = 500 
local RELOAD_TIME = 0.8

local function calculateTrajectory(powerPercent, strength, rebirthMultiplier)
	local baseDistance = MAX_DISTANCE * powerPercent
	local finalDistance = baseDistance * strength * rebirthMultiplier
	local accuracy = powerPercent
	return finalDistance, accuracy
end

-- Function to find the brainrot model from any part within it
local function findBrainrotModel(part)
	local current = part.Parent
	for i = 1, 5 do
		if current and current:IsA("Model") and current:GetAttribute("Rarity") ~= nil then
			return current
		end
		if current then
			current = current.Parent
		else
			break
		end
	end
	return nil
end

-- Function to count how many brainrots player currently has
local function countPlayerBrainrots(player)
	local count = 0

	local backpack = player:FindFirstChild("Backpack")
	if backpack then
		for _, tool in pairs(backpack:GetChildren()) do
			if tool:IsA("Tool") and tool:GetAttribute("Rarity") then
				count = count + 1
			end
		end
	end

	-- Check equipped tool
	if player.Character then
		local equippedTool = player.Character:FindFirstChildOfClass("Tool")
		if equippedTool and equippedTool:GetAttribute("Rarity") then
			count = count + 1
		end
	end

	return count
end


local function canCollectBrainrot(player, brainrotModel)
	local requirement = brainrotModel:GetAttribute("RebirthRequirement") or 0

	if requirement == 0 then
		return true -- Common brainrots always collectible
	end

	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then return false end

	local rebirths = leaderstats:FindFirstChild("Rebirths")
	if not rebirths then return false end

	if rebirths.Value < requirement then
		-- Player doesn't have enough rebirths
		warn("ðŸ”’ " .. player.Name .. " needs " .. requirement .. " rebirths to collect this brainrot!")
		return false
	end

	return true
end






-- Function to convert brainrot model into a tool and add to player's inventory
local function collectBrainrot(player, brainrotModel)
	
	
	-- CHECK LOCK STATUS FIRST
	if not canCollectBrainrot(player, brainrotModel) then
		print("âŒ " .. player.Name .. " cannot collect locked brainrot: " .. brainrotModel.Name)
		return false
	end
	-- Check capacity SECOND
	local currentCount = countPlayerBrainrots(player)
	local maxCapacity = player:GetAttribute("BrainrotCapacity") or 1

	if currentCount >= maxCapacity then
		print("âŒ " .. player.Name .. " is at capacity (" .. currentCount .. "/" .. maxCapacity .. ")")

		-- [[ NEW FEATURE: FIRE CAPACITY GUI ]] --
		capacityFullEvent:FireClient(player)
		return false
	end

	local rarity = brainrotModel:GetAttribute("Rarity") or "Common"

	-- COPY THE MUTATION
	local mutation = brainrotModel:GetAttribute("Mutation")
	local mutationMult = brainrotModel:GetAttribute("MutationMult")

	-- Clone world model
	local clone = brainrotModel:Clone()
	clone.Parent = nil

	-- Gather BaseParts
	local parts = {}
	for _, obj in ipairs(clone:GetDescendants()) do
		if obj:IsA("BasePart") then
			table.insert(parts, obj)
		end
	end

	if #parts == 0 then
		warn("Brainrot has no BaseParts:", brainrotModel.Name)
		clone:Destroy()
		return false
	end

	-- Choose handle
	local handle = parts[1]
	handle.Name = "Handle"
	handle.Anchored = false
	handle.CanCollide = false
	handle.CanTouch = false

	-- Create Tool
	local tool = Instance.new("Tool")
	tool.Name = brainrotModel.Name
	tool.RequiresHandle = true
	tool.CanBeDropped = true
	tool:SetAttribute("Rarity", rarity)

	-- PASTE THE MUTATION
	if mutation then
		tool:SetAttribute("Mutation", mutation)
		if mutationMult then
			tool:SetAttribute("MutationMult", mutationMult)
		end
		print("âœ¨ SAVED MUTATION: " .. mutation .. " on " .. tool.Name)
	end

	-- Parent handle
	handle.Parent = tool

	-- Weld remaining parts
	for _, part in ipairs(parts) do
		if part ~= handle then
			part.Anchored = false
			part.CanCollide = false
			part.CanTouch = false
			part.Parent = tool

			local weld = Instance.new("WeldConstraint")
			weld.Part0 = handle
			weld.Part1 = part
			weld.Parent = handle
		end
	end

	-- Destroy leftover containers
	clone:Destroy()

	-- Give tool to player
	tool.Parent = player:WaitForChild("Backpack")

	-- Remove world instance
	brainrotModel:Destroy()

	local newCount = currentCount + 1
	print("âœ“ Brainrot added to Backpack:", tool.Name, "(" .. newCount .. "/" .. maxCapacity .. ")")
	return true
end

local function trackProjectile(player, projectile, detector, expectedDistance)
	local startPosition = projectile.Position
	local hoopsHit = {}
	local maxHeight = projectile.Position.Y
	local collectedBrainrots = {}

	-- TIME TRACKING VARIABLES
	local launchTime = os.clock()
	local groundHitTime = nil

	local heartbeatConnection
	local detectorConnection

	detectorConnection = detector.Touched:Connect(function(hit)
		if hit:IsDescendantOf(player.Character) then return end

		local currentTime = os.clock()

		-- Check for brainrot collision
		local brainrotModel = findBrainrotModel(hit)

		if brainrotModel then
			if not collectedBrainrots[brainrotModel] then

				-- Logic: Bounce vs Direct Hit
				local isBounce = false
				if groundHitTime ~= nil then
					local timeSinceGroundHit = currentTime - groundHitTime
					if timeSinceGroundHit > 0.15 then
						isBounce = true
					end
				end

				if isBounce then
					-- CASE 1: REAL BOUNCE (Notification ONLY)
					bounceNotificationEvent:FireClient(player) 
					print("Bounce Detected! (Notification sent)")
					collectedBrainrots[brainrotModel] = true
				else
					-- CASE 2: DIRECT HIT (Collect item)
					-- NOTE: collectBrainrot now handles the capacity check internally!
					local success = collectBrainrot(player, brainrotModel)

					-- If we successfully collected OR failed due to capacity, we mark it as processed
					-- so we don't trigger it again instantly
					collectedBrainrots[brainrotModel] = true
				end
			end
			return 
		end

		-- Check for hoop collision
		if hit.Name == "HoopPart" and hit.Parent and not hoopsHit[hit.Parent] then
			local hoop = hit.Parent
			local tier = hoop:FindFirstChild("Tier")
			if tier and tier:IsA("IntValue") then
				hoopsHit[hoop] = tier.Value
				hit.BrickColor = BrickColor.new("Bright green")
				task.delay(0.5, function()
					if hit then hit.BrickColor = BrickColor.new("Really red") end
				end)
			end
			return
		end

		-- Ground/Wall Detection
		if hit.CanCollide and hit.Name ~= "ProjectileDetector" then
			if groundHitTime == nil and (currentTime - launchTime > 0.1) then
				groundHitTime = currentTime
			end
		end
	end)

	-- Monitor projectile height and landing
	heartbeatConnection = RunService.Heartbeat:Connect(function()
		if not projectile or not projectile.Parent then
			heartbeatConnection:Disconnect()
			if detectorConnection then detectorConnection:Disconnect() end
			return
		end

		if projectile.Position.Y > maxHeight then
			maxHeight = projectile.Position.Y
		end

		if projectile.Position.Y < -50 or projectile.AssemblyLinearVelocity.Magnitude < 1 then
			heartbeatConnection:Disconnect()
			if detectorConnection then detectorConnection:Disconnect() end

			local endPosition = projectile.Position
			local distanceTraveled = (endPosition - startPosition).Magnitude
			local moneyEarned = math.floor(distanceTraveled)

			if distanceTraveled > 5 then
				print("SERVER: " .. player.Name .. " threw " .. math.floor(distanceTraveled) .. " studs, earned $" .. moneyEarned)
			end

			task.wait(2)
			if detector then detector:Destroy() end
			if projectile then projectile:Destroy() end
		end
	end)
end

local function reloadTool(player, toolName)
	task.wait(RELOAD_TIME)
	local originalToolTemplate = StarterPack:FindFirstChild(toolName)
	if originalToolTemplate and player.Character then
		local newTool = originalToolTemplate:Clone()

		-- GET REBIRTH COUNT FOR SCALING
		local leaderstats = player:FindFirstChild("leaderstats")
		local rebirthCount = 0
		if leaderstats then
			local rebirths = leaderstats:FindFirstChild("Rebirths")
			if rebirths then
				rebirthCount = rebirths.Value
			end
		end

		-- Calculate scale for 2x volume per rebirth
		local volumeMultiplier = 1.5 ^ rebirthCount
		local scaleMultiplier = volumeMultiplier ^ (1/3)

		if rebirthCount > 0 then
			print("ðŸŽ¯ Scaling tool for " .. player.Name .. ": " .. string.format("%.2f", scaleMultiplier) .. "x (" .. volumeMultiplier .. "x volume)")

			-- Scale all parts in the tool
			for _, descendant in pairs(newTool:GetDescendants()) do
				if descendant:IsA("BasePart") then
					descendant.Size = descendant.Size * scaleMultiplier
					-- IMPORTANT: Keep CanCollide false while held to prevent floor clipping
					descendant.CanCollide = false
					descendant.Massless = true
				elseif descendant:IsA("SpecialMesh") then
					descendant.Scale = descendant.Scale * scaleMultiplier
				end
			end
		else
			-- Make sure parts don't collide when held
			for _, descendant in pairs(newTool:GetDescendants()) do
				if descendant:IsA("BasePart") then
					descendant.CanCollide = false
					descendant.Massless = true
				end
			end
		end

		newTool.Parent = player.Backpack
		local humanoid = player.Character:FindFirstChild("Humanoid")
		if humanoid then humanoid:EquipTool(newTool) end
	else
		warn("Could not find tool " .. toolName .. " in StarterPack to reload!")
	end
end

local function launchProjectile(player, powerPercent, distance, accuracy, targetPosition)
	local character = player.Character
	if not character then return end

	local tool = character:FindFirstChildOfClass("Tool")
	if not tool then return end

	local handle = tool:FindFirstChild("Handle")
	if not handle then return end

	local toolName = tool.Name
	local startPos = handle.Position

	local projectile = handle
	projectile.Parent = Workspace 
	projectile.Name = "MemeProjectile"
	projectile.Anchored = false
	projectile.CanCollide = true
	projectile.CanTouch = true

	-- GET REBIRTH COUNT FOR DETECTOR SCALING
	local leaderstats = player:FindFirstChild("leaderstats")
	local rebirthCount = 0
	if leaderstats then
		local rebirths = leaderstats:FindFirstChild("Rebirths")
		if rebirths then
			rebirthCount = rebirths.Value
		end
	end

	-- Calculate detector scale (2x volume per rebirth)
	local volumeMultiplier = 2 ^ rebirthCount
	local detectorScale = volumeMultiplier ^ (1/3)

	-- Scale detector for collision detection
	local baseDetectorSize = 8
	local detectorSize = baseDetectorSize * detectorScale

	local detector = Instance.new("Part")
	detector.Name = "ProjectileDetector"
	detector.Size = Vector3.new(detectorSize, detectorSize, detectorSize) 
	detector.Transparency = 1
	detector.CanCollide = false
	detector.CanTouch = true
	detector.Massless = true
	detector.CFrame = projectile.CFrame
	detector.Parent = Workspace

	print("ðŸŽ¯ Detector size: " .. detectorSize .. " (" .. volumeMultiplier .. "x volume)")

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = projectile
	weld.Part1 = detector
	weld.Parent = projectile

	for _, child in pairs(projectile:GetChildren()) do
		if child:IsA("Script") or child:IsA("LocalScript") or child:IsA("Motor6D") then
			child:Destroy()
		end
	end

	tool:Destroy()

	local directionVector = (targetPosition - startPos).Unit
	local arcDirection = (directionVector + Vector3.new(0, 0.2, 0)).Unit
	local deviation = (1 - accuracy) * 0.3
	local randomWobble = Vector3.new(
		(math.random() - 0.5) * deviation,
		(math.random() - 0.5) * deviation,
		(math.random() - 0.5) * deviation
	)

	local finalDirection = (arcDirection + randomWobble).Unit
	local speed = 50 + (powerPercent * 150) 
	local velocity = finalDirection * speed

	projectile.AssemblyLinearVelocity = velocity
	projectile:SetNetworkOwner(nil)

	trackProjectile(player, projectile, detector, distance)

	task.spawn(function() 
		reloadTool(player, toolName)
	end)
end

local function launchProjectile(player, powerPercent, distance, accuracy, targetPosition)
	local character = player.Character
	if not character then return end

	local tool = character:FindFirstChildOfClass("Tool") -- FIXED: was "Banana"
	if not tool then return end

	local handle = tool:FindFirstChild("Handle")
	if not handle then return end

	local toolName = tool.Name
	local startPos = handle.Position

	local projectile = handle
	projectile.Parent = Workspace 
	projectile.Name = "MemeProjectile"
	projectile.Anchored = false
	projectile.CanCollide = true
	projectile.CanTouch = true

	local detector = Instance.new("Part")
	detector.Name = "ProjectileDetector"
	detector.Size = Vector3.new(8, 8, 8) 
	detector.Transparency = 1
	detector.CanCollide = false
	detector.CanTouch = true
	detector.Massless = true
	detector.CFrame = projectile.CFrame
	detector.Parent = Workspace

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = projectile
	weld.Part1 = detector
	weld.Parent = projectile

	for _, child in pairs(projectile:GetChildren()) do
		if child:IsA("Script") or child:IsA("LocalScript") or child:IsA("Motor6D") then
			child:Destroy()
		end
	end

	tool:Destroy()

	local directionVector = (targetPosition - startPos).Unit
	local arcDirection = (directionVector + Vector3.new(0, 0.2, 0)).Unit
	local deviation = (1 - accuracy) * 0.3
	local randomWobble = Vector3.new(
		(math.random() - 0.5) * deviation,
		(math.random() - 0.5) * deviation,
		(math.random() - 0.5) * deviation
	)

	local finalDirection = (arcDirection + randomWobble).Unit
	local speed = 50 + (powerPercent * 150) 
	local velocity = finalDirection * speed

	projectile.AssemblyLinearVelocity = velocity
	projectile:SetNetworkOwner(nil)

	trackProjectile(player, projectile, detector, distance)

	task.spawn(function() 
		reloadTool(player, toolName)
	end)
end

throwMemeEvent.OnServerEvent:Connect(function(player, powerPercent, targetPosition)
	if type(powerPercent) ~= "number" then return end
	if typeof(targetPosition) ~= "Vector3" then
		if player.Character and player.Character.PrimaryPart then
			targetPosition = player.Character.PrimaryPart.Position + (player.Character.PrimaryPart.CFrame.LookVector * 50)
		else
			return 
		end
	end
	local strength = 1
	local rebirthMultiplier = 1
	local distance, accuracy = calculateTrajectory(powerPercent, strength, rebirthMultiplier)
	launchProjectile(player, powerPercent, distance, accuracy, targetPosition)
end)

print("ThrowingSystem loaded!")


------------------------------------------------------------
-- PATH: ServerScriptService.Spawning System
-- TYPE: Script
------------------------------------------------------------
local replicatedstorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local brainrotsfolder = replicatedstorage:FindFirstChild("Brainrot pack1") or replicatedstorage:WaitForChild("Brainrot pack1")
local brainrots = brainrotsfolder:GetChildren()
local WeatherSystem = require(game.ReplicatedStorage:WaitForChild("WeatherSystem"))
-- Rebirth requirements for each rarity
local RARITY_REQUIREMENTS = {
	["Common"] = 0,
	["Rare"] = 1,
	["Epic"] = 3,
	["Legendary"] = 5,
	["Mythic"] = 10,
	["Brainrot God"] = 25,
	["Secret"] = 50,
	["OG"] = 100,
}

-- Ensure RemoteEvents exist
local Remotes = game.ReplicatedStorage:FindFirstChild("RemoteEvents")
if not Remotes then
	Remotes = Instance.new("Folder", game.ReplicatedStorage)
	Remotes.Name = "RemoteEvents"
end

local function getRemote(name)
	local r = Remotes:FindFirstChild(name)
	if not r then
		r = Instance.new("RemoteEvent", Remotes)
		r.Name = name
	end
	return r
end

local Remotes            = game.ReplicatedStorage:WaitForChild("RemoteEvents")
local event              = Remotes:WaitForChild("randombrainrot")
local autospawn          = Remotes:WaitForChild("AutoSpawn")
local spawnSpecificEvent = Remotes:WaitForChild("SpawnSpecificBrainrot")

local PLATFORM_CENTER_X = 0
local PLATFORM_CENTER_Z = 0
local PLATFORM_RADIUS = 120
local PLATFORM_Y = 1

local AUTO_SPAWN_ENABLED = true
local AUTO_SPAWN_INTERVAL = 3 
local DESPAWN_TIME = {
	["Common"] = 120, ["Rare"] = 120, ["Epic"] = 120, ["Legendary"] = 120,
	["Mythic"] = 120, ["Secret"] = 120, ["OG"] = 120, ["Brainrot God"] = 120,
}
local MAX_BRAINROTS = 25 

local activeBrainrots = {}

local RARITY_COLORS = {
	["Common"] = Color3.fromRGB(0, 255, 0),
	["Rare"] = Color3.fromRGB(0, 100, 255),
	["Epic"] = Color3.fromRGB(150, 0, 255),
	["Legendary"] = Color3.fromRGB(255, 255, 0),
	["Mythic"] = Color3.fromRGB(255, 0, 0),
	["Brainrot God"] = "Rainbow",
	["Secret"] = Color3.fromRGB(30, 30, 30),
	["OG"] = "Split",
}

local MUTATION_COLORS = {
	-- Permanent
	["Gold"]        = Color3.fromRGB(255, 215, 0),
	["Diamond"]     = Color3.fromRGB(185, 242, 255),
	["Rainbow"]     = "Rainbow",
	-- Limited (weather-gated)
	["Bloodrot"]    = Color3.fromRGB(100, 0, 0),
	["Candy"]       = Color3.fromRGB(255, 105, 180),
	["Lava"]        = Color3.fromRGB(255, 80, 0),
	["Galaxy"]      = Color3.fromRGB(138, 43, 226),
	["Yin-Yang"]    = "YinYang",   -- special animated flag
	["Radioactive"] = Color3.fromRGB(0, 255, 50),
	["Wet"] = Color3.fromRGB(84, 130, 255)
}

local MUTATION_RATES = {
	-- Permanent mutations â€” always in the pool
	["Rainbow"]  = 5,
	["Diamond"]  = 102,
	["Gold"]     = 250,
	-- Limited mutations â€” 0 base rate; boosted by weather system
	["Bloodrot"]    = 0,
	["Candy"]       = 0,
	["Lava"]        = 0,
	["Galaxy"]      = 0,
	["Yin-Yang"]    = 0,
	["Radioactive"] = 0,
	["Wet"] = 0
}

local MUTATION_MULTIPLIERS = {
	-- Permanent
	["Gold"]        = 1.25,
	["Diamond"]     = 1.50,
	["Rainbow"]     = 10.0,
	-- Limited
	["Bloodrot"]    = 2.0,
	["Candy"]       = 4.0,
	["Lava"]        = 6.0,
	["Galaxy"]      = 7.0,
	["Yin-Yang"]    = 7.5,
	["Radioactive"] = 8.5,
	["Wet"] = 1.5
}

local RARITY_SPEEDS = {
	["Common"] = 24, 
	["Rare"] = 36, 
	["Epic"] = 48, 
	["Legendary"] = 60,
	["Mythic"] = 75, 
	["Brainrot God"] = 90,
	["BrainrotGod"] = 90,  -- Add version without space
	["Secret"] = 100, 
	["OG"] = 150,
}

local function getValidSpawnPosition()
	local x = math.random(-256, 256)
	local z = math.random(-256, 256)
	return Vector3.new(x, PLATFORM_Y + 5, z)
end

local function getMutation()
	-- â”€â”€ Step 1: Check for a Limited mutation via active weather â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	

	-- â”€â”€ Step 2: Normal permanent mutation roll â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	local roll = math.random(1, 1000)
	if roll <= MUTATION_RATES["Rainbow"] then
		return "Rainbow"
	elseif roll <= MUTATION_RATES["Rainbow"] + MUTATION_RATES["Diamond"] then
		return "Diamond"
	elseif roll <= MUTATION_RATES["Rainbow"] + MUTATION_RATES["Diamond"] + MUTATION_RATES["Gold"] then
		return "Gold"
	end

	return nil  -- no mutation
end

local function animateRainbow(textLabel)
	task.spawn(function()
		local hue = 0
		while textLabel and textLabel.Parent do
			hue = (hue + 0.01) % 1
			textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
			task.wait(0.05)
		end
	end)
end

local function animateRainbowModel(model)
	task.spawn(function()
		local hue = 0
		local parts = {}
		for _, descendant in pairs(model:GetDescendants()) do
			if descendant:IsA("BasePart") then table.insert(parts, descendant) end
		end
		while model and model.Parent do
			hue = (hue + 0.01) % 1
			local rainbowColor = Color3.fromHSV(hue, 1, 1)
			for _, part in pairs(parts) do
				if part and part.Parent then 
					part.Color = rainbowColor 
				end
			end
			task.wait(0.05)
		end
	end)
end

-- FIXED: Apply monochrome filter to locked brainrots
local function applyMonochromeFilter(brainrotModel)
	for _, descendant in pairs(brainrotModel:GetDescendants()) do
		if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
			-- Convert color to grayscale
			local originalColor = descendant.Color
			local gray = (originalColor.R + originalColor.G + originalColor.B) / 3
			descendant.Color = Color3.new(gray, gray, gray)
			descendant.Material = Enum.Material.SmoothPlastic

			-- CRITICAL: Remove SurfaceAppearance which blocks color changes
			local surfaceAppearance = descendant:FindFirstChildOfClass("SurfaceAppearance")
			if surfaceAppearance then
				surfaceAppearance:Destroy()
			end
		elseif descendant:IsA("SpecialMesh") then
			-- Remove textures
			descendant.TextureId = ""
		end
	end
end

-- FIXED: Mutation visuals - handle SurfaceAppearance
local function applyMutationVisuals(brainrotModel, mutation)
	if not mutation then return end

	local function applyColorToPart(part, color, material, reflectance)
		if part:IsA("BasePart") or part:IsA("MeshPart") then
			part.Color = color
			if material then part.Material = material end
			if reflectance then part.Reflectance = reflectance end

			-- CRITICAL: Remove SurfaceAppearance which blocks color changes
			local surfaceAppearance = part:FindFirstChildOfClass("SurfaceAppearance")
			if surfaceAppearance then
				surfaceAppearance:Destroy()
			end
		end
	end

	if mutation == "Rainbow" then
		animateRainbowModel(brainrotModel)
		-- Still need to remove SurfaceAppearance for rainbow to work
		for _, descendant in pairs(brainrotModel:GetDescendants()) do
			if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
				local surfaceAppearance = descendant:FindFirstChildOfClass("SurfaceAppearance")
				if surfaceAppearance then
					surfaceAppearance:Destroy()
				end
			end
		end
	elseif mutation == "Gold" then
		for _, descendant in pairs(brainrotModel:GetDescendants()) do
			applyColorToPart(descendant, Color3.fromRGB(255, 215, 0), Enum.Material.SmoothPlastic, nil)
			-- Remove textures that might override color
			if descendant:IsA("SpecialMesh") then
				descendant.TextureId = ""
			end
		end
	elseif mutation == "Diamond" then
		for _, descendant in pairs(brainrotModel:GetDescendants()) do
			applyColorToPart(descendant, Color3.fromRGB(185, 242, 255), Enum.Material.SmoothPlastic, 0.3)
			-- Remove textures that might override color
			if descendant:IsA("SpecialMesh") then
				descendant.TextureId = ""
			end
		end
	end
end

local function animateGalaxy(model)
	task.spawn(function()
		local parts = {}
		for _, d in pairs(model:GetDescendants()) do
			if d:IsA("BasePart") then table.insert(parts, d) end
		end
		local t = 0
		while model and model.Parent do
			t += 0.02
			-- slow violet pulse between deep purple and bright indigo
			local brightness = 0.5 + 0.5 * math.sin(t)
			local col = Color3.fromRGB(
				math.floor(75  + 63  * brightness),
				math.floor(0   + 0   * brightness),
				math.floor(130 + 100 * brightness)
			)
			for _, p in pairs(parts) do
				if p and p.Parent then p.Color = col end
			end
			task.wait(0.05)
		end
	end)
end

local function animateYinYang(model)
	task.spawn(function()
		local parts = {}
		for _, d in pairs(model:GetDescendants()) do
			if d:IsA("BasePart") then table.insert(parts, d) end
		end
		local flip = false
		local timer = 0
		while model and model.Parent do
			timer += 0.05
			if timer >= 0.5 then
				timer = 0
				flip = not flip
				local col = flip and Color3.new(1,1,1) or Color3.new(0,0,0)
				for _, p in pairs(parts) do
					if p and p.Parent then p.Color = col end
				end
			end
			task.wait(0.05)
		end
	end)
end

local function animateRadioactive(model)
	task.spawn(function()
		local parts = {}
		for _, d in pairs(model:GetDescendants()) do
			if d:IsA("BasePart") then table.insert(parts, d) end
		end
		local t = 0
		while model and model.Parent do
			t += 0.08
			local brightness = 0.5 + 0.5 * math.sin(t)
			local g = math.floor(150 + 105 * brightness)
			local col = Color3.fromRGB(0, g, 0)
			for _, p in pairs(parts) do
				if p and p.Parent then p.Color = col end
			end
			task.wait(0.05)
		end
	end)
end

local function applyLimitedMutationVisuals(brainrotModel, mutation)
	if not mutation then return end
	local visualData = WeatherSystem.LIMITED_VISUALS[mutation]
	if not visualData then return end

	-- Always strip SurfaceAppearance & textures first
	for _, d in pairs(brainrotModel:GetDescendants()) do
		if d:IsA("BasePart") or d:IsA("MeshPart") then
			local sa = d:FindFirstChildOfClass("SurfaceAppearance")
			if sa then sa:Destroy() end
			if visualData.material then
				d.Material = visualData.material
			end
			if visualData.reflectance then
				d.Reflectance = visualData.reflectance
			end
			-- Apply base color (overridden by animations below if animated)
			if visualData.color and visualData.animated == false then
				d.Color = visualData.color
			end
		elseif d:IsA("SpecialMesh") then
			d.TextureId = ""
		end
	end

	-- Apply animation if needed
	if visualData.animated == "galaxy" then
		animateGalaxy(brainrotModel)
	elseif visualData.animated == "yinyang" then
		animateYinYang(brainrotModel)
	elseif visualData.animated == "radioactive" then
		animateRadioactive(brainrotModel)
	end
end

local function addNameTag(brainrot)
	local rarity = brainrot:GetAttribute("Rarity") or "Common"
	local mutation = brainrot:GetAttribute("Mutation")
	local isLocked = brainrot:GetAttribute("IsLocked") or false
	local anchorPart = brainrot:FindFirstChild("RootPart") or brainrot.PrimaryPart or brainrot:FindFirstChildWhichIsA("BasePart")

	if not anchorPart then return end

	local bb = Instance.new("BillboardGui")
	bb.Name = "StatsGUI"
	bb.Adornee = anchorPart
	bb.Size = UDim2.new(12, 0, 6, 0)
	bb.ExtentsOffset = Vector3.new(0, 2.5, 0) 
	bb.AlwaysOnTop = true
	bb.MaxDistance = 400 
	bb.Parent = brainrot

	local container = Instance.new("Frame")
	container.Size = UDim2.new(1, 0, 1, 0)
	container.BackgroundTransparency = 1
	container.Parent = bb

	local listLayout = Instance.new("UIListLayout")
	listLayout.Parent = container
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
	listLayout.Padding = UDim.new(0, 0)

	local function createLabel(text, layoutOrder, font, color, strokeColor, strokeTrans)
		local lbl = Instance.new("TextLabel")
		lbl.Text = text
		lbl.Size = UDim2.new(1, 0, 0.2, 0)
		lbl.BackgroundTransparency = 1
		lbl.TextScaled = true
		lbl.Font = font
		lbl.TextColor3 = color
		lbl.TextStrokeColor3 = strokeColor or Color3.new(0,0,0)
		lbl.TextStrokeTransparency = strokeTrans or 0.5
		lbl.LayoutOrder = layoutOrder
		lbl.Parent = container

		local constraint = Instance.new("UITextSizeConstraint")
		constraint.MaxTextSize = 35 
		constraint.MinTextSize = 2  
		constraint.Parent = lbl

		return lbl
	end

	-- Lock indicator (if locked)
	if isLocked then
		local lockLabel = createLabel("ðŸ”’ LOCKED", 0, Enum.Font.FredokaOne, Color3.fromRGB(255, 50, 50))
	end

	-- Timer
	local maxDuration = DESPAWN_TIME[rarity] or 60
	local tLabel = createLabel("â³ " .. maxDuration .. "s", 1, Enum.Font.FredokaOne, Color3.new(1,1,1), Color3.new(0,0,0), 0)

	-- Mutation
	if mutation then
		local mutText = "â­ " .. mutation .. " â­"
		local mutColor = Color3.new(1,1,1)
		local mc = MUTATION_COLORS[mutation]
		if mc and mc ~= "Rainbow" then mutColor = mc end

		local mLabel = createLabel(mutText, 2, Enum.Font.SourceSansBold, mutColor, Color3.new(0,0,0), 0)
		if mutation and MUTATION_COLORS[mutation] == "Rainbow" then
			animateRainbow(mLabel)
		end
	end

	-- Name
	local rarityColor = RARITY_COLORS[rarity] or Color3.new(1,1,1)
	local nameColor = Color3.new(1,1,1) -- Default white

	if rarityColor == "Rainbow" or rarityColor == "Split" then
		nameColor = Color3.new(1,1,1) -- White for special types
	elseif typeof(rarityColor) == "Color3" then
		nameColor = rarityColor
	end

	local nLabel = createLabel(brainrot.Name, 3, Enum.Font.SourceSansBold, nameColor)
	if rarityColor == "Rainbow" then 
		animateRainbow(nLabel) 
	end

	-- Rarity
	local rarityTextColor = Color3.new(1,1,1) -- Default white

	if rarityColor == "Rainbow" then
		rarityTextColor = Color3.new(1,1,1) -- White, will be animated
	elseif rarityColor == "Split" then
		rarityTextColor = Color3.new(1,0,0) -- Red for Split
	elseif typeof(rarityColor) == "Color3" then
		rarityTextColor = rarityColor
	end

	local rLabel = createLabel(rarity, 4, Enum.Font.SourceSansBold, rarityTextColor)

	if rarityColor == "Rainbow" then
		animateRainbow(rLabel)
	elseif rarityColor == "Split" then
		-- Name is green, rarity is red for Split
		nLabel.TextColor3 = Color3.new(0,1,0)
		rLabel.TextColor3 = Color3.new(1,0,0) 
	end

	-- Timer logic
	task.spawn(function()
		local startTime = os.time()
		local lastTimeLeft = maxDuration 

		while brainrot and brainrot.Parent do
			local elapsed = os.time() - startTime
			local timeLeft = maxDuration - elapsed
			if timeLeft < 0 then timeLeft = 0 end

			if timeLeft ~= lastTimeLeft then
				tLabel.Text = "â³ " .. timeLeft .. "s"
				lastTimeLeft = timeLeft

				if timeLeft <= 10 then
					tLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
				else
					tLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
				end
			end

			if timeLeft <= 0 then break end
			task.wait(0.1)
		end
	end)
end

local function enableCollisionDetection(brainrot)
	local rootPart = brainrot:FindFirstChild("RootPart") or brainrot.PrimaryPart or brainrot:FindFirstChildWhichIsA("BasePart")
	if not rootPart then
		warn("âš ï¸ No RootPart found for " .. brainrot.Name)
		return
	end

	for _, descendant in pairs(brainrot:GetDescendants()) do
		if descendant:IsA("BasePart") then
			descendant.CanTouch = true
			if descendant ~= rootPart then
				local weld = Instance.new("WeldConstraint")
				weld.Part0 = rootPart
				weld.Part1 = descendant
				weld.Parent = descendant
			end
		end
	end
end

local function makeBrainrotWander(brainrot, speed)
	task.spawn(function()
		local rootPart = brainrot:FindFirstChild("RootPart") or brainrot.PrimaryPart
		if not rootPart then return end

		local bodyVelocity = Instance.new("BodyVelocity")
		bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
		bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		bodyVelocity.Parent = rootPart

		local bodyGyro = Instance.new("BodyGyro")
		bodyGyro.MaxTorque = Vector3.new(500000, 500000, 500000) 
		bodyGyro.P = 25000 
		bodyGyro.D = 1000  
		bodyGyro.Parent = rootPart

		local WADDLE_SPEED = 18    
		local WADDLE_AMOUNT = 0.3 

		while brainrot and brainrot.Parent do
			local randomAngle = math.random() * math.pi * 2
			local randomDistance = math.random(30, 80)

			local currentPos = rootPart.Position
			local offsetX = math.cos(randomAngle) * randomDistance
			local offsetZ = math.sin(randomAngle) * randomDistance

			local destinationX = currentPos.X + offsetX
			local destinationZ = currentPos.Z + offsetZ

			local destDX = destinationX - PLATFORM_CENTER_X
			local destDZ = destinationZ - PLATFORM_CENTER_Z
			local destDistance = math.sqrt(destDX * destDX + destDZ * destDZ)

			if destDistance > (PLATFORM_RADIUS - 15) then
				destinationX = currentPos.X - offsetX
				destinationZ = currentPos.Z - offsetZ
			end

			local destination = Vector3.new(destinationX, PLATFORM_Y + 3, destinationZ)
			local moveDuration = randomDistance / speed
			local startTime = tick()

			while tick() - startTime < moveDuration and brainrot and brainrot.Parent do
				currentPos = rootPart.Position
				local direction = (destination - currentPos) * Vector3.new(1, 0, 1)

				if direction.Magnitude > 3 then
					direction = direction.Unit * speed
					bodyVelocity.Velocity = Vector3.new(direction.X, 0, direction.Z)

					local currentTime = tick()
					local wobbleZ = math.sin(currentTime * WADDLE_SPEED) * WADDLE_AMOUNT
					local lookPos = currentPos + direction
					local baseCFrame = CFrame.new(currentPos, Vector3.new(lookPos.X, currentPos.Y, lookPos.Z))

					bodyGyro.CFrame = baseCFrame * CFrame.Angles(-0.1, 0, wobbleZ)
				else
					break 
				end
				task.wait(0.05)
			end
		end
	end)
end

local function removeBrainrot(brainrot)
	for i, tracked in ipairs(activeBrainrots) do
		if tracked == brainrot then
			table.remove(activeBrainrots, i)
			break
		end
	end
	if brainrot and brainrot.Parent then brainrot:Destroy() end
end

local function scheduleDespawn(brainrot)
	local rarity = brainrot:GetAttribute("Rarity") or "Common"
	local waitTime = DESPAWN_TIME[rarity] or 60

	task.delay(waitTime, function() removeBrainrot(brainrot) end)
end

local function spawnbrainrot()
	if #activeBrainrots >= MAX_BRAINROTS then
		print("âš ï¸ Brainrot cap reached (" .. MAX_BRAINROTS .. "), skipping spawn")
		return
	end

	local basicrarity = "Common"
	local randomnum = math.random(1, 1000000)
	if randomnum <= 850000  then basicrarity = "Common"
	elseif randomnum <= 950000 then basicrarity = "Rare"
	elseif randomnum <= 975000  then basicrarity = "Epic"
	elseif randomnum <=990000 then basicrarity = "Legendary"
	elseif randomnum <= 999000 then basicrarity = "Mythic"
	elseif randomnum <= 999900 then basicrarity = "Brainrot God"
	elseif randomnum <= 9999900 then basicrarity = "Secret"
	else basicrarity = "OG" end

	local validbrainrotlist = {}
	for i, brainrot in pairs(brainrots) do
		if brainrot:GetAttribute("Rarity") == basicrarity then
			table.insert(validbrainrotlist, brainrot)
		end
	end

	if #validbrainrotlist == 0 then return end 

	local brainrot = validbrainrotlist[math.random(1, #validbrainrotlist)]:Clone()

	local mutation = getMutation()
	if mutation then
		brainrot:SetAttribute("Mutation", mutation)
		brainrot:SetAttribute("MutationMult",MUTATION_MULTIPLIERS[mutation])
	end

	-- Set rebirth requirement (client will handle locking)
	local requirement = RARITY_REQUIREMENTS[basicrarity] or 0
	brainrot:SetAttribute("RebirthRequirement", requirement)
	brainrot:SetAttribute("IsLocked", false) -- Client will set this properly

	local spawnPosition = getValidSpawnPosition()
	if brainrot:IsA("Model") then
		brainrot:PivotTo(CFrame.new(spawnPosition))
	else
		brainrot.Position = spawnPosition
	end

	brainrot.Parent = workspace
	table.insert(activeBrainrots, brainrot)

	enableCollisionDetection(brainrot)

	-- Apply mutation visuals (client handles grayscale for locks)
	if mutation then
		         local limited = WeatherSystem.LIMITED_VISUALS[mutation]
		         if limited then
		              applyLimitedMutationVisuals(brainrot, mutation)
		          else
		              applyMutationVisuals(brainrot, mutation)  -- Gold/Diamond/Rainbow
		           end
		      end

	addNameTag(brainrot)

	local rarity = brainrot:GetAttribute("Rarity")
	local speed = RARITY_SPEEDS[rarity]

	if not speed then
		warn("âš ï¸ Unknown rarity '" .. tostring(rarity) .. "' for " .. brainrot.Name .. " - using default speed of 24")
		speed = 24
	end

	print("ðŸŒ Speed for " .. brainrot.Name .. " (Rarity: '" .. rarity .. "'): " .. speed)

	makeBrainrotWander(brainrot, speed)
	scheduleDespawn(brainrot)
	print("ðŸŽ¯ Spawned: " .. brainrot.Name .. " (" .. basicrarity .. ")" .. (requirement > 0 and " ðŸ”’" or ""))
end

event.OnServerEvent:Connect(spawnbrainrot)

local function isDeveloper(player)
	if RunService:IsStudio() then return true end
	return player.UserId == game.CreatorId or player.UserId == 10378926133
end

spawnSpecificEvent.OnServerEvent:Connect(function(player, brainrotName)
	if not isDeveloper(player) then return end
	if #activeBrainrots >= MAX_BRAINROTS then return end

	for _, brainrot in pairs(brainrots) do
		if brainrot.Name:lower() == brainrotName:lower() then
			local clone = brainrot:Clone()
			local mutation = getMutation()
			if mutation then clone:SetAttribute("Mutation", mutation) end

			local rarity = clone:GetAttribute("Rarity") or "Common"
			local requirement = RARITY_REQUIREMENTS[rarity] or 0
			clone:SetAttribute("RebirthRequirement", requirement)
			clone:SetAttribute("IsLocked", requirement > 0)

			local spawnPosition = getValidSpawnPosition()
			if clone:IsA("Model") then clone:PivotTo(CFrame.new(spawnPosition))
			else clone.Position = spawnPosition end

			clone.Parent = workspace
			table.insert(activeBrainrots, clone)
			enableCollisionDetection(clone)

			if clone:GetAttribute("IsLocked") then
				applyMonochromeFilter(clone)
			elseif mutation then
				applyMutationVisuals(clone, mutation)
			end

			addNameTag(clone)

			local speed = RARITY_SPEEDS[rarity] or 8
			makeBrainrotWander(clone, speed)
			scheduleDespawn(clone)
			return
		end
	end
end)

if AUTO_SPAWN_ENABLED then
	task.spawn(function()
		print("ðŸ”„ Auto-spawn system started!")
		while true do
			task.wait(AUTO_SPAWN_INTERVAL)
			spawnbrainrot()
		end
	end)
end

print("âœ… Spawning System loaded with auto-spawn and rebirth locks!")


------------------------------------------------------------
-- PATH: ServerScriptService.CarryUpgrade
-- TYPE: Script
------------------------------------------------------------
-- Put this in ServerScriptService
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Create RemoteEvent if it doesn't exist
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local upgradeEvent = remoteEvents:FindFirstChild("UpgradeBrainrotCapacity")
if not upgradeEvent then
	upgradeEvent = Instance.new("RemoteEvent")
	upgradeEvent.Name = "UpgradeBrainrotCapacity"
	upgradeEvent.Parent = remoteEvents
end

-- Upgrade costs (increases with each level)
local BASE_COST = 500,000
local COST_MULTIPLIER = 50

-- Calculate upgrade cost based on current capacity
local function calculateUpgradeCost(currentCapacity)
	return math.floor(BASE_COST * (COST_MULTIPLIER ^ (currentCapacity - 1)))
end

-- Initialize player data
local function setupPlayer(player)
	-- Set default capacity if not already set
	if not player:GetAttribute("BrainrotCapacity") then
		player:SetAttribute("BrainrotCapacity", 1)
	end

	-- Set initial upgrade cost
	local currentCapacity = player:GetAttribute("BrainrotCapacity")
	player:SetAttribute("NextUpgradeCost", calculateUpgradeCost(currentCapacity))

	print("ðŸ“¦ " .. player.Name .. " initialized with capacity: " .. currentCapacity)
end

-- Handle upgrade request
upgradeEvent.OnServerEvent:Connect(function(player)
	local currentCapacity = player:GetAttribute("BrainrotCapacity") or 1
	local upgradeCost = player:GetAttribute("NextUpgradeCost") or 100

	-- Check if player has enough money
	local moneyRaw = player:FindFirstChild("MoneyRaw")
	if not moneyRaw then
		upgradeEvent:FireClient(player, false, "Money system not found!")
		return
	end

	-- Check if player can afford it
	if moneyRaw.Value < upgradeCost then
		upgradeEvent:FireClient(player, false, "Not enough money! Need $" .. upgradeCost)
		return
	end

	-- Check max capacity (optional)
	local MAX_CAPACITY = 10
	if currentCapacity >= MAX_CAPACITY then
		upgradeEvent:FireClient(player, false, "Maximum capacity reached!")
		return
	end

	-- Deduct money
	moneyRaw.Value = moneyRaw.Value - upgradeCost

	-- Increase capacity
	local newCapacity = currentCapacity + 1
	player:SetAttribute("BrainrotCapacity", newCapacity)

	-- Calculate new upgrade cost
	local newCost = calculateUpgradeCost(newCapacity)
	player:SetAttribute("NextUpgradeCost", newCost)

	-- Send success message
	upgradeEvent:FireClient(player, true, "Upgraded to capacity: " .. newCapacity)

	print("ðŸ’° " .. player.Name .. " upgraded capacity to " .. newCapacity .. " for $" .. upgradeCost)
end)

-- Setup existing players
for _, player in pairs(Players:GetPlayers()) do
	setupPlayer(player)
end

-- Setup new players
Players.PlayerAdded:Connect(setupPlayer)

print("âœ… Brainrot Capacity Upgrade System loaded!")


------------------------------------------------------------
-- PATH: ServerScriptService.MoneyPlaceHolder
-- TYPE: Script
------------------------------------------------------------
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local NumberFormat = require(ReplicatedStorage:WaitForChild("NumberFormat"))

local function setupLeaderstats(player)
	-- leaderstats folder
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then
		leaderstats = Instance.new("Folder")
		leaderstats.Name = "leaderstats"
		leaderstats.Parent = player
	end

	-- REAL money (not on leaderboard)
	local moneyRaw = player:FindFirstChild("MoneyRaw")
	if not moneyRaw then
		moneyRaw = Instance.new("NumberValue")
		moneyRaw.Name = "MoneyRaw"
		moneyRaw.Value = 0
		moneyRaw.Parent = player -- IMPORTANT: not inside leaderstats
	end

	-- DISPLAY money (on leaderboard)
	local moneyDisplay = leaderstats:FindFirstChild("Money")
	if not moneyDisplay then
		moneyDisplay = Instance.new("StringValue")
		moneyDisplay.Name = "Money" -- this is what the board shows
		moneyDisplay.Value = "0"
		moneyDisplay.Parent = leaderstats
	end

	local function updateDisplay()
		moneyDisplay.Value = NumberFormat.format(moneyRaw.Value)
	end

	updateDisplay()
	moneyRaw:GetPropertyChangedSignal("Value"):Connect(updateDisplay)

	-- Skyscraper Height
	local skyscraperHeight = leaderstats:FindFirstChild("Skyscraper Height")
	if not skyscraperHeight then
		skyscraperHeight = Instance.new("NumberValue")
		skyscraperHeight.Name = "Skyscraper Height"
		skyscraperHeight.Value = 1
		skyscraperHeight.Parent = leaderstats
	end

	-- Rebirths
	local rebirths = leaderstats:FindFirstChild("Rebirths")
	if not rebirths then
		rebirths = Instance.new("NumberValue")
		rebirths.Name = "Rebirths"
		rebirths.Value = 0
		rebirths.Parent = leaderstats
	end
end

Players.PlayerAdded:Connect(setupLeaderstats)
for _, player in ipairs(Players:GetPlayers()) do
	setupLeaderstats(player)
end


------------------------------------------------------------
-- PATH: ServerScriptService.bigrahim
-- TYPE: Script
------------------------------------------------------------
-- ServerScriptService/BrainrotSlotSystem
print("ðŸš€ BrainrotSlotSystem starting...")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- Validate tools against this folder
local BrainrotPackFolder = ReplicatedStorage:WaitForChild("Brainrot pack1", 10)
if not BrainrotPackFolder then
	warn("CRITICAL: 'Brainrot pack1' folder not found in ReplicatedStorage!")
end
local economyevent = game.ReplicatedStorage.RemoteEvents.EconomyEvent
-- ==========================================================
-- CONFIG
-- ==========================================================
local BASES_FOLDER_NAME = "BrainrotBases"
local TweenService = game:GetService("TweenService")
-- Rarity colours â€” same as spawning system
local RARITY_COLORS = {
	["Common"]       = Color3.fromRGB(0, 255, 0),
	["Rare"]         = Color3.fromRGB(0, 100, 255),
	["Epic"]         = Color3.fromRGB(150, 0, 255),
	["Legendary"]    = Color3.fromRGB(255, 255, 0),
	["Mythic"]       = Color3.fromRGB(255, 0, 0),
	["Brainrot God"] = "Rainbow",
	["Secret"]       = Color3.fromRGB(0, 0, 0),
	["OG"]           = "Split",
}

-- Mutation colors (matches spawning system)
local MUTATION_COLORS = {
	["Gold"]        = Color3.fromRGB(255, 215, 0),
	["Diamond"]     = Color3.fromRGB(185, 242, 255),
	["Rainbow"]     = "Rainbow",
	-- Limited (weather-gated)
	["Bloodrot"]    = Color3.fromRGB(100, 0, 0),
	["Candy"]       = Color3.fromRGB(255, 105, 180),
	["Lava"]        = Color3.fromRGB(255, 80, 0),
	["Galaxy"]      = Color3.fromRGB(138, 43, 226),
	["Yin-Yang"]    = "YinYang",
	["Radioactive"] = Color3.fromRGB(0, 255, 50),
}

-- Mutation multipliers for income (matches spawning system)
local MUTATION_MULTIPLIERS = {
	["Gold"]        = 1.25,
	["Diamond"]     = 1.5,
	["Rainbow"]     = 10,
	-- Limited
	["Bloodrot"]    = 2.0,
	["Candy"]       = 4.0,
	["Lava"]        = 6.0,
	["Galaxy"]      = 7.0,
	["Yin-Yang"]    = 7.5,
	["Radioactive"] = 8.5,
}

-- Income per second keyed by exact tool name (codev's table â€” most complete)
local BRAINROT_INCOME = {
	-- COMMON
	["Noobini Pizzanini"] = 1,
	["Lirili Larila"] = 3,
	["Tim Cheese"] = 5,
	["FluriFlura"] = 7,
	["Talpa Di Fero"] = 9,
	["Svinina Bombardino"] = 10,
	["Noobini Santanini"] = 11,
	["Racooni Jandelini"] = 12,
	["Pipi Kiwi"] = 13,
	["Tartaragno"] = 13,
	["Pipi Corni"] = 14,
	["Trippi Troppi"] = 15,
	["Gangster Footera"] = 30,
	["Bandito Bobritto"] = 35,
	["Boneca Ambalabu"] = 40,
	["Cacto Hipopotamo"] = 50,
	["Ta Ta Ta Ta Sahur"] = 55,
	["Tric Trac Baraboom"] = 65,
	["Frogo Elfo"] = 67,
	["Pipi Avocado"] = 70,
	["Pinealotto Fruttarino"] = 75,
	["Cappuccino Assassino"] = 75,
	["Bandito Axolito"] = 90,
	["Brr Brr Patapim"] = 100,
	["Avocadini Antilopini"] = 115,
	["Trulimero Trulicina"] = 125,
	["Bambini Crostini"] = 135,
	["Malame Amarele"] = 140,
	["Bananita Dolphinita"] = 150,
	["Perochello Lemonchello"] = 160,
	["Brri Brri Bicus Dicus Bombicus"] = 175,
	["Avocadini Guffo"] = 225,
	["Ti Ti Ti Sahur"] = 225,
	["Mangolini Parrocini"] = 235,
	["Frogatto Piratto"] = 240,
	["Salamino Penguino"] = 250,
	["Doi Doi Do"] = 260,
	["Penguin Tree"] = 270,
	["Wombo Rollo"] = 275,
	["Penguino Cocosino"] = 300,
	["Mummio Rappito"] = 325,
	["Chimpanzini Bananini"] = 300,
	["Tirilikalika Tirilikalako"] = 450,
	["Ballerina Cappuccina"] = 500,
	["Burbaloni Loliloli"] = 600,
	["Chef Crabracadabra"] = 600,
	["Lionel Cactuseli"] = 650,
	["Glorbo Fruttodrillo"] = 750,
	["Quivoli Ameleoni"] = 900,
	["Blueberrini Octopusini"] = 1000,
	["Caramello Filtrello"] = 1000,
	["Pipi Potato"] = 1100,
	["Strawberrelli Flamingelli"] = 1100,
	["Cocosini Mama"] = 1200,
	["Pandaccini Bananini"] = 1250,
	["Quackula"] = 1200,
	["Pi Pi Watermelon"] = 1300,
	["Signore Carapace"] = 1300,
	["Sigma Boy"] = 1350,
	["Chocco Bunny"] = 1400,
	["Puffaball"] = 1500,
	["Sigma Girl"] = 1800,
	["Buho de Fuego"] = 1800,
	["Frigo Camelo"] = 1900,
	["Orangutini Ananassini"] = 2000,
	["Rhino Toasterino"] = 2100,
	["Bombardiro Crocodilo"] = 2500,
	["Spioniro Golubiro"] = 3500,
	["Bangangini Gusini"] = 5000,
	["Zibra Zubra Zibralini"] = 6000,
	["Tigrilini Watermelini"] = 6500,
	["Avocadorilla"] = 7000,
	["Cavallo Virtuoso"] = 7500,
	["Gorillo Subwoofero"] = 7700,
	["Gorillo Watermelondrillo"] = 8000,
	["Stoppo Luminino"] = 8000,
	["Ganganzelli Trulala"] = 9000,
	["Lerulerulerule"] = 8700,
	["Tob Tobi Tobi"] = 8500,
	["Te Te Te Sahur"] = 9500,
	["Rhino Helicopterino"] = 11000,
	["Magi Ribbitini"] = 11500,
	["Tracoducotulu Delapeladustuz"] = 12000,
	["Jingle Jingle Sahur"] = 12200,
	["Los Noobinis"] = 12500,
	["Cachorrito Melonito"] = 13000,
	["Carloo"] = 13500,
	["Elefanto Frigo"] = 14000,
	["Carrotini Brainini"] = 15000,
	["Centrucci Nuclucci"] = 15500,
	["Jacko Spaventosa"] = 16200,
	["Toiletto Focaccino"] = 16000,
	["Bananito Bandito"] = 16500,
	["Tree Tree Tree Sahur"] = 17000,
	["Cocofanto Elefanto"] = 17500,
	["Antonio"] = 18500,
	["Girafa Celestre"] = 20000,
	["Gattatino Neonino"] = 35000,
	["Gattatino Nyanino"] = 35000,
	["Chihuanini Taconini"] = 45000,
	["Matteo"] = 50000,
	["Tralalero Tralala"] = 50000,
	["Los Crocodillitos"] = 55000,
	["Tigroligre Frutonni"] = 60000,
	["Espresso Signora"] = 70000,
	["Odin Din Din Dun"] = 75000,
	["Statutino Libertino"] = 75000,
	["Tipi Topi Taco"] = 75000,
	["Alessio"] = 85000,
	["Tralalita Tralala"] = 100000,
	["Tukanno Bananno"] = 100000,
	["Orcalero Orcala"] = 100000,
	["Extinct Ballerina"] = 125000,
	["Trenostruzzo Turbo 3000"] = 150000,
	["Urubini Flamenguini"] = 150000,
	["Capi Taco"] = 155000,
	["Gattito Tacoto"] = 160000,
	["Trippi Troppi Troppa Trippa"] = 175000,
	["Ballerino Lololo"] = 200000,
	["Bulbito Bandito Traktorito"] = 205000,
	["Los Tungtungtungcitos"] = 210000,
	["Ballerina Peppermintina"] = 215000,
	["Pakrahmatmamat"] = 215000,
	["Los Bombinitos"] = 220000,
	["Bombardini Tortinii"] = 225000,
	["Piccione Macchina"] = 225000,
	["Brr es Teh Patipum"] = 225000,
	["Tractoro Dinosauro"] = 230000,
	["Los Orcalitos"] = 235000,
	["Corn Corn Corn Sahur"] = 250000,
	["Squalanana"] = 250000,
	["Dug Dug Dug"] = 255000,
	["Yeti Claus"] = 257500,
	["Ginger Globo"] = 257500,
	["Los Tipi Tacos"] = 260000,
	["Frio Ninja"] = 265000,
	["Ginger Cisterna"] = 293500,
	["Pop Pop Sahur"] = 295000,
	["La Vacca Saturno Saturnita"] = 300000,
	["Los Matteos"] = 300000,
	["Bisonte Giuppitere"] = 300000,
	["Jackorilla"] = 315000,
	["Sammyni Spyderini"] = 325000,
	["Chimpanzini Spiderini"] = 325000,
	["Torrtuginni Dragonfrutini"] = 350000,
	["Unclito Samito"] = 350000,
	["Dul Dul Dul"] = 375000,
	["Blackhole Goat"] = 400000,
	["Chachechi"] = 400000,
	["Guerriro Digitale"] = 425000,
	["Agarrini la Palini"] = 425000,
	["Extinct Tralalero"] = 450000,
	["Fragola La La La"] = 450000,
	["Los Spyderinis"] = 450000,
	["La Cucaracha"] = 475000,
	["Los Tortus"] = 500000,
	["Los Tralaleritos"] = 750000,
	["Extinct Matteo"] = 500000,
	["Vulturino Skeletono"] = 500000,
	["Boatito Auratito"] = 525000,
	["Karkerkar Kurkur"] = 550000,
	["Orcalita Orcala"] = 575000,
	["Piccionetta Macchina"] = 600000,
	["Las Tralaleritas"] = 650000,
	["Job Job Job Sahur"] = 700000,
	["Las Vaquitas Saturnitas"] = 750000,
	["Los Combinasionas"] = 800000,
	["Trenzostruzzo Turbo 4000"] = 850000,
	["La Grande Combinasion"] = 10000000,
	["Graipuss Medussi"] = 1000000,
	["Anpali Babel"] = 1200000,
	["Mastodontico Telepiedone"] = 1200000,
	["Noo My Hotspot"] = 1500000,
	["La Sahur Combinasion"] = 2000000,
	["Nooo My Hotspot"] = 2000000,
	["La Karkerkar Combinasion"] = 17500000,
	["Pot Hotspot"] = 2500000,
	["Esok Sekolah"] = 3000000,
	["Chicleteira Bicicleteira"] = 3500000,
	["67"] = 7500000,
	["Los Nooo My Hotspotsitos"] = 5500000,
	["Nuclearo Dinossauro"] = 15000000,
	["Las Sis"] = 17500000,
	["Celularcini Viciosini"] = 22500000,
	["Los Bros"] = 24000000,
	["Tralaledon"] = 27500000,
	["La Esok Sekolah"] = 30000000,
	["Tang Tang Kelentang"] = 33500000,
	["Ketupat Kepat"] = 35000000,
	["Tictac Sahur"] = 37500000,
	["La Secret Combinasion"] = 125000000,
	["Ketchuru and Musturu"] = 42500000,
	["Garama and Madundung"] = 50000000,
	["Spaghetti Tualetti"] = 60000000,
	["Los Orcaleritos"] = 235000000,
	["Dragon Cannelloni"] = 200000000,
	-- OG
	["Strawberry Elephant"] = 350000000,
}

-- ==========================================================
-- SETUP
-- ==========================================================
local BASES_FOLDER = Workspace:WaitForChild(BASES_FOLDER_NAME, 5)
if not BASES_FOLDER then
	warn("âŒ BrainrotBases folder NOT FOUND in Workspace!")
	return
end
print("âœ“ Found BrainrotBases folder")

-- Track assigned bases
local assignedBases = {} -- [playerName] = baseModel
local availableBases = {} -- Queue of unassigned bases

-- Initialize available bases list
for _, base in pairs(BASES_FOLDER:GetChildren()) do
	if base:IsA("Model") then
		local ownerValue = base:FindFirstChild("Owner")
		if ownerValue and ownerValue:IsA("StringValue") and ownerValue.Value == "" then
			table.insert(availableBases, base)
		end
	end
end

print("ðŸ“Š Found " .. #availableBases .. " available bases for assignment")

-- Function to assign a base to a player
local function assignBaseToPlayer(player)
	-- Check if player already has a base
	if assignedBases[player.Name] then
		print("âœ“ " .. player.Name .. " already has base: " .. assignedBases[player.Name].Name)
		return assignedBases[player.Name]
	end

	-- Find an available base
	if #availableBases == 0 then
		warn("âš ï¸ No available bases to assign to " .. player.Name)
		return nil
	end

	-- Assign the first available base
	local base = table.remove(availableBases, 1)
	local ownerValue = base:FindFirstChild("Owner")

	if ownerValue and ownerValue:IsA("StringValue") then
		ownerValue.Value = player.Name
		assignedBases[player.Name] = base

		-- Set the spawn location
		local spawnLocation = base:FindFirstChild("SpawnLocation")
		if spawnLocation and spawnLocation:IsA("SpawnLocation") then
			-- Configure spawn location
			spawnLocation.Enabled = true
			spawnLocation.Duration = 0
			spawnLocation.Neutral = false
			spawnLocation.AllowTeamChangeOnTouch = false

			-- Set this as the player's respawn location
			player.RespawnLocation = spawnLocation

			print("âœ… Assigned " .. base.Name .. " to " .. player.Name .. " with spawn point")

			-- Wait for character to load, then teleport
			if player.Character then
				local humanoidRootPart = player.Character:WaitForChild("HumanoidRootPart", 5)
				if humanoidRootPart then
					humanoidRootPart.CFrame = spawnLocation.CFrame + Vector3.new(0, 3, 0)
				end
			else
				-- If character hasn't loaded yet, wait for it
				player.CharacterAdded:Connect(function(character)
					local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
					if humanoidRootPart then
						humanoidRootPart.CFrame = spawnLocation.CFrame + Vector3.new(0, 3, 0)
					end
				end)
			end
		else
			warn("âš ï¸ No SpawnLocation found in " .. base.Name)
		end

		return base
	end

	return nil
end

-- Function to unassign a base when player leaves
local function unassignBase(player)
	local base = assignedBases[player.Name]
	if base then
		local ownerValue = base:FindFirstChild("Owner")
		if ownerValue and ownerValue:IsA("StringValue") then
			ownerValue.Value = ""
		end

		-- Clear player's respawn location
		player.RespawnLocation = nil

		-- Return base to available pool
		table.insert(availableBases, base)
		assignedBases[player.Name] = nil

		print("ðŸ”“ Unassigned " .. base.Name .. " from " .. player.Name)
	end
end

-- Auto-assign bases when players join
Players.PlayerAdded:Connect(function(player)
	print("ðŸ‘¤ Player joined: " .. player.Name)
	assignBaseToPlayer(player)
end)

-- Clean up when players leave
Players.PlayerRemoving:Connect(function(player)
	print("ðŸ‘‹ Player leaving: " .. player.Name)
	unassignBase(player)
end)

-- Assign bases to any players already in the game (for testing in Studio)
for _, player in pairs(Players:GetPlayers()) do
	assignBaseToPlayer(player)
end

local remoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not remoteEvents then
	remoteEvents = Instance.new("Folder")
	remoteEvents.Name = "RemoteEvents"
	remoteEvents.Parent = ReplicatedStorage
end

local placeBrainrotEvent = remoteEvents:FindFirstChild("PlaceBrainrotEvent")
if not placeBrainrotEvent then
	placeBrainrotEvent = Instance.new("RemoteEvent")
	placeBrainrotEvent.Name = "PlaceBrainrotEvent"
	placeBrainrotEvent.Parent = remoteEvents
end

local collectIncomeEvent = remoteEvents:FindFirstChild("CollectIncomeEvent")
if not collectIncomeEvent then
	collectIncomeEvent = Instance.new("RemoteEvent")
	collectIncomeEvent.Name = "CollectIncomeEvent"
	collectIncomeEvent.Parent = remoteEvents
end

-- ==========================================================
-- SHARED STATE
-- slotData[slot]      â€“ income tracking per occupied slot
-- incomeLabels[slot]  â€“ direct reference to the TextLabel on that slot's
--                        CollectTrigger billboard (created during the scan,
--                        before any brainrot is placed, so we never have to
--                        walk the instance tree again)
-- ==========================================================
local slotData      = {}
local incomeLabels  = {}   -- [slot Model] = TextLabel

-- ==========================================================
-- BILLBOARD HELPERS  (colour rules match the spawning system)
-- ==========================================================
local function animateRainbow(textLabel)
	task.spawn(function()
		local hue = 0
		while textLabel and textLabel.Parent do
			hue = (hue + 0.01) % 1
			textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
			task.wait(0.05)
		end
	end)
end

-- Apply rainbow effect to all parts in a model
local function animateRainbowModel(model)
	task.spawn(function()
		local hue = 0
		local parts = {}

		-- Collect all parts
		for _, descendant in pairs(model:GetDescendants()) do
			if descendant:IsA("BasePart") then
				table.insert(parts, descendant)
			end
		end

		while model and model.Parent do
			hue = (hue + 0.01) % 1
			local rainbowColor = Color3.fromHSV(hue, 1, 1)

			for _, part in pairs(parts) do
				if part and part.Parent then
					part.Color = rainbowColor
				end
			end

			task.wait(0.05)
		end
	end)
end

local function animateGalaxy(model)
	task.spawn(function()
		local parts = {}
		for _, d in pairs(model:GetDescendants()) do
			if d:IsA("BasePart") then table.insert(parts, d) end
		end
		local t = 0
		while model and model.Parent do
			t += 0.02
			local brightness = 0.5 + 0.5 * math.sin(t)
			local col = Color3.fromRGB(
				math.floor(75  + 63  * brightness),
				0,
				math.floor(130 + 100 * brightness)
			)
			for _, p in pairs(parts) do
				if p and p.Parent then p.Color = col end
			end
			task.wait(0.05)
		end
	end)
end

local function animateYinYang(model)
	task.spawn(function()
		local parts = {}
		for _, d in pairs(model:GetDescendants()) do
			if d:IsA("BasePart") then table.insert(parts, d) end
		end
		local flip = false
		while model and model.Parent do
			flip = not flip
			local col = flip and Color3.new(1, 1, 1) or Color3.new(0, 0, 0)
			for _, p in pairs(parts) do
				if p and p.Parent then p.Color = col end
			end
			task.wait(0.5)
		end
	end)
end

local function animateRadioactive(model)
	task.spawn(function()
		local parts = {}
		for _, d in pairs(model:GetDescendants()) do
			if d:IsA("BasePart") then table.insert(parts, d) end
		end
		local t = 0
		while model and model.Parent do
			t += 0.08
			local brightness = 0.5 + 0.5 * math.sin(t)
			local g = math.floor(150 + 105 * brightness)
			local col = Color3.fromRGB(0, g, 0)
			for _, p in pairs(parts) do
				if p and p.Parent then p.Color = col end
			end
			task.wait(0.05)
		end
	end)
end

-- Apply mutation visual effects to the brainrot model
local function applyMutationVisuals(brainrotModel, mutation)
	if not mutation then return end

	-- Helper: strip SurfaceAppearance so color changes actually apply
	local function stripAndColor(part, color, material, reflectance)
		if part:IsA("BasePart") then
			local sa = part:FindFirstChildOfClass("SurfaceAppearance")
			if sa then sa:Destroy() end
			if color then part.Color = color end
			if material then part.Material = material end
			if reflectance then part.Reflectance = reflectance end
		elseif part:IsA("SpecialMesh") then
			part.TextureId = ""
		end
	end

	-- Strip SurfaceAppearances first for all animated mutations
	if mutation == "Rainbow" or mutation == "Galaxy" or mutation == "Yin-Yang" or mutation == "Radioactive" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			local sa = d:FindFirstChildOfClass("SurfaceAppearance")
			if sa then sa:Destroy() end
			if d:IsA("SpecialMesh") then d.TextureId = "" end
		end
	end

	if mutation == "Rainbow" then
		animateRainbowModel(brainrotModel)

	elseif mutation == "Gold" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(255, 215, 0), Enum.Material.SmoothPlastic, nil)
			if d:IsA("SpecialMesh") then d.TextureId = "" end
		end

	elseif mutation == "Diamond" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(185, 242, 255), Enum.Material.SmoothPlastic, 0.3)
			if d:IsA("SpecialMesh") then d.TextureId = "" end
		end

	elseif mutation == "Bloodrot" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(100, 0, 0), Enum.Material.SmoothPlastic, nil)
		end

	elseif mutation == "Candy" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(255, 105, 180), Enum.Material.SmoothPlastic, 0.1)
		end

	elseif mutation == "Lava" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(255, 80, 0), Enum.Material.Neon, nil)
		end

	elseif mutation == "Galaxy" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(138, 43, 226), Enum.Material.Neon, nil)
		end
		animateGalaxy(brainrotModel)

	elseif mutation == "Yin-Yang" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.new(1, 1, 1), Enum.Material.SmoothPlastic, nil)
		end
		animateYinYang(brainrotModel)

	elseif mutation == "Radioactive" then
		for _, d in pairs(brainrotModel:GetDescendants()) do
			stripAndColor(d, Color3.fromRGB(0, 255, 50), Enum.Material.Neon, nil)
		end
		animateRadioactive(brainrotModel)
	end
end

local function getModelHeight(model)
	local _, size = model:GetBoundingBox()
	return size.Y
end

-- Nametag on the brainrot itself: Name / Rarity / Mutation (if any) / +$X/sec
-- Nametag on the brainrot itself: Name / Rarity / Mutation (if any) / +$X/sec
-- Modified to accept 'targetAdornee' (The Slot's DisplayPosition)
-- NEW: Separate prominent rarity display that's always visible
local function addRarityDisplay(brainrotModel, targetAdornee)
	local rarity = brainrotModel:GetAttribute("Rarity") or "Common"
	local modelHeight = getModelHeight(brainrotModel)

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "RarityDisplay"
	billboard.Adornee = targetAdornee
	billboard.Size = UDim2.new(6, 0, 1.5, 0)  -- Larger size
	billboard.StudsOffsetWorldSpace = Vector3.new(0, modelHeight + 4.5, 0)  -- Higher up
	billboard.AlwaysOnTop = true  -- Always visible
	billboard.MaxDistance = 500
	billboard.Parent = brainrotModel

	local rarityLabel = Instance.new("TextLabel")
	rarityLabel.Size = UDim2.new(1, 0, 1, 0)
	rarityLabel.BackgroundTransparency = 1
	rarityLabel.Text = "â­ " .. rarity .. " â­"
	rarityLabel.TextScaled = true
	rarityLabel.Font = Enum.Font.FredokaOne
	rarityLabel.TextStrokeTransparency = 0
	rarityLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	rarityLabel.Parent = billboard

	local constraint = Instance.new("UITextSizeConstraint")
	constraint.MaxTextSize = 40
	constraint.MinTextSize = 20
	constraint.Parent = rarityLabel

	-- Apply color
	local rarityColor = RARITY_COLORS[rarity] or Color3.fromRGB(255, 255, 255)
	if rarityColor == "Rainbow" then
		animateRainbow(rarityLabel)
	elseif rarityColor == "Split" then
		rarityLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
	else
		rarityLabel.TextColor3 = rarityColor
	end
end

-- Modified name tag (now without prominent rarity)
local function addSlotNameTag(brainrotModel, incomeRate, mutation, targetAdornee)
	local rarity = brainrotModel:GetAttribute("Rarity") or "Common"
	local modelHeight = getModelHeight(brainrotModel)
	local hasMutation = mutation ~= nil

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "NameTag"
	billboard.Adornee = targetAdornee 
	billboard.Size = UDim2.new(4, 0, hasMutation and 1.75 or 1.25, 0)
	billboard.StudsOffsetWorldSpace = Vector3.new(0, modelHeight + 2, 0)
	billboard.AlwaysOnTop = false
	billboard.MaxDistance = 400

	-- Name row
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, 0, hasMutation and 0.33 or 0.5, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = brainrotModel.Name
	nameLabel.TextSize = 14
	nameLabel.Font = Enum.Font.SourceSansBold
	nameLabel.TextStrokeTransparency = 0.5
	nameLabel.Parent = billboard

	-- Mutation row (if exists)
	local mutationLabel
	if hasMutation then
		mutationLabel = Instance.new("TextLabel")
		mutationLabel.Size = UDim2.new(1, 0, 0.33, 0)
		mutationLabel.Position = UDim2.new(0, 0, 0.33, 0)
		mutationLabel.BackgroundTransparency = 1
		mutationLabel.Text = "â­ " .. mutation .. " â­"
		mutationLabel.TextSize = 14
		mutationLabel.Font = Enum.Font.SourceSansBold
		mutationLabel.TextStrokeTransparency = 0.5
		mutationLabel.Parent = billboard
	end

	-- Income row
	local incomeLabel = Instance.new("TextLabel")
	incomeLabel.Size = UDim2.new(1, 0, hasMutation and 0.33 or 0.5, 0)
	incomeLabel.Position = UDim2.new(0, 0, hasMutation and 0.66 or 0.5, 0)
	incomeLabel.BackgroundTransparency = 1
	incomeLabel.Text = "+$" .. incomeRate .. "/sec"
	incomeLabel.TextSize = 14
	incomeLabel.Font = Enum.Font.SourceSansBold
	incomeLabel.TextStrokeTransparency = 0.5
	incomeLabel.Parent = billboard

	-- Apply colours
	local rarityColor = RARITY_COLORS[rarity] or Color3.fromRGB(255, 255, 255)
	if rarityColor == "Rainbow" then
		animateRainbow(nameLabel)
		animateRainbow(incomeLabel)
	elseif rarityColor == "Split" then
		nameLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
		incomeLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
	else
		nameLabel.TextColor3 = rarityColor
		incomeLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
	end

	if hasMutation and mutationLabel then
		local mutationColor = MUTATION_COLORS[mutation]
		if mutationColor == "Rainbow" then
			animateRainbow(mutationLabel)
		elseif mutationColor == "YinYang" then
			-- Alternate the label too
			task.spawn(function()
				local flip = false
				while mutationLabel and mutationLabel.Parent do
					flip = not flip
					mutationLabel.TextColor3 = flip and Color3.new(1,1,1) or Color3.new(0,0,0)
					task.wait(0.5)
				end
			end)
		elseif mutationColor then
			mutationLabel.TextColor3 = mutationColor
		end
	end

	billboard.Parent = brainrotModel 
end

-- "$0" billboard on the CollectTrigger.  Returns the TextLabel so we can
-- cache it and update cheaply every second.


-- ==========================================================
-- CORE LOGIC
-- ==========================================================
local function playerOwnsBase(player, slot)
	local base = slot.Parent
	if not base or not base:IsA("Model") then return false end
	local ownerValue = base:FindFirstChild("Owner")
	return ownerValue and ownerValue:IsA("StringValue") and ownerValue.Value == player.Name
end

-- Returns the tool only if it exists in Brainrot pack1
local function getEquippedBrainrot(player)
	if not player.Character then return nil end
	local tool = player.Character:FindFirstChildOfClass("Tool")
	if not tool or not BrainrotPackFolder then return nil end
	for _, item in pairs(BrainrotPackFolder:GetChildren()) do
		if item.Name == tool.Name then return tool end
	end
	return nil
end

-- PLACE  â€”  moves the tool into the slot (no clone, no destroy)
-- Helper to get Rebirths (Place this above the main function if you haven't already)
local function getRebirthMultiplier(player)
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats then
		local rebirths = leaderstats:FindFirstChild("Rebirths")
		if rebirths then
			-- Formula: 1x base + 0.5x per rebirth (e.g., 2 Rebirths = 2x income)
			return 1 + (rebirths.Value * 0.5) 
		end
	end
	return 1
end
-- Function to show ownership warning GUI with animation
local hideTask = nil 
local currentTween = nil 

local function showOwnershipWarning(player)
	local playerGui = player:WaitForChild("PlayerGui", 5)
	if not playerGui then return end

	local sg = playerGui:FindFirstChild("OwnershipGUI")
	if not sg then return end

	local f = sg:FindFirstChild("MainFrame")
	if not f then return end

	-- 1. CANCEL OLD TIMERS
	-- If the GUI is already waiting to go up, stop the timer so it stays down.
	if hideTask then
		task.cancel(hideTask)
		hideTask = nil
	end

	-- 2. STOP CURRENT MOTION
	if currentTween then
		currentTween:Cancel()
	end

	-- 3. RESET START POSITION (Only if hidden)
	if not sg.Enabled then
		sg.Enabled = true
		f.Position = UDim2.new(0.5, 0, -0.2, 0)
	end

	-- 4. DROP ANIMATION (TIGHTER ELASTIC)
	-- 0.8 seconds is the "sweet spot" for Elastic. 
	-- It snaps into place like a real spring.
	local dropInfo = TweenInfo.new(
		0.8, 
		Enum.EasingStyle.Elastic, 
		Enum.EasingDirection.Out
	)

	currentTween = TweenService:Create(f, dropInfo, {
		Position = UDim2.new(0.5, 0, 0.15, 0)
	})
	currentTween:Play()

	-- 5. WAIT & HIDE
	hideTask = task.spawn(function()
		-- CHANGED: Reduced wait time to 1.2 seconds (Stay on ground for less)
		task.wait(1.2)

		local upInfo = TweenInfo.new(
			0.4, -- Fast exit
			Enum.EasingStyle.Back, -- "Back" creates a nice anticipation effect
			Enum.EasingDirection.In
		)

		currentTween = TweenService:Create(f, upInfo, {
			Position = UDim2.new(0.5, 0, -0.2, 0)
		})
		currentTween:Play()
		currentTween.Completed:Wait()

		-- Fully hide
		sg.Enabled = false
		hideTask = nil
		currentTween = nil
	end)
end
-- THE MAIN FUNCTION
local function placeBrainrotOnSlot(player, slot)
	-- 1. Check Ownership
	if not playerOwnsBase(player, slot) then
		showOwnershipWarning(player)
		return false, "You don't own this base!"

	end

	local displayPart = slot:FindFirstChild("DisplayPosition")
	if not displayPart then
		return false, "Slot missing DisplayPosition!"
	end

	-- 2. DECIDE: Pickup or Place?
	local currentSlotData = slotData[slot]

	if currentSlotData then
		-- ==========================================
		--               PICKUP LOGIC
		-- ==========================================

		-- A. Auto-Collect Income (Don't lose money on pickup!)
		local timeElapsed = tick() - currentSlotData.lastUpdate
		local earned = math.floor(timeElapsed * currentSlotData.incomeRate)
		local totalToGive = currentSlotData.accumulatedIncome + earned

		if totalToGive > 0 then
			local leaderstats = player:FindFirstChild("leaderstats")
			local money = leaderstats and leaderstats:FindFirstChild("Money")
			if money then
				money.Value += totalToGive
				-- Update the visual label to $0
				if currentSlotData.incomeLabel then
					currentSlotData.incomeLabel.Text = "$0"
					currentSlotData.incomeLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
				end
				-- Optional: Fire client event for popup
				collectIncomeEvent:FireClient(player, true, "Collected on pickup!", totalToGive)
			end
		end

		-- B. Find the tool
		local brainrot = displayPart:FindFirstChildWhichIsA("Tool")
		if not brainrot then
			slotData[slot] = nil
			return false, "Glitch: Slot empty but data existed. Resetting."
		end

		-- C. Reset Tool Physics
		brainrot.Enabled = true
		for _, part in pairs(brainrot:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Anchored = false
				part.CanCollide = false 
			end
		end

		-- D. Give to Player
		brainrot.Parent = player.Character 

		-- E. Clean up Data
		local tag = brainrot:FindFirstChild("NameTag")
		if tag then tag:Destroy() end

		slotData[slot] = nil 

		slot:SetAttribute("HasBrainrot", nil)
		slot:SetAttribute("BrainrotName", nil)
		slot:SetAttribute("IncomeRate", nil)
		slot:SetAttribute("Mutation", nil)

		return true, "Picked up " .. brainrot.Name .. "!"

	else
		-- ==========================================
		--               PLACE LOGIC
		-- ==========================================

		local brainrot = getEquippedBrainrot(player)
		if not brainrot then
			return false, "Equip a valid Brainrot first!"
		end

		-- A. Calculate Base Rate
		local baseIncome = BRAINROT_INCOME[brainrot.Name]
		if not baseIncome then
			warn("âš ï¸ '" .. brainrot.Name .. "' not in BRAINROT_INCOME. Defaulting to 1.")
			baseIncome = 1
		end

		-- B. Apply Rebirth Multiplier (for display purposes)
		local rebirthMult = getRebirthMultiplier(player)

		-- C. Read Mutation (if it exists from spawning system) for display
		local mutation = brainrot:GetAttribute("Mutation")
		local mutationMult = brainrot:GetAttribute("MutationMult") or 1
		if mutation then
			mutationMult = MUTATION_MULTIPLIERS[mutation] or 1
			print("âœ¨ READING MUTATION: " .. brainrot.Name .. " has " .. mutation .. "! (" .. mutationMult .. "x multiplier)")
		end

		-- D. Calculate display income rate (mutations will be applied during collection)
		local finalIncomeRate = math.ceil(baseIncome * rebirthMult * mutationMult)
		local brainrotName = brainrot.Name

		-- E. Move Tool
		brainrot.Parent = displayPart
		brainrot.Enabled = false

		-- F. Lock Physics
		for _, part in pairs(brainrot:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Anchored = true
				part.CanCollide = false
				if part.Name == "Handle" and part:FindFirstChild("TouchInterest") then
					part.TouchInterest:Destroy()
				end
			end
		end

		-- G. Position
		brainrot:PivotTo(displayPart.CFrame * CFrame.Angles(0, math.rad(90), 0))

		-- H. Add UI (with mutation info)
		-- H. Add UI (with mutation info)
addRarityDisplay(brainrot, displayPart)  -- ADD THIS NEW LINE
addSlotNameTag(brainrot, finalIncomeRate, mutation, displayPart)

		-- I. Apply mutation visual effects
		if mutation then
			applyMutationVisuals(brainrot, mutation)
		end

		-- I. Save Data (mutation will be read from tool during collection)
		slotData[slot] = {
			brainrotName      = brainrotName,
			baseIncome        = baseIncome,  -- Store base for recalculation
			incomeRate        = finalIncomeRate, -- Current calculated rate (for display)
			accumulatedIncome = 0,
			lastUpdate        = tick(),
			incomeLabel       = incomeLabels[slot],
			tool              = brainrot,    -- Store reference to the tool itself
		}

		slot:SetAttribute("HasBrainrot",  true)
		slot:SetAttribute("BrainrotName", brainrotName)
		slot:SetAttribute("IncomeRate",   finalIncomeRate)
		if mutation then
			slot:SetAttribute("Mutation", mutation)
		end

		local mutationText = mutation and (" [" .. mutation .. " " .. mutationMult .. "x]") or ""
		print("âœ… " .. player.Name .. " placed " .. brainrotName .. mutationText .. " (Rebirth: " .. rebirthMult .. "x, Final: $" .. finalIncomeRate .. "/sec)")
		return true, "Placed " .. brainrotName .. "! (+" .. finalIncomeRate .. "/sec)" .. (mutation and " [" .. mutation .. "!]" or "")
	end
end

-- COLLECT
local function collectIncome(player, slot)
	if not playerOwnsBase(player, slot) then
		showOwnershipWarning(player)
		return false, "You don't own this base!", 0

	end

	local data = slotData[slot]
	if not data then
		return false, "No brainrot in this slot!", 0
	end

	-- Get current multiplier dynamically
	local currentRebirthMult = getRebirthMultiplier(player)

	-- Get base income
	local baseIncome = data.baseIncome or BRAINROT_INCOME[data.brainrotName] or 1

	-- READ MUTATION FROM TOOL DYNAMICALLY
	local mutationMult = 1
	if data.tool and data.tool:IsDescendantOf(game) then
		local mutation = data.tool:GetAttribute("Mutation")
		if mutation then
			mutationMult = MUTATION_MULTIPLIERS[mutation] or 1
		end
	end

	-- Calculate the real rate right now (Base * Rebirth * Mutation)
	local currentRealRate = baseIncome * currentRebirthMult * mutationMult

	-- Accumulate since last tick using the REAL rate
	local now = tick()
	data.accumulatedIncome = data.accumulatedIncome + (now - data.lastUpdate) * currentRealRate
	data.lastUpdate = now

	local totalIncome = math.floor(data.accumulatedIncome)
	if totalIncome <= 0 then
		return false, "No income to collect yet!", 0
	end

	-- Pay out
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then return false, "Leaderstats not found!", 0 end
	local money = leaderstats:FindFirstChild("Money") or leaderstats:FindFirstChild("Cash") or leaderstats:FindFirstChild("Coins")
	if not money then return false, "Money stat not found!", 0 end

	money.Value = money.Value + totalIncome
	data.accumulatedIncome = data.accumulatedIncome - totalIncome

	-- Immediately refresh the billboard
	-- Immediately refresh the billboard
	-- Immediately refresh the billboard
	if data.incomeLabel then
		local amount = math.floor(data.accumulatedIncome)
		if amount > 0 then
			data.incomeLabel.Parent.Visible = true
			data.incomeLabel.Text = "$" .. amount
		else
			data.incomeLabel.Parent.Visible = false
		end
	end

	print("ðŸ’° " .. player.Name .. " collected $" .. totalIncome .. " from " .. slot.Name)
	return true, "Collected $" .. totalIncome .. "!", totalIncome
end

-- ==========================================================
-- REMOTE EVENTS
-- ==========================================================
placeBrainrotEvent.OnServerEvent:Connect(function(player, slot)
	if typeof(slot) ~= "Instance" or not slot:IsDescendantOf(BASES_FOLDER) then return end
	local ok, msg = placeBrainrotOnSlot(player, slot)
	placeBrainrotEvent:FireClient(player, ok, msg)
end)

collectIncomeEvent.OnServerEvent:Connect(function(player, slot)
	if slot and typeof(slot) == "Instance" then
		local ok, msg, amount = collectIncome(player, slot)
		collectIncomeEvent:FireClient(player, ok, msg, amount)
	end
end)

-- ==========================================================
-- SCAN  â€”  wire up every CollectTrigger & ProximityPrompt once at startup
-- ==========================================================
print("ðŸ” Scanning BrainrotBases...")
local basesFound, slotsFound = 0, 0

for _, base in pairs(BASES_FOLDER:GetChildren()) do
	if not base:IsA("Model") then continue end
	basesFound += 1

	local ownerValue = base:FindFirstChild("Owner")
	print("ðŸ“¦ Base:", base.Name, "| Owner:", ownerValue and ownerValue.Value or "âš ï¸ NONE")

	for _, child in pairs(base:GetChildren()) do
		if not (child:IsA("Model") and child.Name:match("Slot")) then continue end
		slotsFound += 1
		local slot = child
		print("   ðŸ“ Slot:", slot.Name)

		-- 1. CollectTrigger  â€”  create billboard + touch handler
		local collectTrigger = slot:FindFirstChild("CollectTrigger")
		if collectTrigger then

			-- NEW LOGIC: Find existing GUI instead of creating one
			-- NEW LOGIC: Find existing GUI instead of creating one
			local bb = collectTrigger:FindFirstChild("IncomeBillboard")
			local frame = bb and bb:FindFirstChild("Frame")
			local label = frame and frame:FindFirstChild("IncomeText")

			if label then
				incomeLabels[slot] = label
				label.Text = "$0" -- Reset on load
				frame.Visible = false -- Hide it initially since there's no income yet
			end

			collectTrigger.Touched:Connect(function(hit)
				local player = Players:GetPlayerFromCharacter(hit.Parent)
				if not player then return end
				local lastCollect = player:GetAttribute("LastCollectTime") or 0
				if tick() - lastCollect <= 0.5 then return end
				player:SetAttribute("LastCollectTime", tick())

				local ok, msg, amount = collectIncome(player, slot)
				if ok then collectIncomeEvent:FireClient(player, ok, msg, amount) end
			end)
			print("      âœ“ CollectTrigger connected")
		else
			print("      âŒ No CollectTrigger")
		end
		-- 2. ProximityPrompt  â€”  check slot directly, then one level deeper
		local placePrompt = slot:FindFirstChild("PlacePrompt")
		if not placePrompt then
			for _, part in pairs(slot:GetChildren()) do
				local found = part:FindFirstChild("PlacePrompt")
				if found then placePrompt = found; break end
			end
		end

		if placePrompt and placePrompt:IsA("ProximityPrompt") then
			placePrompt.Triggered:Connect(function(player)
				local ok, msg = placeBrainrotOnSlot(player, slot)
				placeBrainrotEvent:FireClient(player, ok, msg)
			end)
			print("      âœ“ PlacePrompt connected")
		else
			print("      âš ï¸ No PlacePrompt found")
		end
	end
end

print("ðŸ“Š Scan done â€”", basesFound, "bases,", slotsFound, "slots")

-- ==========================================================
-- UPDATE LOOP  â€”  accumulate income & refresh billboards every second
-- ==========================================================
task.spawn(function()
    while true do
        task.wait(1)

        -- 1. Initialize totals ONLY for players who actually own a base
        local playerTotals = {} 
        for playerName, base in pairs(assignedBases) do
            playerTotals[playerName] = 0
        end

        -- 2. Calculate income from active slots
        for slot, data in pairs(slotData) do
            -- Find the owner of this slot
            local base = slot.Parent
            local ownerValue = base and base:FindFirstChild("Owner")
            local ownerName = ownerValue and ownerValue.Value
            local player = Players:FindFirstChild(ownerName)

            -- If the player is still in the game (and owns this slot)
            if player then
                local currentRealRate = 1 

                -- Get multipliers
                local rebirthMult = getRebirthMultiplier(player)

                -- Base income
                local baseIncome = data.baseIncome or BRAINROT_INCOME[data.brainrotName] or 1

                -- Mutation maultiplier
                local mutationMult = 1
                if data.tool and data.tool:IsDescendantOf(game) then
                    local mutation = data.tool:GetAttribute("Mutation")
                    if mutation then
                        mutationMult = MUTATION_MULTIPLIERS[mutation] or 1
                    end
                end

                -- Final Calc
                currentRealRate = baseIncome * rebirthMult * mutationMult

                -- ADD TO PLAYER TOTAL
                if playerTotals[player.Name] ~= nil then
                    playerTotals[player.Name] = playerTotals[player.Name] + currentRealRate
                end

                -- Accumulate income for the slot (Backend logic)
                local now = tick()
                data.accumulatedIncome = data.accumulatedIncome + (now - data.lastUpdate) * currentRealRate
                data.lastUpdate = now

                -- Update the small text on the slot itself
				-- Update the small text on the slot itself
				local label = data.incomeLabel
				if label then
					local amount = math.floor(data.accumulatedIncome)

					if amount > 0 then
						-- Show the background frame and text
						label.Parent.Visible = true 
						label.Text = "$" .. amount

						if amount >= 100 then
							label.TextColor3 = Color3.fromRGB(255, 100, 255)   -- purple
						elseif amount >= 50 then
							label.TextColor3 = Color3.fromRGB(255, 215, 0)     -- gold
						else
							label.TextColor3 = Color3.fromRGB(100, 255, 100)   -- green
						end
					else
						-- Hide everything if 0
						label.Parent.Visible = false 
					end
				
                    -- >>> CHANGED LOGIC END <<<
                end
            end
        end

        -- 3. PRINT & UPDATE GUI ONLY FOR BASE OWNERS
        for playerName, totalMPS in pairs(playerTotals) do
            -- (Keep your existing MPS display logic here exactly as it was)
            local player = Players:FindFirstChild(playerName)
            if player and player.Character then
                local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local incomeGui = rootPart:FindFirstChild("MPSDisplay")
                    local textLabel
                    if not incomeGui then
                        incomeGui = Instance.new("BillboardGui")
                        incomeGui.Name = "MPSDisplay"
                        incomeGui.Size = UDim2.new(6, 0, 1.5, 0) 
                        incomeGui.StudsOffset = Vector3.new(0, 3.5, 0) 
                        incomeGui.AlwaysOnTop = true 
                        
                        textLabel = Instance.new("TextLabel")
                        textLabel.Parent = incomeGui
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.TextScaled = true 
                        textLabel.Font = Enum.Font.FredokaOne
                        textLabel.TextColor3 = Color3.fromRGB(85, 255, 127)
                        textLabel.TextStrokeTransparency = 0 
                        
                        incomeGui.Parent = rootPart
                    else
                        textLabel = incomeGui:FindFirstChild("TextLabel")
                    end

                    if textLabel then
                        textLabel.Text = "+$" .. totalMPS .. "/s"
                    end
                end
            end
        end
    end
end)

print("âœ… BrainrotSlotSystem fully loaded with mutation support!")


-- ==========================================================
-- UPDATE LOOP â€” accumulate income & refresh billboards every second
-- ==========================================================
task.spawn(function()
	while true do
		task.wait(1)

		-- 1. Initialize totals ONLY for players who actually own a base
		local playerTotals = {} 
		for playerName, base in pairs(assignedBases) do
			playerTotals[playerName] = 0
		end

		-- 2. Calculate income from active slots
		for slot, data in pairs(slotData) do
			-- Find the owner of this slot
			local base = slot.Parent
			local ownerValue = base and base:FindFirstChild("Owner")
			local ownerName = ownerValue and ownerValue.Value
			local player = Players:FindFirstChild(ownerName)

			-- If the player is still in the game (and owns this slot)
			if player then
				local currentRealRate = 1 

				-- Get multipliers
				local rebirthMult = getRebirthMultiplier(player)

				-- Base income
				local baseIncome = data.baseIncome or BRAINROT_INCOME[data.brainrotName] or 1

				-- Mutation multiplier
				local mutationMult = 1
				if data.tool and data.tool:IsDescendantOf(game) then
					local mutation = data.tool:GetAttribute("Mutation")
					if mutation then
						mutationMult = MUTATION_MULTIPLIERS[mutation] or 1
					end
				end

				-- Final Calc
				currentRealRate = baseIncome * rebirthMult * mutationMult

				-- ADD TO PLAYER TOTAL
				-- We only add if they are in our 'assignedBases' list (sanity check)
				if playerTotals[player.Name] ~= nil then
					playerTotals[player.Name] = playerTotals[player.Name] + currentRealRate
				end

				-- Accumulate income for the slot (Backend logic)
				local now = tick()
				data.accumulatedIncome = data.accumulatedIncome + (now - data.lastUpdate) * currentRealRate
				data.lastUpdate = now

				-- Update the small text on the slot itself
				local label = data.incomeLabel
				if label then
					local amount = math.floor(data.accumulatedIncome)
					label.Text = "$" .. amount

					if amount >= 100 then
						label.TextColor3 = Color3.fromRGB(255, 100, 255)   -- purple
					elseif amount >= 50 then
						label.TextColor3 = Color3.fromRGB(255, 215, 0)     -- gold
					else
						label.TextColor3 = Color3.fromRGB(100, 255, 100)   -- green
					end
				end
			end
		end

		-- 3. PRINT & UPDATE GUI ONLY FOR BASE OWNERS
		for playerName, totalMPS in pairs(playerTotals) do
			

			local player = Players:FindFirstChild(playerName)
			if player and player.Character then
				local rootPart = player.Character:FindFirstChild("HumanoidRootPart")

				if rootPart then
					local incomeGui = rootPart:FindFirstChild("MPSDisplay")
					local textLabel

					if not incomeGui then
						-- CREATE IT ONLY ONCE
						incomeGui = Instance.new("BillboardGui")
						incomeGui.Name = "MPSDisplay"
						incomeGui.Size = UDim2.new(6, 0, 1.5, 0) 
						incomeGui.StudsOffset = Vector3.new(0, 3.5, 0) 
						incomeGui.AlwaysOnTop = true 

						textLabel = Instance.new("TextLabel")
						textLabel.Parent = incomeGui
						textLabel.Size = UDim2.new(1, 0, 1, 0)
						textLabel.BackgroundTransparency = 1
						textLabel.TextScaled = true 
						textLabel.Font = Enum.Font.FredokaOne
						textLabel.TextColor3 = Color3.fromRGB(85, 255, 127) -- Money Green
						textLabel.TextStrokeTransparency = 0 -- Black outline

						incomeGui.Parent = rootPart
					else
						textLabel = incomeGui:FindFirstChild("TextLabel")
					end

					if textLabel then
						textLabel.Text = "+$" .. totalMPS .. "/s"
					end
				end
			end
		end
	end
end)


------------------------------------------------------------
-- PATH: ServerScriptService.Rebirth
-- TYPE: Script
------------------------------------------------------------
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local rebirthevent = ReplicatedStorage.RemoteEvents:WaitForChild("rebirthevent")

	-- CONFIGURATION
	local BASE_REBIRTH_COST = 100000 -- First rebirth cost
	local COST_MULTIPLIER = 1.5      -- Multiplier per rebirth (exponential growth)

	-- Cost formula options (choose one by uncommenting):
	local function calculateCost(rebirthCount)
		-- OPTION 1: Exponential (recommended for simulators)
		-- Gets expensive quickly: 100k, 150k, 225k, 337.5k, 506.25k...
		return math.floor(BASE_REBIRTH_COST * (COST_MULTIPLIER ^ rebirthCount))

		-- OPTION 2: Linear
		-- Steady increase: 100k, 200k, 300k, 400k...
		-- return BASE_REBIRTH_COST * (rebirthCount + 1)

		-- OPTION 3: Quadratic
		-- Moderate scaling: 100k, 200k, 400k, 800k, 1.6M...
		-- return BASE_REBIRTH_COST * ((rebirthCount + 1) ^ 2)

		-- OPTION 4: Fibonacci-style
		-- Unique progression
		-- if rebirthCount == 0 then return BASE_REBIRTH_COST end
		-- if rebirthCount == 1 then return BASE_REBIRTH_COST * 2 end
		-- return calculateCost(rebirthCount - 1) + calculateCost(rebirthCount - 2)
	end

	rebirthevent.OnServerEvent:Connect(function(player)
		local leaderstats = player:FindFirstChild("leaderstats")
		if not leaderstats then return end

		local moneyRaw = player:FindFirstChild("MoneyRaw")
		local rebirths = leaderstats:FindFirstChild("Rebirths")

		if not moneyRaw or not rebirths then return end

		-- Calculate current cost based on rebirth count
		local currentCost = calculateCost(rebirths.Value)

		-- Check if player can afford it
		if moneyRaw.Value >= currentCost then
			-- Reset money and increment rebirths
			moneyRaw.Value = 0
			rebirths.Value = rebirths.Value + 1

			print(player.Name .. " rebirthed! Now at: " .. rebirths.Value .. " rebirths")

			-- Send success back to client (for UI feedback)
			rebirthevent:FireClient(player, true, rebirths.Value)
		else
			-- Send failure back to client
			warn(player.Name .. " tried to rebirth but needs $" .. currentCost .. " (has $" .. moneyRaw.Value .. ")")
			rebirthevent:FireClient(player, false, currentCost)
		end
	end)


------------------------------------------------------------
-- PATH: ServerScriptService.Selling System
-- TYPE: Script
------------------------------------------------------------
-- Put this in ServerScriptService/ShopSystem
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Sell prices based on individual brainrot name
local SELL_PRICES = {
	-- COMMON
	["Tralalero Tralala"] = 10000000,
	["Spioniro Golubiro"] = 750000,
	["Quivioli Ameleonni"] = 225000,
	["Strawberrelli Flamingelli"] = 275000,
	["Strawberry Elephant"] = 500000000000,
	["Ti Ti Ti Sahur"] = 37500,
	["Spaghetti Tualetti"] = 50000000000,
	["Salamino Penguino"] = 400000,
	["Rhino Toasterino"] = 450000,
	["Tric Trac Baraboom"] = 9000,
	["Torrtuginni Dragonfrutini"] = 120000000,
	["Sammyni Spyderini"] = 100000000,
	["Urubini Flamenguini"] = 35000000,
	["Unclito Samito"] = 20000000,
	["Trippi Troppi"] = 2000,
	["Te Te Te Sahur"] = 4000000,
	["Svinina Bombardino"] = 1200,
	["Ta Ta Ta Ta Sahur"] = 7500,
	["Sigma Girl"] = 340000,
	["Trulimero Trulicina"] = 20000,
	["Trenostruzzo Turbo 3000"] = 35000000,
	["Talpa Di Fero"] = 1000,
	["Tim Cheese"] = 500,
	["Trippi Troppi Troppa Trippa"] = 30000000,
	["Taco Lucky Block"] = 500000,
	["Tralaledon"] = 15000000000,
	["Tigrilini Watermelini"] = 1700000,
	["Zibra Zubra Zibralini"] = 1000000,
	["Tracoducotulu Delapeladustuz"] = 4200000,
	["Tralalita Tralala"] = 20000000,
	["Tigroligre Frutonni"] = 14000000,
	["Sigma Boy"] = 325000,
	["To to to Sahur"] = 550000000,
	["Tipi Topi Taco"] = 17500000,
	["Pot Hotspot"] = 500000000,
	["Tukanno Bananno"] = 22500000,
	["Tung Tung Tung Sahur"] = 2500000,
	["Secret Lucky Block"] = 750000000,
	["67"] = 2600000000,
	["Admin Lucky Block"] = 1000000000,
	["Agarrini la Palini"] = 160000000,
	["Alessio"] = 18000000,
	["Antonio"] = 6000000,
	["Avocadini Antilopini"] = 17500,
	["Avocadini Guffo"] = 35000,
	["Avocadorilla"] = 2000000,
	["Ballerina Cappuccina"] = 100000,
	["Ballerino Lololo"] = 45000000,
	["Bambini Crostini"] = 225000,
	["Bananita Dolphinita"] = 25000,
	["Bandito Axolito"] = 12500,
	["Bandito Bobritto"] = 4500,
	["Bisonte Giuppitere"] = 75000000,
	["Blackhole Goat"] = 140000000,
	["Blueberrinni Octopusini"] = 250000,
	["Bombardiro Crocodilo"] = 500000,
	["Bombombini Gusini"] = 1000000,
	["Boneca Ambalabu"] = 5000,
	["Brainrot God Lucky Block"] = 5000000,
	["Brr Brr Patapim"] = 15000,
	["Brr es Teh Patipum"] = 65000000,
	["Brri Brri Bicus Dicus Bombicus"] = 30000,
	["Bulbito Bandito Traktorito"] = 48000000,
	["Burbaloni Loliloli"] = 100000,
	["Cacasito Satalito"] = 125000,
	["Cacto Hipopotamo"] = 6500,
	["Cappuccino Assassino"] = 10000,
	["Caramello Filtrello"] = 255000,
	["Carloo"] = 4500000,
	["Carrotini Brainini"] = 4700000,
	["Cavallo Virtuoso"] = 2500000,
	["Celularcini Viciosini"] = 10000000000,
	["Chachechi"] = 150000000,
	["Chef Crabracadabra"] = 150000,
	["Chicleteira Bicicleteira"] = 3500000,
	["Chihuanini Taconini"] = 8500000,
	["Chimpanzini Bananini"] = 50000,
	["Cocofanto Elefanto"] = 5000000,
	["Crabbo Limonetta"] = 1250000,
	["Dragon Cannelloni"] = 100000000000,
	["Dug dug dug"] = 255000,
	["Dul Dul Dul"] = 130000000,
	["Esok Sekolah"] = 3000000,
	["Espresso Signora"] = 15000000,
	["Extinct Ballerina"] = 30000000,
	["Extinct Matteo"] = 250000000,
	["Extinct Tralalero"] = 175000000,
	["Fluriflura"] = 750,
	["Fragola La La La"] = 180000000,
	["Frigo Camelo"] = 350000,
	["Ganganzelli Trulala"] = 3500000,
	["Gangster Footera"] = 4000,
	["Garama and Madundung"] = 40000000000,
	["Gattatino Nyanino"] = 7500000,
	["Gattito Tacoto"] = 40000000,
	["Girafa Celestre"] = 7500000,
	["Glorbo Fruttodrillo"] = 200000,
	["Gorillo Watermelondrillo"] = 3000000,
	["Graipuss Medussi"] = 400000000,
	["Guerriro Digitale"] = 1000000000,
	["Job Job Job Sahur"] = 350000000,
	["Karkerkar Kurkur"] = 550000,
	["Ketchuru and Musturu"] = 30000000000,
	["Ketupat Kepat"] = 25000000000,
	["La Cucaracha"] = 220000000,
	["La Extinct Grande"] = 235000000,
	["La Grande Combinasion"] = 750000000,
	["La Karkerkar Combinasion"] = 7500000000,
	["La Sahur Combinasion"] = 550000000,
	["La Vacca Saturno Saturnita"] = 110000000,
	["Las Capuchinas"] = 185000,
	["Las Sis"] = 8000000000,
	["Las Tralaleritas"] = 650000,
	["Las Vaquitas Saturnitas"] = 60000,
	["Lerulerulerule"] = 3500000,
	["Lionel Cactuseli"] = 175000,
	["LirilÃ¬ LarilÃ "] = 250,
	["Los Bombinitos"] = 60000000,
	["Los Bros"] = 12000000000,
	["Los Chicleteiras"] = 4500000,
	["Los Combinasionas"] = 15000000,
	["Los Crocodillitos"] = 12500000,
	["Los Hotspotsitos"] = 25000000,
	["Los Matteos"] = 100000000,
	["Los Noobinis"] = 4300000,
	["Los Nooo My Hotspotsitos"] = 3500000000,
	["Los Orcalitos"] = 45000000,
	["Los Spyderinis"] = 200000000,
	["Los Tacoritas"] = 16500000,
	["Los Tipi Tacos"] = 260000,
	["Los Tralaleritos"] = 300000000,
	["Los Tungtungtungcitos"] = 50000000,
	["Matteo"] = 10000000,
	["Mythic Lucky Block"] = 2500000,
	["Noobini Pizzanini"] = 25,
	["Nuclearo Dinossauro"] = 5000000000,
	["Odin Din Din Dun"] = 16000000,
	["Orangutini Ananassini"] = 400000,
	["Orcalero Orcala"] = 25000000,
	["Pakrahmatmamat"] = 55000000,
	["Pandaccini Bananini"] = 300000,
	["Penguino Cocosino"] = 45000,
	["Perochello Lemonchello"] = 27500,
	["Piccione Macchina"] = 65000000,
	["Pipi Avocado"] = 9500,
	["Pipi Corni"] = 1700,
	["Pipi Kiwi"] = 1500,
	["Pipi Potato"] = 265000,
}

	-- Reference to brainrot folder
	local BrainrotPackFolder = ReplicatedStorage:WaitForChild("Brainrot pack1", 10)

	-- Create RemoteEvent for selling
	local remoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
	if not remoteEvents then
		remoteEvents = Instance.new("Folder")
		remoteEvents.Name = "RemoteEvents"
		remoteEvents.Parent = ReplicatedStorage
	end

	local sellBrainrotEvent = remoteEvents:FindFirstChild("SellBrainrotEvent")
	if not sellBrainrotEvent then
		sellBrainrotEvent = Instance.new("RemoteEvent")
		sellBrainrotEvent.Name = "SellBrainrotEvent"
		sellBrainrotEvent.Parent = remoteEvents
	end

	-- Function to check if player has a valid brainrot equipped
	local function getEquippedBrainrot(player)
		if not player.Character then return nil end
		local tool = player.Character:FindFirstChildOfClass("Tool")
		if not tool or not BrainrotPackFolder then return nil end

		-- Verify it's actually a brainrot from our pack
		for _, item in pairs(BrainrotPackFolder:GetChildren()) do
			if item.Name == tool.Name then
				return tool
			end
		end
		return nil
	end

	-- Function to sell brainrot
	local function sellBrainrot(player)
		local brainrot = getEquippedBrainrot(player)

		if not brainrot then
			return false, "You need to hold a Brainrot to sell!", 0
		end

		-- Get sell price by brainrot name
		local brainrotName = brainrot.Name
		local sellPrice = SELL_PRICES[brainrotName]

		if not sellPrice then
			warn("âš ï¸ '" .. brainrotName .. "' not found in SELL_PRICES. Defaulting to $1.")
			sellPrice = 1
		end

		local rarity = brainrot:GetAttribute("Rarity") or "Unknown"

		-- Give player money
		local moneyRaw = player:FindFirstChild("MoneyRaw")
		if not moneyRaw then
			return false, "Money system not found!", 0
		end

		moneyRaw.Value = moneyRaw.Value + sellPrice

		-- Destroy the brainrot tool
		brainrot:Destroy()

		print("ðŸ’° " .. player.Name .. " sold " .. brainrotName .. " (" .. rarity .. ") for $" .. sellPrice)

		return true, "Sold " .. brainrotName .. " for $" .. sellPrice .. "!", sellPrice, brainrotName, rarity
	end

	-- Handle sell requests
	sellBrainrotEvent.OnServerEvent:Connect(function(player)
		print("ðŸ”” Sell request from " .. player.Name)
		local success, message, amount, name, rarity = sellBrainrot(player)
		print("ðŸ“¤ Sending result to client:", success, message, amount)
		sellBrainrotEvent:FireClient(player, success, message, amount, name, rarity)
	end)

	-- Setup shop ProximityPrompts in workspace
	local function setupShopPrompt(shopPart)
		local prompt = Instance.new("ProximityPrompt")
		prompt.Name = "ShopPrompt"
		prompt.ActionText = "Sell Brainrot"
		prompt.ObjectText = "Shop"
		prompt.MaxActivationDistance = 10
		prompt.HoldDuration = 0
		prompt.RequiresLineOfSight = false
		prompt.Parent = shopPart

		prompt.Triggered:Connect(function(player)
			local success, message, amount, name, rarity = sellBrainrot(player)
			sellBrainrotEvent:FireClient(player, success, message, amount, name, rarity)
		end)

		print("âœ… Shop prompt added to " .. shopPart:GetFullName())
	end

	-- Auto-find and setup shop parts (any part named "BrainrotSellLocation" or with "IsBrainrotShop" attribute)
	for _, obj in pairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") then
			if obj.Name == "BrainrotSellLocation" or obj:GetAttribute("IsBrainrotShop") == true then
				setupShopPrompt(obj)
			end
		end
	end

	print("âœ… Shop System loaded!")


------------------------------------------------------------
-- PATH: ServerScriptService.CheckMoney
-- TYPE: Script
------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local PurchaseEvent = ReplicatedStorage.RemoteEvents:WaitForChild("Purchasecoil") -- Use one event for the transaction
local ServerStorage = game:GetService("ServerStorage")

-- Configuration Table (Easy to add more items later!)
local ItemPrices = {
	["SpeedCoil"] = 500,
	["SuperSpeedCoil"] = 800 
}

PurchaseEvent.OnServerEvent:Connect(function(player, itemName)
	local price = ItemPrices[itemName]
	local tool = ServerStorage:WaitForChild(itemName)
	-- 1. Validate the item exists
	if not price then return end 

	-- 2. Secure Money Check
	local leaderstats = player:WaitForChild("leaderstats")
	local money = leaderstats:WaitForChild("Money")

	if money.Value >= price then
		-- 3. The Transaction
		money.Value = money.Value - price -- Subtract money
		tool:Clone().Parent = player.Backpack -- Give the tool

		-- 4. Tell the Client it succeeded
		PurchaseEvent:FireClient(player, true, itemName)
		print(player.Name .. " bought " .. itemName)
	else
		-- 5. Tell the Client it failed
		PurchaseEvent:FireClient(player, false, "Insufficient Funds")
	end
end)


------------------------------------------------------------
-- PATH: ServerScriptService.BaseUpgradeSystem
-- TYPE: Script
------------------------------------------------------------
print("ðŸ—ï¸ BaseUpgradeSystem (Replicate Mode) starting...")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")

-- Ensure Remotes Exist
local remoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder", ReplicatedStorage)
remoteEvents.Name = "RemoteEvents"

local upgradeBaseEvent = remoteEvents:FindFirstChild("UpgradeBaseEvent") or Instance.new("RemoteEvent", remoteEvents)
upgradeBaseEvent.Name = "UpgradeBaseEvent"

local incomingEvent = remoteEvents:FindFirstChild("UpgradeBase") or Instance.new("RemoteEvent", remoteEvents)
incomingEvent.Name = "UpgradeBase"

-- ==========================================================
-- âš™ï¸ CONFIGURATION
-- ==========================================================
local BASES_FOLDER_NAME = "BrainrotBases"
local TEMPLATE_NAME = "SecondFloorReplicate" -- Name of the model to clone

local UPGRADE_CONFIG = {
	BaseCost = 1000,
	Multiplier = 1.5,
	Exponent = 1.3
}

-- ðŸ—ï¸ FLOOR POSITIONING CONFIGURATION
-- Controls the position of new floors relative to the base center

-- Vertical spacing (Y-axis)
-- Positive number = gap between floors
-- Negative number = floors overlap/squish together
-- 0 = floors touch perfectly (edge to edge)
local FLOOR_SPACING = -24.75

-- Horizontal offset (X-axis)
-- Positive = shift right, Negative = shift left
-- 0 = centered on base X position
local FLOOR_OFFSET_X = 4.8

-- Horizontal offset (Z-axis)
-- Positive = shift forward, Negative = shift backward
-- 0 = centered on base Z position
local FLOOR_OFFSET_Z = 5

-- ==========================================================
-- VARIABLES
-- ==========================================================
local BASES_FOLDER = Workspace:WaitForChild(BASES_FOLDER_NAME, 5)
local FLOOR_TEMPLATE = Workspace:WaitForChild(TEMPLATE_NAME, 5)

if not BASES_FOLDER or not FLOOR_TEMPLATE then
	warn("âŒ CRITICAL ERROR: Could not find 'BrainrotBases' folder or 'SecondFloorReplicate' model!")
	return
end

-- Track data
local baseData = {} 
-- Structure: 
-- baseData[baseModel] = {
--     Level = 1,
--     TopFloorModel = baseModel (Initially the base itself)
-- }

-- ==========================================================
-- ðŸ§® MATH HELPER FUNCTIONS
-- ==========================================================

local function calculateUpgradeCost(currentLevel)
	local cost = UPGRADE_CONFIG.BaseCost 
		* (UPGRADE_CONFIG.Multiplier ^ (currentLevel - 1)) 
		* (currentLevel ^ UPGRADE_CONFIG.Exponent)
	return math.floor(cost)
end

local function getBaseInfo(base)
	if not baseData[base] then
		baseData[base] = {
			Level = 1,
			TopFloorModel = base
		}
	end
	return baseData[base]
end

-- ==========================================================
-- ðŸŽ¨ VISUALS
-- ==========================================================

local function updateSignVisuals(base)
	local info = getBaseInfo(base)
	local cost = calculateUpgradeCost(info.Level)
	local text = "Upgrade to Floor " .. (info.Level + 1) .. "\n$" .. cost

	local upgradeSign = base:FindFirstChild("UpgradeSign")
	if upgradeSign then
		-- Update SurfaceGui
		local surfaceGui = upgradeSign:FindFirstChildWhichIsA("SurfaceGui", true)
		if surfaceGui then
			local label = surfaceGui:FindFirstChildWhichIsA("TextLabel", true)
			if label then label.Text = text end
		end

		-- Update ProximityPrompt
		local prompt = upgradeSign:FindFirstChildWhichIsA("ProximityPrompt", true)
		if prompt then
			prompt.ObjectText = "$" .. cost
			prompt.ActionText = "Upgrade (Lvl " .. (info.Level + 1) .. ")"
			prompt.Enabled = true
		end
	end
end

-- ==========================================================
-- ðŸ—ï¸ CORE UPGRADE LOGIC
-- ==========================================================

local function findBaseOwnedBy(player)
	for _, base in pairs(BASES_FOLDER:GetChildren()) do
		local ownerVal = base:FindFirstChild("Owner")
		if ownerVal and ownerVal.Value == player.Name then
			return base
		end
	end
	return nil
end

local function upgradeBase(player, base)
	local info = getBaseInfo(base)
	local cost = calculateUpgradeCost(info.Level)

	-- 1. Check Money
	local leaderstats = player:FindFirstChild("leaderstats")
	local money = leaderstats and (leaderstats:FindFirstChild("Money") or leaderstats:FindFirstChild("Cash"))

	if not money then return false, "No money found!" end
	if money.Value < cost then return false, "Need $"..cost end

	-- 2. Prepare the New Floor
	local currentTop = info.TopFloorModel
	local newFloor = FLOOR_TEMPLATE:Clone()
	local nextLevel = info.Level + 1

	-- 3. Calculate Stacking Position
	local currentCF, currentSize = currentTop:GetBoundingBox()
	local newCF, newSize = newFloor:GetBoundingBox()
	local baseCF = base:GetBoundingBox() -- This is the "Anchor" rotation

	-- Calculate Height: Top of old floor + Half height of new floor + Floor Spacing
	local stackY = (currentSize.Y / 2) + (newSize.Y / 2) + FLOOR_SPACING

	-- Calculate Target Position with offsets:
	-- X = Base center + X offset
	-- Y = Calculated stack height above current top floor
	-- Z = Base center + Z offset
	local targetY = currentCF.Position.Y + stackY
	local targetPos = Vector3.new(
		baseCF.Position.X + FLOOR_OFFSET_X, 
		targetY, 
		baseCF.Position.Z + FLOOR_OFFSET_Z
	)

	-- ---------------------------------------------------------
	-- ðŸ”¥ CRITICAL FIX: FORCE ROTATION TO MATCH BASE ðŸ”¥
	-- ---------------------------------------------------------
	newFloor:PivotTo(CFrame.new(targetPos) * baseCF.Rotation)

	-- 4. Clean up the New Floor
	newFloor.Name = base.Name .. "_Floor" .. nextLevel
	for _, child in pairs(newFloor:GetChildren()) do
		if child.Name == "UpgradeSign" or child.Name == "Owner" or child:IsA("Script") then
			child:Destroy()
		end
	end

	newFloor.Parent = BASES_FOLDER

	-- 5. Finalize Transaction
	money.Value -= cost
	info.Level = nextLevel
	info.TopFloorModel = newFloor

	local skyHeight = leaderstats:FindFirstChild("Skyscraper Height")
	if skyHeight then skyHeight.Value = nextLevel end

	updateSignVisuals(base)

	print("âœ… " .. player.Name .. " stacked floor " .. nextLevel .. " (Offset: X=" .. FLOOR_OFFSET_X .. ", Y=" .. FLOOR_SPACING .. ", Z=" .. FLOOR_OFFSET_Z .. ")")
	return true, "Upgraded to Floor " .. nextLevel .. "!", nextLevel
end

-- ==========================================================
-- ðŸ“¡ EVENT LISTENERS
-- ==========================================================

incomingEvent.OnServerEvent:Connect(function(player)
	local playerBase = findBaseOwnedBy(player)
	if not playerBase then
		upgradeBaseEvent:FireClient(player, false, "You don't own a base!")
		return
	end

	-- Debounce check could go here
	local success, msg = upgradeBase(player, playerBase)
	upgradeBaseEvent:FireClient(player, success, msg)
end)

-- Initialize Signs on Load
for _, base in pairs(BASES_FOLDER:GetChildren()) do
	if base:IsA("Model") then
		updateSignVisuals(base)
	end
end


------------------------------------------------------------
-- PATH: ServerScriptService.WeatherChangeSystem
-- TYPE: Script
------------------------------------------------------------
local Remotes             = game.ReplicatedStorage:WaitForChild("RemoteEvents")
local weatherChangedEvent = Remotes:WaitForChild("WeatherChanged")
local getWeatherFunc      = Remotes:WaitForChild("GetCurrentWeather")
local WeatherSystem       = require(game.ReplicatedStorage:WaitForChild("WeatherSystem"))
local rainEvent           = Remotes:WaitForChild("StartRain") -- Fixed capitalization to match standard naming
local RunService          = game:GetService("RunService")

-- Mutation colors (must match Spawning System)
local MUTATION_COLORS = {
	["Gold"]        = Color3.fromRGB(255, 215, 0),
	["Diamond"]     = Color3.fromRGB(185, 242, 255),
	["Rainbow"]     = "Rainbow",
	["Bloodrot"]    = Color3.fromRGB(100, 0, 0),
	["Candy"]       = Color3.fromRGB(255, 105, 180),
	["Lava"]        = Color3.fromRGB(255, 80, 0),
	["Galaxy"]      = Color3.fromRGB(138, 43, 226),
	["Yin-Yang"]    = "YinYang",
	["Radioactive"] = Color3.fromRGB(0, 255, 50),
	["Wet"] = Color3.fromRGB(84, 130, 255)
}

-- Mutation multipliers (must match Spawning System)
local MUTATION_MULTIPLIERS = {
	["Gold"]        = 1.25,
	["Diamond"]     = 1.50,
	["Rainbow"]     = 10.0,
	["Bloodrot"]    = 2.0,
	["Candy"]       = 4.0,
	["Lava"]        = 6.0,
	["Galaxy"]      = 7.0,
	["Yin-Yang"]    = 7.5,
	["Radioactive"] = 8.5,
	["Wet"] = 1.5
}

-- Ensure WeatherSystem is fully loaded before accessing its properties
local EVENT_DURATION = WeatherSystem.EVENT_DURATION or 15
local CLEAR_DURATION = WeatherSystem.CLEAR_DURATION or 15

local function isDeveloper(player)
	if RunService:IsStudio() then return true end
	return player.UserId == game.CreatorId or player.UserId == 10378926133
end

local function getNextEvent()
	local events = WeatherSystem.WEATHER_EVENTS
	local idx = math.random(1, #events)
	local attempts = 0
	while idx == WeatherSystem._lastEventIndex and attempts < 10 do
		idx = math.random(1, #events)
		attempts += 1
	end
	WeatherSystem._lastEventIndex = idx
	return events[idx]
end

-- ============================================================
--  HELPER: set weather and broadcast
-- ============================================================
local function setWeather(weatherName, duration)
	WeatherSystem._currentWeather = weatherName
	WeatherSystem._weatherEndTime = os.time() + duration

	local data = WeatherSystem.WEATHER_TYPES[weatherName]
	print(string.format("ðŸŒ¦ï¸ Weather changed â†’ %s (lasts %ds)", data.displayName, duration))

	-- Fire to all connected clients (General UI update)
	weatherChangedEvent:FireAllClients(
		weatherName,
		data.displayName,
		data.color,
		data.description,
		duration
	)

	-- ==========================================
	-- [RESTORED] Trigger the physical rain falling!
	-- ==========================================
	if weatherName == "Rain" then
		-- We now use the rainEvent defined at the very top of the script!
		rainEvent:FireAllClients(false)
	else
		rainEvent:FireAllClients(true)
	end

	-- [NEW] Random Mutation Loop over time
	if weatherName ~= "Clear" and data.mutation then
		task.spawn(function()
			local endTime = os.time() + duration
			local visualData = WeatherSystem.LIMITED_VISUALS[data.mutation]
			local announceRemote = Remotes:FindFirstChild("MutationAnnounced")

			-- Keep looping as long as the weather event is active
			while os.time() < endTime do
				-- Wait a random amount of time (e.g., every 1.5 to 3 seconds)
				task.wait(math.random(15, 30) / 10) 

				if os.time() >= endTime then break end

				-- Find all brainrots currently in the workspace
				local availableBrainrots = {}
				for _, obj in ipairs(workspace:GetDescendants()) do
					-- Must be a model, must have a Rarity, and must NOT already have a mutation
					if obj:IsA("Model") and obj:GetAttribute("Rarity") ~= nil and not obj:GetAttribute("Mutation") then
						table.insert(availableBrainrots, obj)
					end
				end

				if #availableBrainrots > 0 then
					-- Pick a random lucky (or unlucky) brainrot!
					local luckyRot = availableBrainrots[math.random(1, #availableBrainrots)]

					-- 1. Assign the mutation attribute so it gets the multiplier
					luckyRot:SetAttribute("Mutation", data.mutation)
					luckyRot:SetAttribute("MutationMult", MUTATION_MULTIPLIERS[data.mutation] or 1)

					-- 2. APPLY VISUALS dynamically
					if visualData then
						-- Strip SurfaceAppearances first
						for _, d in pairs(luckyRot:GetDescendants()) do
							if d:IsA("BasePart") or d:IsA("MeshPart") then
								local sa = d:FindFirstChildOfClass("SurfaceAppearance")
								if sa then sa:Destroy() end
								if visualData.material then
									d.Material = visualData.material
								end
								if visualData.reflectance then
									d.Reflectance = visualData.reflectance
								end
								if visualData.color and visualData.animated == false then
									d.Color = visualData.color
								end
							elseif d:IsA("SpecialMesh") then
								d.TextureId = ""
							end
						end
					end

					-- Apply animation if needed
					if visualData.animated == "galaxy" then
						-- Galaxy animation
						task.spawn(function()
							local parts = {}
							for _, d in pairs(luckyRot:GetDescendants()) do
								if d:IsA("BasePart") then table.insert(parts, d) end
							end
							local t = 0
							while luckyRot and luckyRot.Parent do
								t += 0.02
								local brightness = 0.5 + 0.5 * math.sin(t)
								local col = Color3.fromRGB(
									math.floor(75  + 63  * brightness),
									0,
									math.floor(130 + 100 * brightness)
								)
								for _, p in pairs(parts) do
									if p and p.Parent then p.Color = col end
								end
								task.wait(0.05)
							end
						end)
					elseif visualData.animated == "yinyang" then
						-- Yin-Yang animation
						task.spawn(function()
							local parts = {}
							for _, d in pairs(luckyRot:GetDescendants()) do
								if d:IsA("BasePart") then table.insert(parts, d) end
							end
							local flip = false
							while luckyRot and luckyRot.Parent do
								flip = not flip
								local col = flip and Color3.new(1, 1, 1) or Color3.new(0, 0, 0)
								for _, p in pairs(parts) do
									if p and p.Parent then p.Color = col end
								end
								task.wait(0.5)
							end
						end)
					elseif visualData.animated == "radioactive" then
						-- Radioactive animation
						task.spawn(function()
							local parts = {}
							for _, d in pairs(luckyRot:GetDescendants()) do
								if d:IsA("BasePart") then table.insert(parts, d) end
							end
							local t = 0
							while luckyRot and luckyRot.Parent do
								t += 0.08
								local brightness = 0.5 + 0.5 * math.sin(t)
								local g = math.floor(150 + 105 * brightness)
								local col = Color3.fromRGB(0, g, 0)
								for _, p in pairs(parts) do
									if p and p.Parent then p.Color = col end
								end
								task.wait(0.05)
							end
						end)
					end

					-- ==========================================
					-- [NEW] 2.5 UPDATE THE OVERHEAD BILLBOARD DYNAMICALLY
					-- ==========================================
					local statsGUI = luckyRot:FindFirstChild("StatsGUI")
					if statsGUI and not statsGUI:FindFirstChild("MutationLabel") then
						local mutationLabel = Instance.new("TextLabel")
						mutationLabel.Name = "MutationLabel"
						mutationLabel.Size = UDim2.new(1, 0, 0.2, 0)
						mutationLabel.BackgroundTransparency = 1
						mutationLabel.Font = Enum.Font.SourceSansBold
						mutationLabel.TextScaled = true

						-- Use the same format as permanent mutations
						mutationLabel.Text = "â­ " .. data.mutation .. " â­"

						-- Get color from MUTATION_COLORS table
						local mutColor = Color3.new(1, 1, 1)
						local mc = MUTATION_COLORS[data.mutation]
						if mc and mc ~= "Rainbow" then
							mutationLabel.TextColor3 = mc
						end

						mutationLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
						mutationLabel.TextStrokeTransparency = 0
						mutationLabel.LayoutOrder = 2

						local constraint = Instance.new("UITextSizeConstraint")
						constraint.MaxTextSize = 35
						constraint.MinTextSize = 2
						constraint.Parent = mutationLabel

						-- Parent it to the main billboard so the UIListLayout organizes it instantly
						mutationLabel.Parent = statsGUI

						-- Apply rainbow animation if needed
						if MUTATION_COLORS[data.mutation] == "Rainbow" then
							task.spawn(function()
								local hue = 0
								while mutationLabel and mutationLabel.Parent do
									hue = (hue + 0.01) % 1
									mutationLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
									task.wait(0.05)
								end
							end)
						elseif MUTATION_COLORS[data.mutation] == "YinYang" then
							-- Alternate the label too
							task.spawn(function()
								local flip = false
								while mutationLabel and mutationLabel.Parent do
									flip = not flip
									mutationLabel.TextColor3 = flip and Color3.new(1,1,1) or Color3.new(0,0,0)
									task.wait(0.5)
								end
							end)
						end
					end

					-- 3. Fire the GUI announcement to all players
					if announceRemote then
						announceRemote:FireAllClients(luckyRot.Name, data.mutation, data.color)
					end
				end
			end
		end)
	end
end

local forceWeatherEvent = Remotes:WaitForChild("ForceWeather")
forceWeatherEvent.OnServerEvent:Connect(function(player, weatherName)
	if not isDeveloper(player) then return end
	if WeatherSystem.WEATHER_TYPES[weatherName] then
		setWeather(weatherName, EVENT_DURATION)
	end
end)

-- ============================================================
--  WEATHER CYCLE LOOP
-- ============================================================



task.spawn(function()
	print("ðŸŒ¤ï¸ Weather system started!")

	setWeather("Clear", CLEAR_DURATION)
	task.wait(CLEAR_DURATION)  -- was hardcoded to 30 â€” now uses your module value

	while true do
		local nextEvent = getNextEvent()
		setWeather(nextEvent, EVENT_DURATION)
		task.wait(EVENT_DURATION)

		setWeather("Clear", CLEAR_DURATION)
		task.wait(CLEAR_DURATION)
	end
end)



print("âœ… WeatherController loaded.")


------------------------------------------------------------
-- PATH: ServerScriptService.RemoteSetup
-- TYPE: Script
------------------------------------------------------------
-- RemoteSetup (Script) -- place in ServerScriptService
-- Runs FIRST to guarantee all RemoteEvents exist before any LocalScript loads.
-- Set RunContext to "Server" or just leave it as a normal Script.

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Ensure the folder exists
local Remotes = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not Remotes then
	Remotes = Instance.new("Folder")
	Remotes.Name = "RemoteEvents"
	Remotes.Parent = ReplicatedStorage
end

local function ensureRemoteEvent(name)
	if not Remotes:FindFirstChild(name) then
		local r = Instance.new("RemoteEvent")
		r.Name = name
		r.Parent = Remotes
	end
end

local function ensureRemoteFunction(name)
	if not Remotes:FindFirstChild(name) then
		local r = Instance.new("RemoteFunction")
		r.Name = name
		r.Parent = Remotes
	end
end

-- Spawn system remotes (your existing script uses these)
ensureRemoteEvent("randombrainrot")
ensureRemoteEvent("AutoSpawn")
ensureRemoteEvent("SpawnSpecificBrainrot")

-- Weather system remotes
ensureRemoteEvent("WeatherChanged")
ensureRemoteFunction("GetCurrentWeather")
ensureRemoteEvent("ForceWeather")

print("âœ… RemoteSetup: All RemoteEvents pre-created.")


------------------------------------------------------------
-- PATH: ServerScriptService.MoneyHandler
-- TYPE: Script
------------------------------------------------------------
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local addMoneyEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("AddMoneyRequest")

-- ðŸ› ï¸ Helper: Check Developer Status
local function isDeveloper(player)
	-- Always allow in Studio
	if RunService:IsStudio() then
		return true
	end

	-- Allow if you are the owner OR if your ID matches
	return player.UserId == game.CreatorId or player.UserId == 10378926133 -- Put your ID here
end

local function onAddMoneyRequest(player, amount)
	-- ðŸ›¡ï¸ SECURITY: Check if player is developer
	if not isDeveloper(player) then
		warn("âŒ Security: " .. player.Name .. " attempted to add money but is not a developer")
		return
	end

	-- Validate the input
	if type(amount) ~= "number" or amount <= 0 then
		warn("âŒ Invalid amount requested by " .. player.Name .. ": " .. tostring(amount))
		return
	end

	-- Find and update the player's money
	local leaderstats = player:FindFirstChild("leaderstats")
	local money = leaderstats and leaderstats:FindFirstChild("Money")

	if money then
		money.Value = money.Value + amount
		print("âœ… Added " .. amount .. " money to " .. player.Name)
	else
		warn("âŒ Could not find Money leaderstat for " .. player.Name)
	end
end

-- Connect the remote event
addMoneyEvent.OnServerEvent:Connect(onAddMoneyRequest)


------------------------------------------------------------
-- PATH: ReplicatedStorage.WeatherSystem
-- TYPE: ModuleScript
------------------------------------------------------------
-- WeatherSystem (ModuleScript) -- place in ReplicatedStorage
-- Manages weather states that enable Limited mutations during events

local WeatherSystem = {}

-- ============================================================
--  WEATHER DEFINITIONS
--  Each weather maps to one Limited mutation from the wiki.
--  limitedChance = rolls out of 1000 during active weather.
-- ============================================================
WeatherSystem.WEATHER_TYPES = {
	["Clear"] = {
		displayName   = "â˜€ï¸ Clear",
		mutation      = nil,       -- no limited mutation during clear
		limitedChance = 0,
		color         = Color3.fromRGB(135, 206, 235),
		description   = "Normal spawns.",
	},
	["Bloodstorm"] = {
		displayName   = "ðŸ©¸ Bloodstorm",
		mutation      = "Bloodrot",
		limitedChance = 150,        -- 4% chance per spawn during event
		color         = Color3.fromRGB(139, 0, 0),
		description   = "Dark clouds bring Bloodrot mutations!",
	},
	["Rain"] = {
		displayName   = "ðŸŒ§ï¸ Rain",
		mutation      = "Wet",
		limitedChance = 150,        -- 2% chance per spawn during event
		color         = Color3.fromRGB(135, 206, 235),
		description   = "Rain brings Wet mutations!",
	},

	["Candyland"] = {
		displayName   = "ðŸ¬ Candy Rain",
		mutation      = "Candy",
		limitedChance = 150,        -- 2.5% â€” rarer because 4x mult
		color         = Color3.fromRGB(255, 182, 193),
		description   = "Sweet showers bring Candy mutations!",
	},
	["Volcanic"] = {
		displayName   = "ðŸŒ‹ Volcanic Eruption",
		mutation      = "Lava",
		limitedChance = 150,        -- ~1.8% â€” 6x mult
		color         = Color3.fromRGB(255, 69, 0),
		description   = "Scorching heat brings Lava mutations!",
	},
	["Galactic"] = {
		displayName   = "ðŸŒŒ Galactic Storm",
		mutation      = "Galaxy",
		limitedChance = 150,        -- ~1.5% â€” 7x mult
		color         = Color3.fromRGB(75, 0, 130),
		description   = "Cosmic energy brings Galaxy mutations!",
	},
	["YinYang"] = {
		displayName   = "â˜¯ï¸ Balance Shift",
		mutation      = "Yin-Yang",
		limitedChance = 150,        -- ~1.2% â€” 7.5x mult
		color         = Color3.fromRGB(50, 50, 50),
		description   = "Reality splits, bringing Yin-Yang mutations!",
	},
	["Radioactive"] = {
		displayName   = "â˜¢ï¸ Toxic Fallout",
		mutation      = "Radioactive",
		limitedChance = 150,         -- 0.8% â€” 8.5x mult (near-Rainbow tier)
		color         = Color3.fromRGB(0, 255, 50),
		description   = "Toxic rain brings Radioactive mutations!",
	},
}

-- ============================================================
--  WEATHER EVENT RARITY (WEIGHTS)
--  Higher number = more common. 
--  (e.g., 4 means it gets added to the selection pool 4 times)
-- ============================================================
WeatherSystem.EVENT_WEIGHTS = {
	["Bloodstorm"]  = 1,
	["Candyland"]   = 1,
	["Volcanic"]    = 1,
	["Galactic"]    = 1,
	["YinYang"]     = 1,
	["Radioactive"] = 1,
	["Rain"]        = 1, -- Set higher to make Rain more common!
}

-- Auto-generate the WEATHER_EVENTS array based on the weights above.
-- This keeps your external scripts working perfectly without modifications!
WeatherSystem.WEATHER_EVENTS = {}
for weatherName, weight in pairs(WeatherSystem.EVENT_WEIGHTS) do
	for i = 1, weight do
		table.insert(WeatherSystem.WEATHER_EVENTS, weatherName)
	end
end

-- Duration config (seconds)
WeatherSystem.EVENT_DURATION  = 15   -- how long each weather event lasts
WeatherSystem.CLEAR_DURATION  = 15    -- gap between events

-- ============================================================
--  LIMITED MUTATION MULTIPLIERS
-- ============================================================
WeatherSystem.LIMITED_MULTIPLIERS = {
	["Bloodrot"]    = 2.0,
	["Candy"]       = 4.0,
	["Lava"]        = 6.0,
	["Galaxy"]      = 7.0,
	["Yin-Yang"]    = 7.5,
	["Radioactive"] = 8.5,
	["Wet"] = 1.5
}

-- ============================================================
--  LIMITED MUTATION VISUALS
--  Colors/effects applied server-side (SurfaceAppearance removed)
-- ============================================================
WeatherSystem.LIMITED_VISUALS = {
	["Bloodrot"] = {
		color       = Color3.fromRGB(100, 0, 0),
		material    = Enum.Material.SmoothPlastic,
		reflectance = 0,
		animated    = false,
	},
	["Candy"] = {
		color       = Color3.fromRGB(255, 105, 180),
		material    = Enum.Material.SmoothPlastic,
		reflectance = 0.1,
		animated    = false,
	},
	["Lava"] = {
		color       = Color3.fromRGB(255, 80, 0),
		material    = Enum.Material.Neon,   -- glowing neon orange
		reflectance = 0,
		animated    = false,
	},
	["Galaxy"] = {
		color       = Color3.fromRGB(138, 43, 226),
		material    = Enum.Material.Neon,
		reflectance = 0,
		animated    = "galaxy",   -- slow purple pulse
	},
	["Yin-Yang"] = {
		color       = nil,        -- handled specially (alternating B&W)
		material    = Enum.Material.SmoothPlastic,
		reflectance = 0,
		animated    = "yinyang",
	},
	["Radioactive"] = {
		color       = Color3.fromRGB(0, 255, 50),
		material    = Enum.Material.Neon,
		reflectance = 0,
		animated    = "radioactive",  -- fast green pulse
	},
	["Wet"] = {
		color       = Color3.fromRGB(84, 130, 255),
		material    = Enum.Material.Neon,
		reflectance = 0,
		animated    = "wet",  -- fast green pulse
	}
}

-- ============================================================
--  STATE  (runtime, not saved)
-- ============================================================
WeatherSystem._currentWeather  = "Clear"
WeatherSystem._weatherEndTime  = 0
WeatherSystem._lastEventIndex  = 0

-- ============================================================
--  PUBLIC API
-- ============================================================

function WeatherSystem.getCurrentWeather()
	return WeatherSystem._currentWeather
end

function WeatherSystem.getWeatherData(weatherName)
	return WeatherSystem.WEATHER_TYPES[weatherName]
end

-- Returns the limited mutation name if one is active, else nil
function WeatherSystem.getActiveLimitedMutation()
	local data = WeatherSystem.WEATHER_TYPES[WeatherSystem._currentWeather]
	if data then return data.mutation end
	return nil
end

-- Returns limitedChance (out of 1000) for current weather
function WeatherSystem.getLimitedChance()
	local data = WeatherSystem.WEATHER_TYPES[WeatherSystem._currentWeather]
	if data then return data.limitedChance end
	return 0
end

return WeatherSystem


------------------------------------------------------------
-- PATH: ReplicatedStorage.NumberFormat
-- TYPE: ModuleScript
------------------------------------------------------------
-- Shared number formatting module
-- Use this anywhere you need to format numbers with suffixes

local NumberFormat = {}

local suffixes = {
	"", "K", "M", "B", "T",
	"Qa", "Qi", "Sx", "Sp", "Oc", "No",
	"Dc", "Ud", "Dd", "Td", "Qd", "QiD",
	"SxD", "SpD", "OcD", "NoD"
}

function NumberFormat.format(num)
	-- Safety check just in case a nil value passes through
	if not num then return "0" end

	if num < 1000 then
		return tostring(math.floor(num))
	end

	local magnitude = math.floor(math.log10(num) / 3)

	-- [THE FIX]: Add +1 because Lua tables start at index 1!
	-- magnitude 1 (Thousands) + 1 = Index 2 ("K")
	local suffix = suffixes[magnitude + 1] or ("e" .. (magnitude * 3))

	local short = num / (1000 ^ magnitude)

	-- Format to 2 decimal places, then remove unnecessary ".00"
	-- This turns "10.00M" into "10M", while keeping "1.25M" intact
	local formatted = string.format("%.2f", short):gsub("%.?0+$", "")

	return formatted .. suffix
end

return NumberFormat


------------------------------------------------------------
-- PATH: StarterPlayer.StarterPlayerScripts.carryUpgradeClient
-- TYPE: LocalScript
------------------------------------------------------------
-- Put this in StarterPlayer > StarterPlayerScripts
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for the proximity prompt (adjust the path to where your proximity prompt is)
local workspace = game:GetService("Workspace")
local proximityPrompt = workspace:WaitForChild("UpgradeStation"):WaitForChild("ProximityPrompt") -- Change this path!

-- Create the GUI
local function createUpgradeGui()
	local screenGui = playerGui:WaitForChild("BrainrotUpgradeGui")



	local mainFrame = screenGui:WaitForChild("MainFrame")

	-- Add corner radius
	local corner = mainFrame.UICorner

	-- Title
	local title = mainFrame.Title

	-- Current capacity display
	local capacityLabel = mainFrame.CapacityLabel

	-- Cost display
	local costLabel = mainFrame.CostLabel

	-- Upgrade button
	local upgradeButton = mainFrame.UpgradeButton
	

	local upgradeCorner = mainFrame.UICorner
	
	-- Close button
	local closeButton = mainFrame.CloseButton

	local closeCorner = closeButton.UICorner

	-- Status message
	local statusLabel = mainFrame.StatusLabel

	return screenGui
end

-- Get or create the GUI
local upgradeGui = playerGui:FindFirstChild("BrainrotUpgradeGui") or createUpgradeGui()

-- Update the GUI with current stats
local function updateGui()
	local currentCapacity = player:GetAttribute("BrainrotCapacity") or 1
	local upgradeCost = player:GetAttribute("NextUpgradeCost") or 100

	local capacityLabel = upgradeGui.MainFrame.CapacityLabel
	local costLabel = upgradeGui.MainFrame.CostLabel

	capacityLabel.Text = "Current Capacity: " .. currentCapacity
	costLabel.Text = "Next Upgrade Cost: $" .. upgradeCost
end

-- When proximity prompt is triggered
proximityPrompt.Triggered:Connect(function()
	upgradeGui.Enabled = not upgradeGui.Enabled

	if upgradeGui.Enabled then
		updateGui()
		upgradeGui.MainFrame.StatusLabel.Text = ""
	end
end)

-- Close button
upgradeGui.MainFrame.CloseButton.MouseButton1Click:Connect(function()
	upgradeGui.Enabled = false
end)

-- Upgrade button
upgradeGui.MainFrame.UpgradeButton.MouseButton1Click:Connect(function()
	-- Fire to server
	local upgradeEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("UpgradeBrainrotCapacity")
	upgradeEvent:FireServer()
end)

-- Listen for server response
local upgradeEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("UpgradeBrainrotCapacity")
upgradeEvent.OnClientEvent:Connect(function(success, message)
	local statusLabel = upgradeGui.MainFrame.StatusLabel

	if success then
		statusLabel.Text = "âœ“ " .. message
		statusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
		updateGui()
	else
		statusLabel.Text = "âœ• " .. message
		statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
	end

	-- Clear message after 3 seconds
	task.delay(3, function()
		if statusLabel then
			statusLabel.Text = ""
		end
	end)
end)

print("âœ… Brainrot Upgrade GUI loaded!")


------------------------------------------------------------
-- PATH: StarterPlayer.StarterPlayerScripts.SlotSystem
-- TYPE: LocalScript
------------------------------------------------------------
-- Put this in StarterPlayer > StarterPlayerScripts
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

-- Wait for RemoteEvents
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local placeBrainrotEvent = remoteEvents:WaitForChild("PlaceBrainrotEvent")
local collectIncomeEvent = remoteEvents:WaitForChild("CollectIncomeEvent")

-- Listen for place brainrot responses (just console logging now)
placeBrainrotEvent.OnClientEvent:Connect(function(success, message)
	if success then
		print("âœ… " .. message)
	else
		print("âŒ"  .. message)
	end
end)

-- Listen for collect income responses (just console logging now)
collectIncomeEvent.OnClientEvent:Connect(function(success, message, amount)
	if success then
		print("ðŸ’° " .. message)
	else
		print("âŒ " .. message)
	end
end)

print("âœ… Brainrot Slot Client System loaded!")


------------------------------------------------------------
-- PATH: StarterPlayer.StarterPlayerScripts.BrainrotPlaceTest
-- TYPE: LocalScript
------------------------------------------------------------
-- Put this in StarterPlayer > StarterPlayerScripts > TestPlaceBrainrot
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for RemoteEvent
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local placeBrainrotEvent = remoteEvents:WaitForChild("PlaceBrainrotEvent")

-- Create a simple test GUI

local gui = playerGui:WaitForChild("TestPlaceGui")
local placeButton = gui.PlaceButton

-- Function to find the nearest slot
local function findNearestSlot()
	local character = player.Character
	if not character or not character.PrimaryPart then return nil end

	local playerPos = character.PrimaryPart.Position
	local nearestSlot = nil
	local nearestDistance = 50 -- Max distance

	local basesFolder = Workspace:FindFirstChild("BrainrotBases")
	if not basesFolder then 
		warn("BrainrotBases folder not found!")
		return nil 
	end

	for _, base in pairs(basesFolder:GetChildren()) do
		if base:IsA("Model") then
			for _, slot in pairs(base:GetChildren()) do
				if slot:IsA("Model") and slot.Name:match("Slot") then
					local displayPos = slot:FindFirstChild("DisplayPosition")
					if displayPos then
						local distance = (displayPos.Position - playerPos).Magnitude
						if distance < nearestDistance then
							nearestDistance = distance
							nearestSlot = slot
						end
					end
				end
			end
		end
	end

	return nearestSlot, nearestDistance
end

-- Button click handler
placeButton.MouseButton1Click:Connect(function()
	print("ðŸ”˜ Place button clicked!")

	local nearestSlot, distance = findNearestSlot()

	if nearestSlot then
		print("ðŸ“ Nearest slot:", nearestSlot.Name, "| Distance:", math.floor(distance), "studs")
		placeButton.Text = "PLACING..."
		placeButton.BackgroundColor3 = Color3.fromRGB(255, 150, 0)

		-- Fire to server
		placeBrainrotEvent:FireServer(nearestSlot)

		task.wait(0.5)
		placeButton.Text = "PLACE BRAINROT"
		placeButton.BackgroundColor3 = Color3.fromRGB(50, 150, 255)
	else
		print("âŒ No slot nearby (must be within 50 studs)")
		placeButton.Text = "NO SLOT NEARBY!"
		placeButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)

		task.wait(1)
		placeButton.Text = "PLACE BRAINROT"
		placeButton.BackgroundColor3 = Color3.fromRGB(50, 150, 255)
	end
end)

print("âœ… Test Place Brainrot GUI loaded! Click the blue button to place.")


------------------------------------------------------------
-- PATH: StarterPlayer.StarterPlayerScripts.SellNotification
-- TYPE: LocalScript
------------------------------------------------------------
-- Put this in StarterPlayer/StarterPlayerScripts/SellNotificationHandler
-- This is a LocalScript (CLIENT-SIDE)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local NumberFormat = require(ReplicatedStorage:WaitForChild("NumberFormat"))

-- Create notification GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "SellNotifications"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Container for notifications (stacks them vertically)
local notificationContainer = Instance.new("Frame")
notificationContainer.Name = "NotificationContainer"
notificationContainer.Size = UDim2.new(0, 300, 0, 0)
notificationContainer.Position = UDim2.new(1, -320, 0, 20)
notificationContainer.BackgroundTransparency = 1
notificationContainer.Parent = screenGui

local listLayout = Instance.new("UIListLayout")
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Padding = UDim.new(0, 10)
listLayout.Parent = notificationContainer

-- Function to show sell notification
local function showSellNotification(brainrotName, amount, rarity)
	local notification = Instance.new("Frame")
	notification.Size = UDim2.new(1, 0, 0, 80)
	notification.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	notification.BorderSizePixel = 0
	notification.BackgroundTransparency = 0
	notification.Parent = notificationContainer

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = notification

	-- Sold text
	local soldLabel = Instance.new("TextLabel")
	soldLabel.Size = UDim2.new(1, -20, 0, 25)
	soldLabel.Position = UDim2.new(0, 10, 0, 5)
	soldLabel.BackgroundTransparency = 1
	soldLabel.Text = "SOLD!"
	soldLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
	soldLabel.TextSize = 18
	soldLabel.Font = Enum.Font.GothamBold
	soldLabel.TextXAlignment = Enum.TextXAlignment.Left
	soldLabel.Parent = notification

	-- Brainrot name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, -20, 0, 20)
	nameLabel.Position = UDim2.new(0, 10, 0, 28)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = brainrotName
	nameLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	nameLabel.TextSize = 14
	nameLabel.Font = Enum.Font.Gotham
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
	nameLabel.Parent = notification

	-- Money amount
	local moneyLabel = Instance.new("TextLabel")
	moneyLabel.Size = UDim2.new(1, -20, 0, 25)
	moneyLabel.Position = UDim2.new(0, 10, 0, 50)
	moneyLabel.BackgroundTransparency = 1
	moneyLabel.Text = "+$" .. NumberFormat.format(amount)
	moneyLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
	moneyLabel.TextSize = 20
	moneyLabel.Font = Enum.Font.GothamBold
	moneyLabel.TextXAlignment = Enum.TextXAlignment.Left
	moneyLabel.Parent = notification

	-- Slide in animation
	notification.Position = UDim2.new(1, 0, 0, 0)
	notification:TweenPosition(
		UDim2.new(0, 0, 0, 0),
		Enum.EasingDirection.Out,
		Enum.EasingStyle.Back,
		0.3,
		true
	)

	-- Auto-remove after 3 seconds
	task.delay(3, function()
		if notification and notification.Parent then
			notification:TweenPosition(
				UDim2.new(1, 0, 0, 0),
				Enum.EasingDirection.In,
				Enum.EasingStyle.Back,
				0.3,
				true,
				function()
					notification:Destroy()
				end
			)
		end
	end)
end

-- Listen for ProximityPrompt triggers to show notifications
workspace.DescendantAdded:Connect(function(descendant)
	if descendant:IsA("ProximityPrompt") and descendant.Name == "SellPrompt" then
		descendant.Triggered:Connect(function(playerWhoTriggered)
			if playerWhoTriggered == player then
				local brainrot = descendant.Parent.Parent
				if brainrot and brainrot:IsA("Model") then
					local rarity = brainrot:GetAttribute("Rarity") or "Common"
					local sellPrice = tonumber(descendant.ActionText:match("%d+")) or 0

					showSellNotification(brainrot.Name, sellPrice, rarity)
				end
			end
		end)
	end
end)

-- Check existing prompts
for _, descendant in pairs(workspace:GetDescendants()) do
	if descendant:IsA("ProximityPrompt") and descendant.Name == "SellPrompt" then
		descendant.Triggered:Connect(function(playerWhoTriggered)
			if playerWhoTriggered == player then
				local brainrot = descendant.Parent.Parent
				if brainrot and brainrot:IsA("Model") then
					local rarity = brainrot:GetAttribute("Rarity") or "Common"
					local sellPrice = tonumber(descendant.ActionText:match("%d+")) or 0

					showSellNotification(brainrot.Name, sellPrice, rarity)
				end
			end
		end)
	end
end

print("âœ… Sell Notification System loaded!")


------------------------------------------------------------
-- PATH: StarterPlayer.StarterPlayerScripts.FindBase
-- TYPE: LocalScript
------------------------------------------------------------
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local basesFolder = Workspace:WaitForChild("BrainrotBases")
local INDICATOR_NAME = "YourBaseIndicator" -- Must match exactly

local function updateBaseVisuals(base)
	-- Safely check if the parts exist yet
	local spawnLocation = base:FindFirstChild("SpawnLocation")
	if not spawnLocation then return end

	local indicator = spawnLocation:FindFirstChild(INDICATOR_NAME)
	if not indicator then return end

	local ownerValue = base:FindFirstChild("Owner")
	local ownerName = ownerValue and ownerValue.Value or ""

	-- LOGIC: Only enable it if I own it. Otherwise, hide it.
	if ownerName == player.Name then
		indicator.Enabled = true
		print("âœ… Showing base indicator for " .. base.Name)
	else
indicator.Enabled = false
	end
end

local function setupBase(base)
	-- 1. Try to update immediately
	updateBaseVisuals(base)

	-- 2. Listen for Ownership changes (When you claim the base)
	local ownerValue = base:WaitForChild("Owner", 10)
	if ownerValue then
		ownerValue.Changed:Connect(function()
			updateBaseVisuals(base)
		end)
	end

	-- 3. Listen for the Indicator loading in (In case of lag/streaming)
	local spawnLocation = base:WaitForChild("SpawnLocation", 10)
	if spawnLocation then
		spawnLocation.ChildAdded:Connect(function(child)
			if child.Name == INDICATOR_NAME then
				updateBaseVisuals(base)
			end
		end)

		-- Also check if indicator was already there inside spawnLocation
		updateBaseVisuals(base)
	end
end

-- Initialize existing bases
for _, base in pairs(basesFolder:GetChildren()) do
	setupBase(base)
end

-- Initialize future bases (if they are added later)
basesFolder.ChildAdded:Connect(setupBase)


------------------------------------------------------------
-- PATH: StarterPlayer.StarterPlayerScripts.BaseUpgradeClient
-- TYPE: LocalScript
------------------------------------------------------------
-- StarterPlayer/StarterPlayerScripts/BaseUpgradeClient
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- Wait for RemoteEvent
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents", 10)
if not remoteEvents then
	warn("RemoteEvents folder not found!")
	return
end

local upgradeBaseEvent = remoteEvents:WaitForChild("UpgradeBaseEvent", 10)
if not upgradeBaseEvent then
	warn("UpgradeBaseEvent not found!")
	return
end

-- Create UI for notifications
local playerGui = player:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "UpgradeNotifications"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-- Function to show notification
local function showNotification(success, message)
	local notification = Instance.new("Frame")
	notification.Size = UDim2.new(0, 400, 0, 80)
	notification.Position = UDim2.new(0.5, -200, 0.1, 0)
	notification.BackgroundColor3 = success and Color3.fromRGB(40, 180, 40) or Color3.fromRGB(180, 40, 40)
	notification.BorderSizePixel = 0
	notification.Parent = screenGui

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = notification

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -20, 1, -20)
	label.Position = UDim2.new(0, 10, 0, 10)
	label.BackgroundTransparency = 1
	label.Text = message
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.TextSize = 20
	label.Font = Enum.Font.SourceSansBold
	label.TextWrapped = true
	label.Parent = notification

	-- Animate in
	notification.BackgroundTransparency = 1
	label.TextTransparency = 1

	local tweenService = game:GetService("TweenService")
	local tweenIn = tweenService:Create(notification, TweenInfo.new(0.3), {BackgroundTransparency = 0})
	local tweenInText = tweenService:Create(label, TweenInfo.new(0.3), {TextTransparency = 0})

	tweenIn:Play()
	tweenInText:Play()

	-- Wait then fade out
	task.wait(3)

	local tweenOut = tweenService:Create(notification, TweenInfo.new(0.5), {
		BackgroundTransparency = 1,
		Position = UDim2.new(0.5, -200, 0, 0)
	})
	local tweenOutText = tweenService:Create(label, TweenInfo.new(0.5), {TextTransparency = 1})

	tweenOut:Play()
	tweenOutText:Play()

	tweenOut.Completed:Connect(function()
		notification:Destroy()
	end)
end

-- Listen for upgrade events
upgradeBaseEvent.OnClientEvent:Connect(function(success, message)
	showNotification(success, message)
end)

print("âœ… BaseUpgradeClient loaded!")


------------------------------------------------------------
-- PATH: StarterPlayer.StarterPlayerScripts.BounceNotifClient
-- TYPE: LocalScript
------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
-- Wait for your specific GUI
local purchaseGui = playerGui:WaitForChild("PurchaseGui") 
-- Wait for the new Green Frame you just made
local bounceFrame = purchaseGui:WaitForChild("BounceFrame") 

local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local bounceEvent = remoteEvents:WaitForChild("BounceNotif")

-- Animation State Variables
local currentTween = nil
local hideTask = nil

local function playBounceNotification()
	-- 1. CANCEL OLD TIMERS
	if hideTask then
		task.cancel(hideTask)
		hideTask = nil
	end

	-- 2. STOP CURRENT MOTION
	if currentTween then
		currentTween:Cancel()
	end

	-- 3. RESET (Make sure it's visible and on top)
	bounceFrame.Visible = true
	bounceFrame.ZIndex = 101 -- Higher than everything else

	-- If frame is currently hidden (off screen), reset to start position
	if bounceFrame.Position.Y.Scale < 0 then
		bounceFrame.Position = UDim2.new(0.5, 0,-0.007, 0)
	end

	-- DROP ANIMATION (Elastic Out)
	local dropInfo = TweenInfo.new(
		1.2, 
		Enum.EasingStyle.Elastic, 
		Enum.EasingDirection.Out
	)

	currentTween = TweenService:Create(bounceFrame, dropInfo, {
		Position = UDim2.new(0.5, 0, 0.075, 0)
	})
	currentTween:Play()

	-- 4. WAIT & HIDE
	hideTask = task.spawn(function()
		task.wait(2.5) -- Kept it long enough to read the long text

		local upInfo = TweenInfo.new(
			0.6,
			Enum.EasingStyle.Back,
			Enum.EasingDirection.In
		)

		currentTween = TweenService:Create(bounceFrame, upInfo, {
			Position = UDim2.new(0.5, 0, -0.3, 0)
		})
		currentTween:Play()
		currentTween.Completed:Wait()

		bounceFrame.Visible = false
		hideTask = nil
		currentTween = nil
	end)
end

-- Listen for the Server to tell us to play the animation
bounceEvent.OnClientEvent:Connect(playBounceNotification)


------------------------------------------------------------
-- PATH: StarterPlayer.StarterPlayerScripts.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local purchaseGui = playerGui:WaitForChild("PurchaseGui")
-- The new Red Frame
local capacityFrame = purchaseGui:WaitForChild("CapacityFrame") 

local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local capacityEvent = remoteEvents:WaitForChild("CapacityFullEvent")

-- Animation State Variables
local currentTween = nil
local hideTask = nil

local function playCapacityNotification()
	-- 1. CANCEL OLD TIMERS
	if hideTask then
		task.cancel(hideTask)
		hideTask = nil
	end

	-- 2. STOP CURRENT MOTION
	if currentTween then
		currentTween:Cancel()
	end

	-- 3. RESET
	capacityFrame.Visible = true
	capacityFrame.ZIndex = 102 -- Highest priority (above bounce)

	-- If frame is currently hidden (off screen), reset to start position
	if capacityFrame.Position.Y.Scale < 0 then
		capacityFrame.Position = UDim2.new(0.5, 0, -0.3, 0)
	end

	-- DROP ANIMATION (Elastic Out)
	local dropInfo = TweenInfo.new(
		1.2, 
		Enum.EasingStyle.Elastic, 
		Enum.Ea
F|S|Part_2
-- [[ CHUNK START ]] --
singDirection.Out
	)

	currentTween = TweenService:Create(capacityFrame, dropInfo, {
		Position = UDim2.new(0.5, 0, 0.15, 0)
	})
	currentTween:Play()

	-- 4. WAIT & HIDE
	hideTask = task.spawn(function()
		task.wait(2.5) 

		local upInfo = TweenInfo.new(
			0.6,
			Enum.EasingStyle.Back,
			Enum.EasingDirection.In
		)

		currentTween = TweenService:Create(capacityFrame, upInfo, {
			Position = UDim2.new(0.5, 0, -0.3, 0)
		})
		currentTween:Play()
		currentTween.Completed:Wait()

		capacityFrame.Visible = false
		hideTask = nil
		currentTween = nil
	end)
end

capacityEvent.OnClientEvent:Connect(playCapacityNotification)


------------------------------------------------------------
-- PATH: StarterPlayer.StarterPlayerScripts.RebirthLocks
-- TYPE: LocalScript
------------------------------------------------------------
-- Put this in StarterPlayer/StarterPlayerScripts/BrainrotLockHandler
-- This is a LocalScript (CLIENT-SIDE)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local leaderstats = player:WaitForChild("leaderstats")
local rebirths = leaderstats:WaitForChild("Rebirths")

-- Rebirth requirements matching spawning system
local RARITY_REQUIREMENTS = {
	["Common"] = 0,
	["Rare"] = 1,
	["Epic"] = 3,
	["Legendary"] = 5,
	["Mythic"] = 10,
	["Brainrot God"] = 25,
	["Secret"] = 50,
	["OG"] = 100,
}

-- Store original visuals before applying monochrome
local originalVisuals = {}

local function storeBrainrotVisuals(brainrot)
	if originalVisuals[brainrot] then return end

	local visualData = {}
	for _, descendant in pairs(brainrot:GetDescendants()) do
		if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
			visualData[descendant] = {
				Color = descendant.Color,
				Material = descendant.Material,
				Reflectance = descendant.Reflectance,
			}
		end
	end
	originalVisuals[brainrot] = visualData
end

local function applyMonochrome(brainrot)
	for _, descendant in pairs(brainrot:GetDescendants()) do
		if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
			local originalColor = descendant.Color
			local gray = (originalColor.R + originalColor.G + originalColor.B) / 3
			descendant.Color = Color3.new(gray, gray, gray)
		end
	end
end

local function restoreOriginalVisuals(brainrot)
	local visualData = originalVisuals[brainrot]
	if not visualData then return end

	for part, data in pairs(visualData) do
		if part and part.Parent then
			part.Color = data.Color
			part.Material = data.Material
			part.Reflectance = data.Reflectance
		end
	end
end

local function updateBrainrotLockStatus(brainrot)
	local requirement = brainrot:GetAttribute("RebirthRequirement") or 0
	local currentRebirths = rebirths.Value
	local isLocked = currentRebirths < requirement

	-- Update lock attribute
	brainrot:SetAttribute("IsLocked", isLocked)

	if isLocked then
		-- Lock: store originals and apply grayscale
		storeBrainrotVisuals(brainrot)
		applyMonochrome(brainrot)

		-- CRITICAL: Remove SurfaceAppearance to allow grayscale to show
		for _, descendant in pairs(brainrot:GetDescendants()) do
			if descendant:IsA("BasePart") or descendant:IsA("MeshPart") then
				local surfaceAppearance = descendant:FindFirstChildOfClass("SurfaceAppearance")
				if surfaceAppearance then
					-- Store it so we can restore later
					if not originalVisuals[brainrot].surfaceAppearances then
						originalVisuals[brainrot].surfaceAppearances = {}
					end
					originalVisuals[brainrot].surfaceAppearances[descendant] = surfaceAppearance:Clone()
					surfaceAppearance:Destroy()
				end
				descendant.CanTouch = false
			end
		end
	else
		-- Unlock: restore original colors
		restoreOriginalVisuals(brainrot)

		-- Restore SurfaceAppearances if they existed
		if originalVisuals[brainrot] and originalVisuals[brainrot].surfaceAppearances then
			for part, surfaceAppearance in pairs(originalVisuals[brainrot].surfaceAppearances) do
				if part and part.Parent then
					surfaceAppearance:Clone().Parent = part
				end
			end
		end

		-- Make touchable again
		for _, descendant in pairs(brainrot:GetDescendants()) do
			if descendant:IsA("BasePart") then
				descendant.CanTouch = true
			end
		end

		-- Update nametag to remove lock indicator
		local statsGUI = brainrot:FindFirstChild("StatsGUI")
		if statsGUI then
			local container = statsGUI:FindFirstChild("Frame")
			if container then
				for _, child in pairs(container:GetChildren()) do
					if child:IsA("TextLabel") and child.Text:find("ðŸ”’") then
						child:Destroy()
					end
				end
			end
		end
	end
end

local function scanAllBrainrots()
	for _, obj in pairs(workspace:GetDescendants()) do
		if obj:IsA("Model") and obj:GetAttribute("Rarity") and obj:GetAttribute("RebirthRequirement") then
			updateBrainrotLockStatus(obj)
		end
	end
end

-- Initial scan
task.wait(1) -- Wait for brainrots to spawn
scanAllBrainrots()

-- Update when rebirths change
rebirths:GetPropertyChangedSignal("Value"):Connect(function()
	print("ðŸ”“ Rebirth count changed to " .. rebirths.Value .. " - checking locks...")
	scanAllBrainrots()
end)

-- Watch for new brainrots spawning
workspace.DescendantAdded:Connect(function(descendant)
	if descendant:IsA("Model") and descendant:GetAttribute("Rarity") then
		task.wait(0.2) -- Wait for all attributes to be set
		if descendant:GetAttribute("RebirthRequirement") then
			updateBrainrotLockStatus(descendant)
		end
	end
end)

-- Cleanup when brainrots are removed
workspace.DescendantRemoving:Connect(function(descendant)
	if originalVisuals[descendant] then
		originalVisuals[descendant] = nil
	end
end)

print("âœ… Brainrot Lock Handler (Client) loaded!")


------------------------------------------------------------
-- PATH: StarterPlayer.StarterPlayerScripts.WeatherUI
-- TYPE: LocalScript
------------------------------------------------------------
-- WeatherUI (LocalScript) -- place in StarterPlayerScripts
-- Shows a weather announcement banner when weather changes.
-- Optionally tints the sky to match the weather colour.

local Players           = game:GetService("Players")
local TweenService      = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player    = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for remotes
local Remotes             = ReplicatedStorage:WaitForChild("RemoteEvents")
local weatherChangedEvent = Remotes:WaitForChild("WeatherChanged")
local getWeatherFunc      = Remotes:WaitForChild("GetCurrentWeather")
local mutationAnnouncedEvent = Remotes:WaitForChild("MutationAnnounced")

local Lighting = game:GetService("Lighting")

-- Create or grab the ColorCorrection effect
local colorCorrection = Lighting:FindFirstChildOfClass("ColorCorrectionEffect")
if not colorCorrection then
	colorCorrection = Instance.new("ColorCorrectionEffect")
	colorCorrection.Name = "WeatherTint"
	colorCorrection.Parent = Lighting
end

local CLEAR_SKY_COLOR = Color3.new(1, 1, 1)  -- neutral/no tint

local skyTweenInfo = TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
local currentSkyTween = nil

local function setSkyColor(color)
	if currentSkyTween then currentSkyTween:Cancel() end
	currentSkyTween = TweenService:Create(colorCorrection, skyTweenInfo, { TintColor = color })
	currentSkyTween:Play()
end





-- ============================================================
--  BUILD THE WEATHER BANNER GUI
-- ============================================================
local screenGui = Instance.new("ScreenGui")
screenGui.Name            = "WeatherUI"
screenGui.ResetOnSpawn    = false
screenGui.IgnoreGuiInset  = true
screenGui.Parent          = playerGui

-- Banner frame (slides in from top)
local banner = Instance.new("Frame")
banner.Name              = "WeatherBanner"
banner.Size              = UDim2.new(0, 420, 0, 90)
banner.AnchorPoint       = Vector2.new(0.5, 0)
banner.Position          = UDim2.new(0.5, 0, 0, -100)  -- starts off-screen
banner.BackgroundColor3  = Color3.fromRGB(20, 20, 20)
banner.BackgroundTransparency = 0.25
banner.BorderSizePixel   = 0
banner.Parent            = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 14)
corner.Parent = banner

local stroke = Instance.new("UIStroke")
stroke.Color       = Color3.fromRGB(255, 255, 255)
stroke.Thickness   = 2
stroke.Transparency = 0.6
stroke.Parent = banner

-- Weather name label
local nameLabel = Instance.new("TextLabel")
nameLabel.Name              = "WeatherName"
nameLabel.Size              = UDim2.new(1, -20, 0.55, 0)
nameLabel.Position          = UDim2.new(0, 10, 0, 6)
nameLabel.BackgroundTransparency = 1
nameLabel.Text              = "â˜€ï¸ Clear Skies"
nameLabel.Font              = Enum.Font.FredokaOne
nameLabel.TextScaled        = true
nameLabel.TextColor3        = Color3.new(1, 1, 1)
nameLabel.TextXAlignment    = Enum.TextXAlignment.Center
nameLabel.Parent            = banner

local nameConstraint = Instance.new("UITextSizeConstraint")
nameConstraint.MaxTextSize = 28
nameConstraint.Parent = nameLabel

-- Description label
local descLabel = Instance.new("TextLabel")
descLabel.Name              = "Description"
descLabel.Size              = UDim2.new(1, -20, 0.38, 0)
descLabel.Position          = UDim2.new(0, 10, 0.58, 0)
descLabel.BackgroundTransparency = 1
descLabel.Text              = ""
descLabel.Font              = Enum.Font.SourceSans
descLabel.TextScaled        = true
descLabel.TextColor3        = Color3.fromRGB(220, 220, 220)
descLabel.TextXAlignment    = Enum.TextXAlignment.Center
descLabel.Parent            = banner

local descConstraint = Instance.new("UITextSizeConstraint")
descConstraint.MaxTextSize = 18
descConstraint.Parent = descLabel

-- ============================================================
--  TIMER BAR (shows how long the weather lasts)
-- ============================================================
local timerBar = Instance.new("Frame")
timerBar.Name              = "TimerBar"
timerBar.Size              = UDim2.new(0.95, 0, 0, 5)
timerBar.Position          = UDim2.new(0.025, 0, 1, -8)
timerBar.AnchorPoint       = Vector2.new(0, 0)
timerBar.BackgroundColor3  = Color3.new(1, 1, 1)
timerBar.BackgroundTransparency = 0.4
timerBar.BorderSizePixel   = 0
timerBar.Parent            = banner

local timerCorner = Instance.new("UICorner")
timerCorner.CornerRadius = UDim.new(1, 0)
timerCorner.Parent = timerBar

-- ============================================================
--  PERSISTENT WEATHER INDICATOR (small icon top-right)
-- ============================================================
local indicator = Instance.new("Frame")
indicator.Name              = "WeatherIndicator"
indicator.Size              = UDim2.new(0, 160, 0, 44)
indicator.AnchorPoint       = Vector2.new(1, 0)
indicator.Position          = UDim2.new(1, -10, 0, 10)
indicator.BackgroundColor3  = Color3.fromRGB(20, 20, 20)
indicator.BackgroundTransparency = 0.35
indicator.BorderSizePixel   = 0
indicator.Parent            = screenGui

local indCorner = Instance.new("UICorner")
indCorner.CornerRadius = UDim.new(0, 10)
indCorner.Parent = indicator

local indLabel = Instance.new("TextLabel")
indLabel.Size               = UDim2.new(1, -8, 1, 0)
indLabel.Position           = UDim2.new(0, 4, 0, 0)
indLabel.BackgroundTransparency = 1
indLabel.Text               = "â˜€ï¸ Clear"
indLabel.Font               = Enum.Font.FredokaOne
indLabel.TextScaled         = true
indLabel.TextColor3         = Color3.new(1, 1, 1)
indLabel.TextXAlignment     = Enum.TextXAlignment.Center
indLabel.Parent             = indicator

local indConstraint = Instance.new("UITextSizeConstraint")
indConstraint.MaxTextSize = 16
indConstraint.Parent = indLabel

-- ============================================================
--  ANIMATION HELPERS
-- ============================================================
local tweenInfo_in  = TweenInfo.new(0.5, Enum.EasingStyle.Back,   Enum.EasingDirection.Out)
local tweenInfo_out = TweenInfo.new(0.4, Enum.EasingStyle.Quad,   Enum.EasingDirection.In)

local currentTimerThread = nil

local function showBanner(displayName, color, description, duration)
	-- Update text
	nameLabel.Text  = displayName
	descLabel.Text  = description
	nameLabel.TextColor3 = color
	stroke.Color         = color

	-- Slide in
	banner.Position = UDim2.new(0.5, 0, 0, -100)
	local tweenIn = TweenService:Create(banner, tweenInfo_in,
		{ Position = UDim2.new(0.5, 0, 0, 16) })
	tweenIn:Play()

	-- Timer bar countdown
	timerBar.Size = UDim2.new(0.95, 0, 0, 5)
	timerBar.BackgroundColor3 = color

	if currentTimerThread then task.cancel(currentTimerThread) end
	currentTimerThread = task.spawn(function()
		local startTime = os.clock()
		while os.clock() - startTime < duration do
			local elapsed  = os.clock() - startTime
			local fraction = math.max(0, 1 - (elapsed / duration))
			timerBar.Size = UDim2.new(0.95 * fraction, 0, 0, 5)
			task.wait(0.1)
		end
		-- Slide out when done
		local tweenOut = TweenService:Create(banner, tweenInfo_out,
			{ Position = UDim2.new(0.5, 0, 0, -100) })
		tweenOut:Play()
	end)
end

-- ============================================================
--  HOOK UP TO WEATHER EVENTS
-- ============================================================
weatherChangedEvent.OnClientEvent:Connect(function(weatherName, displayName, color, description, duration)
	indLabel.Text       = displayName
	indLabel.TextColor3 = color

	if weatherName == "Clear" then
		setSkyColor(CLEAR_SKY_COLOR)  -- â† ADD THIS

		local tweenOut = TweenService:Create(banner, tweenInfo_out,
			{ Position = UDim2.new(0.5, 0, 0, -100) })
		tweenOut:Play()
		if currentTimerThread then
			task.cancel(currentTimerThread)
			currentTimerThread = nil
		end
	else
		setSkyColor(color)            -- â† ADD THIS
		showBanner(displayName, color, description, duration)
	end
end)

-- ============================================================
--  SHOW CURRENT WEATHER ON JOIN
-- ============================================================
task.spawn(function()
	task.wait(1)
	local ok, weatherName, data = pcall(function()
		return getWeatherFunc:InvokeServer()
	end)
	if ok and weatherName and data then
		indLabel.Text       = data.displayName
		indLabel.TextColor3 = data.color
		setSkyColor(weatherName ~= "Clear" and data.color or CLEAR_SKY_COLOR)  -- â† ADD THIS
		if weatherName ~= "Clear" then
			local remaining = math.max(0, WeatherSystem and WeatherSystem._weatherEndTime - os.time() or 60)
			showBanner(data.displayName, data.color, data.description, remaining)
		end
	end
end)
mutationAnnouncedEvent.OnClientEvent:Connect(function(brainrotName, mutationName, mutColor)
	-- Create the Notification "Toast"
	local toast = Instance.new("TextLabel")
	toast.Size = UDim2.new(0, 320, 0, 45)
	toast.Position = UDim2.new(1, 10, 1, -80) -- Starts off-screen to the right
	toast.AnchorPoint = Vector2.new(1, 1)
	toast.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	toast.BackgroundTransparency = 0.15
	toast.Font = Enum.Font.GothamBold
	toast.TextSize = 16
	toast.Text = string.format("âœ¨ A %s gained the %s mutation!", brainrotName, mutationName)
	toast.TextColor3 = mutColor

	local stroke = Instance.new("UIStroke")
	stroke.Thickness = 2
	stroke.Color = Color3.new(1, 1, 1)
	stroke.Parent = toast

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = toast

	-- Put it in the existing WeatherUI (or directly in a ScreenGui)
	local screenGui = playerGui:FindFirstChild("WeatherUI")
	if not screenGui then
		screenGui = Instance.new("ScreenGui")
		screenGui.Name = "WeatherUI"
		screenGui.Parent = playerGui
	end
	toast.Parent = screenGui

	-- Slide In Animation
	TweenService:Create(toast, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Position = UDim2.new(1, -15, 1, -80)
	}):Play()

	-- Wait 3 seconds, Slide Out, and Destroy
	task.delay(3, function()
		local tweenOut = TweenService:Create(toast, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			Position = UDim2.new(1, 10, 1, -80)
		})
		tweenOut:Play()
		tweenOut.Completed:Wait()
		toast:Destroy()
	end)
end)


------------------------------------------------------------
-- PATH: StarterPlayer.StarterPlayerScripts.RainScript
-- TYPE: LocalScript
------------------------------------------------------------
--!GENERATED
local Rain = require(script.Rain)
local event = game.ReplicatedStorage.RemoteEvents.StartRain

Rain:SetColor(Color3.fromRGB(script.Color.Value.x, script.Color.Value.y, script.Color.Value.z))
Rain:SetDirection(script.Direction.Value)

Rain:SetTransparency(script.Transparency.Value)
Rain:SetSpeedRatio(script.SpeedRatio.Value)
Rain:SetIntensityRatio(script.IntensityRatio.Value)
Rain:SetLightInfluence(script.LightInfluence.Value)
Rain:SetLightEmission(script.LightEmission.Value)

Rain:SetVolume(script.Volume.Value)

Rain:SetSoundId(script.SoundId.Value)
Rain:SetStraightTexture(script.StraightTexture.Value)
Rain:SetTopDownTexture(script.TopDownTexture.Value)
Rain:SetSplashTexture(script.SplashTexture.Value)

local threshold = script.TransparencyThreshold.Value
if script.TransparencyConstraint.Value and script.CanCollideConstraint.Value then
	Rain:SetCollisionMode(
		Rain.CollisionMode.Function,
		function(p)
			return p.Transparency <= threshold and p.CanCollide
		end
	)
elseif script.TransparencyConstraint.Value then
	Rain:SetCollisionMode(
		Rain.CollisionMode.Function,
		function(p)
			return p.Transparency <= threshold
		end
	)
elseif script.CanCollideConstraint.Value then
	Rain:SetCollisionMode(
		Rain.CollisionMode.Function,
		function(p)
			return p.CanCollide
		end
	)
end

event.OnClientEvent:Connect(function(israining)
	print("oseifjooassaeifooooooooooooooooooooooooooaseofiiiiiiiiiiiiiiiiiasefoiiiiiiiiiiiiiiiiiiiii")
	if israining == false then
		Rain:Enable()
		return
	else
		Rain:Disable()
	end
	
end)


------------------------------------------------------------
-- PATH: StarterPlayer.StarterPlayerScripts.RainScript.Rain
-- TYPE: ModuleScript
------------------------------------------------------------
--[[
	
	Rain module v1.0 by buildthomas (July 2018)
	
	This module is licensed under the APLv2:
	http://www.apache.org/licenses/LICENSE-2.0
	
	In short, you may use this code only if you agree to the following:
	* This notice must always be present and may not be modified or removed in any copy of this code or derived code.
	* You may use this in commercial, closed source projects, and you may modify the source code itself.
	
	Refer to the license for a full description.
	
	For questions please reach out on the Developer Forum (@buildthomas)
	or via Twitter (https://www.twitter.com/buildthomasRBX)
	
	------
	
	
	Rain:Enable(<TweenInfo> tweenInfo)
		Enable the rain effects instantly, or over a given easing function if tweenInfo is given.
		
	Rain:Disable(<TweenInfo> tweenInfo)
		Disable the rain effects instantly, or over a given easing function if tweenInfo is given.
		
		
	Rain:SetColor(<Color3> color, <TweenInfo> tweenInfo)
		Set the global color of all rain particles to a given Color3 value.
		Sets the color instantly, or over a given easing function if tweenInfo is given.
		Color sequences are not supported because this would lead to a messy effect.
		The starting value is RAIN_DEFAULT_COLOR.
		
	Rain:SetTransparency(<number> transparency, <TweenInfo> tweenInfo)
		Set the global transparency of all rain effects. 0 = regular visibility, 1 = fully invisible.
		Sets the transparency instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_TRANSPARENCY.
	
	Rain:SetSpeedRatio(<number> ratio, <TweenInfo> tweenInfo)
		Set the vertical falling speed of the rain particles. 0 = still, 1 = max falling speed.
		Sets the speed instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_SPEEDRATIO.
		
	Rain:SetIntensityRatio(<number> ratio, <TweenInfo> tweenInfo)
		Set the intensity of the rain. 0 = no effects, 1 = full effects.
		Sets the intensity instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_INTENSITYRATIO.
		
	Rain:SetLightEmission(<number> ratio, <TweenInfo> tweenInfo)
		Set the global light emission of all rain effects.
		Sets the light emission instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_LIGHTEMISSION.
		
	Rain:SetLightInfluence(<number> transparency, <TweenInfo> tweenInfo)
		Set the global light influence of all rain effects.
		Sets the light influence instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_LIGHTINFLUENCE.
		
		
	Rain:SetVolume(<number> volume, <TweenInfo> tweenInfo)
		Set the global max volume of rain instantly, or over a given easing function if tweenInfo is given.
		The initial volume of the rain's soundgroup is RAIN_SOUND_BASEVOLUME.
		
		
	Rain:SetCeiling(<Variant<number, nil>> ceiling)
		Set a Y coordinate that marks the ceiling of the world. Above this spot, rain will act as if it's indoors.
		Feed nil to remove any previously set ceiling.
		
		
	Rain:SetDirection(<Vector3> direction, <TweenInfo> tweenInfo)
		Set the direction that rain falls from. The direction parameter should be a unit direction.
		Sets the rain direction instantly, or over a given easing function if tweenInfo is given.
		
	Rain:SetStraightTexture(<string> asset)
	Rain:SetTopDownTexture(<string> asset)
	Rain:SetSplashTexture(<string> asset)
		Adjust textures of the rain effect.
		
	Rain:SetSoundId(<string> asset)
		Adjust sound effect of the rain effect.
		
	Rain:SetCollisionMode(<Rain.CollisionMode> mode, ...)
		Sets the current way collisions are determined for the rain.
		
		Rain.CollisionMode
			A table that should be seen as an enumerator for the collision mode.
			The following values are available:
			* Rain.CollisionMode.None			- All parts in the default collision group will block the rain.
			* Rain.CollisionMode.Whitelist		- Use the whitelist provided by Rain::SetCollisionWhitelist.
			* Rain.CollisionMode.Blacklist		- Use the blacklist provided by Rain::SetCollisionBlacklist.
			* Rain.CollisionMode.Function		- Use the test function provided by Rain::SetCollisionFunction and do deep-casts.
			
		Rain:SetCollisionMode(Rain.CollisionMode.None)
			No parameters.
			
		Rain:SetCollisionMode(Rain.CollisionMode.Whitelist, <Variant<Instance, table>> whitelist)
			The provided value can either be a hierarchy of objects or a table of objects to filter with.
		
		Rain:SetCollisionMode(Rain.CollisionMode.Blacklist, <Variant<Instance, table>> blacklist)
			The provided value can either be a hierarchy of objects or a table of objects to filter out.
			
		Rain:SetCollisionMode(Rain.CollisionMode.Function, <function<BasePart -> boolean>> f)
			If f(part) returns a value that lua evaluates to a true condition, that part can be hit by rain.
			If f(part) returns any other value, that part cannot be hit by the rain.
			
	
--]]

-- Options:

local MIN_SIZE = Vector3.new(0.05,0.05,0.05)				-- Size of main emitter part when rain inactive

local RAIN_DEFAULT_COLOR = Color3.new(1,1,1)				-- Default color3 of all rain elements
local RAIN_DEFAULT_TRANSPARENCY = 0							-- Default transparency scale ratio of all rain elements
local RAIN_DEFAULT_SPEEDRATIO = 1							-- Default speed scale ratio of falling rain effects
local RAIN_DEFAULT_INTENSITYRATIO = 1						-- Default intensity ratio of all rain elements
local RAIN_DEFAULT_LIGHTEMISSION = 0.05						-- Default LightEmission of all rain elements
local RAIN_DEFAULT_LIGHTINFLUENCE = 0.9						-- Default LightInfluence of all rain elements
local RAIN_DEFAULT_DIRECTION = Vector3.new(0,-1,0)			-- Default direction for rain to fall into

local RAIN_TRANSPARENCY_T1 = .25							-- Define the shape (time-wise) of the transparency curves for emitters
local RAIN_TRANSPARENCY_T2 = .75

local RAIN_SCANHEIGHT = 1000								-- How many studs to scan up from camera position to determine whether occluded

local RAIN_EMITTER_DIM_DEFAULT = 40							-- Size of emitter block to the side/up
local RAIN_EMITTER_DIM_MAXFORWARD = 100						-- Size of emitter block forwards when looking at the horizon
local RAIN_EMITTER_UP_MODIFIER = 20							-- Maximum vertical displacement of emitter (when looking fully up/down)

local RAIN_SOUND_ASSET = "rbxassetid://1516791621"
local RAIN_SOUND_BASEVOLUME = 0.2							-- Starting volume of rain sound effect when not occluded
local RAIN_SOUND_FADEIN_TIME = 1							-- Tween in/out times for sound volume
local RAIN_SOUND_FADEOUT_TIME = 1

local RAIN_STRAIGHT_ASSET = "rbxassetid://1822883048"		-- Some properties of the straight rain particle effect
local RAIN_STRAIGHT_ALPHA_LOW = 0.7							-- Minimum particle transparency for the straight rain emitter
local RAIN_STRAIGHT_SIZE = NumberSequence.new(10)
local RAIN_STRAIGHT_LIFETIME = NumberRange.new(0.8)
local RAIN_STRAIGHT_MAX_RATE = 600							-- Maximum rate for the straight rain emitter
local RAIN_STRAIGHT_MAX_SPEED = 60							-- Maximum speed for the straight rain emitter

local RAIN_TOPDOWN_ASSET = "rbxassetid://1822856633"		-- Some properties of the top-down rain particle effect
local RAIN_TOPDOWN_ALPHA_LOW = 0.85							-- Minimum particle transparency for the top-down rain emitter
local RAIN_TOPDOWN_SIZE = NumberSequence.new {
	NumberSequenceKeypoint.new(0, 5.33, 2.75);
	NumberSequenceKeypoint.new(1, 5.33, 2.75);
}			
local RAIN_TOPDOWN_LIFETIME = NumberRange.new(0.8)
local RAIN_TOPDOWN_ROTATION = NumberRange.new(0,360)
local RAIN_TOPDOWN_MAX_RATE = 600							-- Maximum rate for the top-down rain emitter
local RAIN_TOPDOWN_MAX_SPEED = 60							-- Maximum speed for the top-down rain emitter

local RAIN_SPLASH_ASSET = "rbxassetid://1822856633"			-- Some properties of the splash particle effect
local RAIN_SPLASH_ALPHA_LOW = 0.6							-- Minimum particle transparency for the splash emitters
local RAIN_SPLASH_SIZE = NumberSequence.new {				
	NumberSequenceKeypoint.new(0, 0);
	NumberSequenceKeypoint.new(.4, 3);
	NumberSequenceKeypoint.new(1, 0);
}
local RAIN_SPLASH_LIFETIME = NumberRange.new(0.1, 0.15)
local RAIN_SPLASH_ROTATION = NumberRange.new(0,360)
local RAIN_SPLASH_NUM = 20									-- Amount of splashes per frame
local RAIN_SPLASH_CORRECTION_Y = .5							-- Offset from impact position for visual reasons
local RAIN_SPLASH_STRAIGHT_OFFSET_Y = 50					-- Offset against rain direction for straight rain particles from splash position
local RAIN_NOSPLASH_STRAIGHT_OFFSET_Y_MIN = 20				-- Min/max vertical offset from camera height for straight rain particles
local RAIN_NOSPLASH_STRAIGHT_OFFSET_Y_MAX = 100				-- when no splash position could be found (i.e. no floor at that XZ-column)

local RAIN_OCCLUDED_MINSPEED = 70							-- Minimum speed for the occluded straight rain emitters
local RAIN_OCCLUDED_MAXSPEED = 100							-- Maximum speed for the occluded straight rain emitters
local RAIN_OCCLUDED_SPREAD = Vector2.new(10,10)				-- Spread angle for the occluded straight rain emitters
local RAIN_OCCLUDED_MAXINTENSITY = 2						-- How many occluded straight rain particles are emitted for every splash for max intensity

local RAIN_OCCLUDECHECK_OFFSET_Y = 500						-- Vertical offset from camera height to start scanning downward from for splashes
local RAIN_OCCLUDECHECK_OFFSET_XZ_MIN = -100				-- Range of possible XZ offset values from camera XZ position for the splashes
local RAIN_OCCLUDECHECK_OFFSET_XZ_MAX = 100
local RAIN_OCCLUDECHECK_SCAN_Y = 550						-- Scan magnitude along rain path

local RAIN_UPDATE_PERIOD = 6								-- Update the transparency of the main emitters + volume of rain inside every X frames

local RAIN_VOLUME_SCAN_RADIUS = 35							-- Defining grid for checking how far the camera is away from a spot exposed to rain
local RAIN_VOLUME_SCAN_GRID = {								-- Unit range grid for scanning how far away user is from rain space
	-- range 0.2, 4 pts
	Vector3.new(0.141421363, 0, 0.141421363);
	Vector3.new(-0.141421363, 0, 0.141421363);
	Vector3.new(-0.141421363, 0, -0.141421363);
	Vector3.new(0.141421363, 0, -0.141421363);
	-- range 0.4, 8 pts
	Vector3.new(0.400000006, 0, 0);
	Vector3.new(0.282842726, 0, 0.282842726);
	Vector3.new(2.44929371e-17, 0, 0.400000006);
	Vector3.new(-0.282842726, 0, 0.282842726);
	Vector3.new(-0.400000006, 0, 4.89858741e-17);
	Vector3.new(-0.282842726, 0, -0.282842726);
	Vector3.new(-7.34788045e-17, 0, -0.400000006);
	Vector3.new(0.282842726, 0, -0.282842726);
	-- range 0.6, 10 pts
	Vector3.new(0.600000024, 0, 0);
	Vector3.new(0.485410213, 0, 0.352671146);
	Vector3.new(0.185410202, 0, 0.570633948);
	Vector3.new(-0.185410202, 0, 0.570633948);
	Vector3.new(-0.485410213, 0, 0.352671146);
	Vector3.new(-0.600000024, 0, 7.34788112e-17);
	Vector3.new(-0.485410213, 0, -0.352671146);
	Vector3.new(-0.185410202, 0, -0.570633948);
	Vector3.new(0.185410202, 0, -0.570633948);
	Vector3.new(0.485410213, 0, -0.352671146);
	-- range 0.8, 12 pts
	Vector3.new(0.772740662, 0, 0.207055241);
	Vector3.new(0.565685451, 0, 0.565685451);
	Vector3.new(0.207055241, 0, 0.772740662);
	Vector3.new(-0.207055241, 0, 0.772740662);
	Vector3.new(-0.565685451, 0, 0.565685451);
	Vector3.new(-0.772740662, 0, 0.207055241);
	Vector3.new(-0.772740662, 0, -0.207055241);
	Vector3.new(-0.565685451, 0, -0.565685451);
	Vector3.new(-0.207055241, 0, -0.772740662);
	Vector3.new(0.207055241, 0, -0.772740662);
	Vector3.new(0.565685451, 0, -0.565685451);
	Vector3.new(0.772740662, 0, -0.207055241);
}


-- Enumerators:

local CollisionMode = {
	None = 0;
	Whitelist = 1;
	Blacklist = 2;
	Function = 3;
}


-- Variables & setup:

-- services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local GlobalModifier = Instance.new("NumberValue")			-- modifier for rain visibility for disabling/enabling over time span
GlobalModifier.Value = 1									-- 0 = fully visible, 1 = invisible

local connections = {}										-- Stores connections to RunService signals when enabled

local disabled = true										-- Value to figure out whether we are moving towards a disabled state (useful during tweens)

local rainDirection = RAIN_DEFAULT_DIRECTION				-- Direction that rain falls into

local currentCeiling = nil									-- Y coordinate of ceiling (if present)

local collisionMode = CollisionMode.None					-- Collision mode (from Rain.CollisionMode) for raycasting
local collisionList = nil									-- Blacklist/whitelist for raycasting
local collisionFunc = nil									-- Raycasting test function for when collisionMode == Rain.CollisionMode.Function

local straightLowAlpha = 1									-- Current transparency for straight rain particles
local topdownLowAlpha = 1									-- Current transparency for top-down rain particles
local intensityOccludedRain = 0								-- Current intensity of occluded rain particles
local numSplashes = 0										-- Current number of generated splashes per frame
local volumeTarget = 0										-- Current (target of tween for) sound volume

-- shorthands
local v3 = Vector3.new
local NSK010 = NumberSequenceKeypoint.new(0, 1, 0)
local NSK110 = NumberSequenceKeypoint.new(1, 1, 0)

local volumeScanGrid = {}									-- Pre-generate grid used for raining area distance scanning
for _,v in pairs(RAIN_VOLUME_SCAN_GRID) do
	table.insert(volumeScanGrid, v * RAIN_VOLUME_SCAN_RADIUS)
end
table.sort(volumeScanGrid, function(a,b)					-- Optimization: sort from close to far away for fast evaluation if closeby
	return a.magnitude < b.magnitude
end)

-- sound group for easy main volume tweaking
local SoundGroup = Instance.new("SoundGroup")
SoundGroup.Name = "__RainSoundGroup"
SoundGroup.Volume = RAIN_SOUND_BASEVOLUME
SoundGroup.Archivable = false

local Sound = Instance.new("Sound")
Sound.Name = "RainSound"
Sound.Volume = volumeTarget
Sound.SoundId = RAIN_SOUND_ASSET
Sound.Looped = true
Sound.SoundGroup = SoundGroup
Sound.Parent = SoundGroup
Sound.Archivable = false

-- emitter block around camera used when outside
local Emitter do
	
	Emitter = Instance.new("Part")
	Emitter.Transparency = 1
	Emitter.Anchored = true
	Emitter.CanCollide = false
	Emitter.Locked = false
	Emitter.Archivable = false
	Emitter.TopSurface = Enum.SurfaceType.Smooth
	Emitter.BottomSurface = Enum.SurfaceType.Smooth
	Emitter.Name = "__RainEmitter"
	Emitter.Size = MIN_SIZE
	Emitter.Archivable = false
	
	local straight = Instance.new("ParticleEmitter")
	straight.Name = "RainStraight"
	straight.LightEmission = RAIN_DEFAULT_LIGHTEMISSION
	straight.LightInfluence = RAIN_DEFAULT_LIGHTINFLUENCE
	straight.Size = RAIN_STRAIGHT_SIZE
	straight.Texture = RAIN_STRAIGHT_ASSET
	straight.LockedToPart = true
	straight.Enabled = false
	straight.Lifetime = RAIN_STRAIGHT_LIFETIME
	straight.Rate = RAIN_STRAIGHT_MAX_RATE
	straight.Speed = NumberRange.new(RAIN_STRAIGHT_MAX_SPEED)
	straight.EmissionDirection = Enum.NormalId.Bottom
	straight.Parent = Emitter
	straight.Orientation = Enum.ParticleOrientation.FacingCameraWorldUp
	
	local topdown = Instance.new("ParticleEmitter")
	topdown.Name = "RainTopDown"
	topdown.LightEmission = RAIN_DEFAULT_LIGHTEMISSION
	topdown.LightInfluence = RAIN_DEFAULT_LIGHTINFLUENCE
	topdown.Size = RAIN_TOPDOWN_SIZE
	topdown.Texture = RAIN_TOPDOWN_ASSET
	topdown.LockedToPart = true
	topdown.Enabled = false
	topdown.Rotation = RAIN_TOPDOWN_ROTATION
	topdown.Lifetime = RAIN_TOPDOWN_LIFETIME
	topdown.Rate = RAIN_TOPDOWN_MAX_RATE
	topdown.Speed = NumberRange.new(RAIN_TOPDOWN_MAX_SPEED)
	topdown.EmissionDirection = Enum.NormalId.Bottom
	topdown.Parent = Emitter
	
end

local splashAttachments, rainAttachments do
	
	splashAttachments = {}
	rainAttachments = {}
	
	for i = 1, RAIN_SPLASH_NUM do
		
		-- splashes on ground
		local splashAttachment = Instance.new("Attachment")
		splashAttachment.Name = "__RainSplashAttachment"
		local splash = Instance.new("ParticleEmitter")
		splash.LightEmission = RAIN_DEFAULT_LIGHTEMISSION
		splash.LightInfluence = RAIN_DEFAULT_LIGHTINFLUENCE
		splash.Size = RAIN_SPLASH_SIZE
		splash.Texture = RAIN_SPLASH_ASSET
		splash.Rotation = RAIN_SPLASH_ROTATION
		splash.Lifetime = RAIN_SPLASH_LIFETIME
		splash.Transparency = NumberSequence.new {
			NSK010;
			NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T1, RAIN_SPLASH_ALPHA_LOW, 0);
			NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T2, RAIN_SPLASH_ALPHA_LOW, 0);
			NSK110;
		}
		splash.Enabled = false
		splash.Rate = 0
		splash.Speed = NumberRange.new(0)
		splash.Name = "RainSplash"
		splash.Parent = splashAttachment
		splashAttachment.Archivable = false
		table.insert(splashAttachments, splashAttachment)
		
		-- occluded rain particle generation
		local rainAttachment = Instance.new("Attachment")
		rainAttachment.Name = "__RainOccludedAttachment"
		local straightOccluded = Emitter.RainStraight:Clone()
		straightOccluded.Speed = NumberRange.new(RAIN_OCCLUDED_MINSPEED, RAIN_OCCLUDED_MAXSPEED)
		straightOccluded.SpreadAngle = RAIN_OCCLUDED_SPREAD
		straightOccluded.LockedToPart = false
		straightOccluded.Enabled = false
		straightOccluded.Parent = rainAttachment
		local topdownOccluded = Emitter.RainTopDown:Clone()
		topdownOccluded.Speed = NumberRange.new(RAIN_OCCLUDED_MINSPEED, RAIN_OCCLUDED_MAXSPEED)
		topdownOccluded.SpreadAngle = RAIN_OCCLUDED_SPREAD
		topdownOccluded.LockedToPart = false
		topdownOccluded.Enabled = false
		topdownOccluded.Parent = rainAttachment
		rainAttachment.Archivable = false
		table.insert(rainAttachments, rainAttachment)
		
	end
	
end


-- Helper methods:

local ignoreEmitterList = { Emitter }

local raycastFunctions = {
	[CollisionMode.None] = function(ray, ignoreCharacter)
		return workspace:FindPartOnRayWithIgnoreList(ray, ignoreCharacter and {Emitter, Players.LocalPlayer and Players.LocalPlayer.Character} or ignoreEmitterList)
	end;
	[CollisionMode.Blacklist] = function(ray)
		return workspace:FindPartOnRayWithIgnoreList(ray, collisionList)
	end;
	[CollisionMode.Whitelist] = function(ray)
		return workspace:FindPartOnRayWithWhitelist(ray, collisionList)
	end;
	[CollisionMode.Function] = function(ray)
		local destination = ray.Origin + ray.Direction
		-- draw multiple raycasts concatenated to each other until no hit / valid hit found
		while ray.Direction.magnitude > 0.001 do
			local part, pos, norm, mat = workspace:FindPartOnRayWithIgnoreList(ray, ignoreEmitterList)
			if not part or collisionFunc(part) then
				return part, pos, norm, mat
			end
			local start = pos + ray.Direction.Unit * 0.001
			ray = Ray.new(start, destination - start)
		end
	end;
}
local raycast = raycastFunctions[collisionMode]

local function connectLoop()
	
	local rand = Random.new()
	
	local inside = true					-- Whether camera is currently in a spot occluded from the sky
	local frame = RAIN_UPDATE_PERIOD	-- Frame counter, and force update cycle right now
	
	-- Update Emitter on RenderStepped since it needs to be synced to Camera
	table.insert(connections, RunService.RenderStepped:connect(function()
		
		-- Check if camera is outside or inside
		local part, position = raycast(Ray.new(workspace.CurrentCamera.CFrame.p, -rainDirection * RAIN_SCANHEIGHT), true)
		
		if (not currentCeiling or workspace.CurrentCamera.CFrame.p.y <= currentCeiling) and not part then
			
			-- Camera is outside and under ceiling
				
			if volumeTarget < 1 and not disabled then
				volumeTarget = 1
				TweenService:Create(Sound, TweenInfo.new(.5), {Volume = 1}):Play()
			end
			
			frame = RAIN_UPDATE_PERIOD
			
			local t = math.abs(workspace.CurrentCamera.CFrame.lookVector:Dot(rainDirection))
			
			local center = workspace.CurrentCamera.CFrame.p
			local right = workspace.CurrentCamera.CFrame.lookVector:Cross(-rainDirection)
			right = right.magnitude > 0.001 and right.unit or -rainDirection
			local forward = rainDirection:Cross(right).unit
			
			Emitter.Size = v3(
				RAIN_EMITTER_DIM_DEFAULT,
				RAIN_EMITTER_DIM_DEFAULT,
				RAIN_EMITTER_DIM_DEFAULT + (1 - t)*(RAIN_EMITTER_DIM_MAXFORWARD - RAIN_EMITTER_DIM_DEFAULT)
			)
			
			Emitter.CFrame =
				CFrame.new(
					center.x, center.y, center.z,
					right.x, -rainDirection.x, forward.x,
					right.y, -rainDirection.y, forward.y,
					right.z, -rainDirection.z, forward.z
				)
				+ (1 - t) * workspace.CurrentCamera.CFrame.lookVector * Emitter.Size.Z/3
				- t * rainDirection * RAIN_EMITTER_UP_MODIFIER
			
			Emitter.RainStraight.Enabled = true
			Emitter.RainTopDown.Enabled = true
			
			inside = false
			
		else
			
			-- Camera is inside / above ceiling
			
			Emitter.RainStraight.Enabled = false
			Emitter.RainTopDown.Enabled = false
		
			inside = true
			
		end
		
	end))

	-- Do the other effects on Stepped
	local signal = RunService:IsRunning() and RunService.Stepped or RunService.RenderStepped
	table.insert(connections, signal:connect(function()
		
		frame = frame + 1
		
		-- Only do some updates once every few frames
		if frame >= RAIN_UPDATE_PERIOD then
			
			-- Measure of how much camera is facing down (0-1)
			local t = math.abs(workspace.CurrentCamera.CFrame.lookVector:Dot(rainDirection))
			
			-- More looking down = see straight particles less and see top-down particles more
			local straightSequence = NumberSequence.new {
				NSK010;
				NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T1, (1 - t)*straightLowAlpha + t, 0);
				NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T2, (1 - t)*straightLowAlpha + t, 0);
				NSK110;
			}
			local topdownSequence = NumberSequence.new {
				NSK010;
				NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T1, t*topdownLowAlpha + (1 - t), 0);
				NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T2, t*topdownLowAlpha + (1 - t), 0);
				NSK110;
			}
			
			-- Find desired rotation for the straight rain particles
			local mapped = workspace.Camera.CFrame:inverse() * (workspace.Camera.CFrame.p - rainDirection)
			local straightRotation = NumberRange.new(math.deg(math.atan2(-mapped.x, mapped.y)))
			
			if inside then
				
				-- Update emitter properties
				for _,v in pairs(rainAttachments) do
					v.RainStraight.Transparency = straightSequence
					v.RainStraight.Rotation = straightRotation
					v.RainTopDown.Transparency = topdownSequence
				end
				
				if not disabled then
					
					-- Only do occluded volume check if not moving towards disabled state
					
					local volume = 0
					
					if (not currentCeiling or workspace.CurrentCamera.CFrame.p.y <= currentCeiling) then
						
						-- Check how far away camera is from a space open to the sky using volume scan grid
						
						local minDistance = RAIN_VOLUME_SCAN_RADIUS
						local rayDirection = -rainDirection * RAIN_SCANHEIGHT
						
						for i = 1, #volumeScanGrid do -- In order, so first hit is closest
							if not raycast(Ray.new(workspace.CurrentCamera.CFrame * volumeScanGrid[i], rayDirection), true) then
								minDistance = volumeScanGrid[i].magnitude
								break
							end
						end
						
						-- Volume is inversely proportionate to minimum distance
						volume = 1 - minDistance / RAIN_VOLUME_SCAN_RADIUS
						
					end
					
					if math.abs(volume - volumeTarget) > .01 then
						-- Value is sufficiently different from previous target, overwrite it
						volumeTarget = volume
						TweenService:Create(Sound, TweenInfo.new(1), {Volume = volumeTarget}):Play()
					end
					
				end
				
			else
				
				-- Update emitter properties
				Emitter.RainStraight.Transparency = straightSequence
				Emitter.RainStraight.Rotation = straightRotation
				Emitter.RainTopDown.Transparency = topdownSequence
				
			end
			
			-- Reset frame counter
			frame = 0
			
		end
		
		local center = workspace.CurrentCamera.CFrame.p
		local right = workspace.CurrentCamera.CFrame.lookVector:Cross(-rainDirection)
		right = right.magnitude > 0.001 and right.unit or -rainDirection
		local forward = rainDirection:Cross(right).unit
		local transform = CFrame.new(
			center.x, center.y, center.z,
			right.x, -rainDirection.x, forward.x,
			right.y, -rainDirection.y, forward.y,
			right.z, -rainDirection.z, forward.z
		)
		local rayDirection = rainDirection * RAIN_OCCLUDECHECK_SCAN_Y
		
		-- Splash and occlusion effects
		for i = 1, numSplashes do
			
			local splashAttachment = splashAttachments[i]
			local rainAttachment = rainAttachments[i]
			
			-- Sample random splash position
			local x = rand:NextNumber(RAIN_OCCLUDECHECK_OFFSET_XZ_MIN, RAIN_OCCLUDECHECK_OFFSET_XZ_MAX)
			local z = rand:NextNumber(RAIN_OCCLUDECHECK_OFFSET_XZ_MIN, RAIN_OCCLUDECHECK_OFFSET_XZ_MAX)
			local part, position, normal = raycast(Ray.new(transform * v3(x, RAIN_OCCLUDECHECK_OFFSET_Y, z), rayDirection))
			
			if part then
				
				-- Draw a splash at hit
				splashAttachment.Position = position + normal * RAIN_SPLASH_CORRECTION_Y
				splashAttachment.RainSplash:Emit(1)
				
				if inside then
					
					-- Draw occlusion rain particles a little bit above the splash position
					local corrected = position - rainDirection * RAIN_SPLASH_STRAIGHT_OFFSET_Y
					if currentCeiling and corrected.Y > currentCeiling and rainDirection.Y < 0 then
						corrected = corrected + rainDirection * (currentCeiling - corrected.Y) / rainDirection.Y
					end
					rainAttachment.CFrame = transform - transform.p + corrected
					rainAttachment.RainStraight:Emit(intensityOccludedRain)
					rainAttachment.RainTopDown:Emit(intensityOccludedRain)
					
				end
				
			elseif inside then
				
				-- Draw occlusion rain particles on the XZ-position at around the camera's height
				local corrected = transform * v3(x, rand:NextNumber(RAIN_NOSPLASH_STRAIGHT_OFFSET_Y_MIN, RAIN_NOSPLASH_STRAIGHT_OFFSET_Y_MAX), z)
				if currentCeiling and corrected.Y > currentCeiling and rainDirection.Y < 0 then
					corrected = corrected + rainDirection * (currentCeiling - corrected.Y) / rainDirection.Y
				end
				rainAttachment.CFrame = transform - transform.p + corrected
				rainAttachment.RainStraight:Emit(intensityOccludedRain)
				rainAttachment.RainTopDown:Emit(intensityOccludedRain)
				
			end
			
		end
		
	end))

end

local function disconnectLoop()
	-- If present, disconnect all RunService connections
	if #connections > 0 then
		for _,v in pairs(connections) do
			v:disconnect()
		end
		connections = {}
	end
end

local function disableSound(tweenInfo)
	
	-- Tween the rain sound to be mute over a given easing function
	volumeTarget = 0
	local tween = TweenService:Create(Sound, tweenInfo, {Volume = 0})
	tween.Completed:connect(function(state)
		if state == Enum.PlaybackState.Completed then
			Sound:Stop()
		end
		tween:Destroy()
	end)
	tween:Play()
	
end

local function disable()
	
	disconnectLoop()
	
	-- Hide Emitter
	Emitter.RainStraight.Enabled = false
	Emitter.RainTopDown.Enabled = false
	Emitter.Size = MIN_SIZE
	
	-- Disable sound now if not tweened into disabled state beforehand
	if not disabled then
		disableSound(TweenInfo.new(RAIN_SOUND_FADEOUT_TIME))
	end
	
end

-- Shorthand for creating a tweenable "variable" using value object
local function makeProperty(valueObjectClass, defaultValue, setter)
	local valueObject = Instance.new(valueObjectClass)
	if defaultValue then
		valueObject.Value = defaultValue
	end
	valueObject.Changed:connect(setter)
	setter(valueObject.Value)
	return valueObject
end

local Color = makeProperty("Color3Value", RAIN_DEFAULT_COLOR, function(value)
	
	local value = ColorSequence.new(value)
	
	Emitter.RainStraight.Color = value
	Emitter.RainTopDown.Color = value
	
	for _,v in pairs(splashAttachments) do
		v.RainSplash.Color = value
	end
	for _,v in pairs(rainAttachments) do
		v.RainStraight.Color = value
		v.RainTopDown.Color = value
	end
	
end)

local function updateTransparency(value)
	
	local opacity = (1 - value) * (1 - GlobalModifier.Value)
	local transparency = 1 - opacity
	
	straightLowAlpha = RAIN_STRAIGHT_ALPHA_LOW * opacity + transparency
	topdownLowAlpha = RAIN_TOPDOWN_ALPHA_LOW * opacity + transparency
	
	local splashSequence = NumberSequence.new {
		NSK010;
		NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T1, opacity*RAIN_SPLASH_ALPHA_LOW + transparency, 0);
		NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T2, opacity*RAIN_SPLASH_ALPHA_LOW + transparency, 0);
		NSK110;
	}
	
	for _,v in pairs(splashAttachments) do
		v.RainSplash.Transparency = splashSequence
	end
	
end
local Transparency = makeProperty("NumberValue", RAIN_DEFAULT_TRANSPARENCY, updateTransparency)
GlobalModifier.Changed:connect(updateTransparency)

local SpeedRatio = makeProperty("NumberValue", RAIN_DEFAULT_SPEEDRATIO, function(value)
	
	Emitter.RainStraight.Speed = NumberRange.new(value * RAIN_STRAIGHT_MAX_SPEED)
	Emitter.RainTopDown.Speed = NumberRange.new(value * RAIN_TOPDOWN_MAX_SPEED)
	
end)

local IntensityRatio = makeProperty("NumberValue", RAIN_DEFAULT_INTENSITYRATIO, function(value)
	
	Emitter.RainStraight.Rate = RAIN_STRAIGHT_MAX_RATE * value
	Emitter.RainTopDown.Rate = RAIN_TOPDOWN_MAX_RATE * value
	
	intensityOccludedRain = math.ceil(RAIN_OCCLUDED_MAXINTENSITY * value)
	numSplashes = RAIN_SPLASH_NUM * value
	
end)

local LightEmission = makeProperty("NumberValue", RAIN_DEFAULT_LIGHTEMISSION, function(value)
	
	Emitter.RainStraight.LightEmission = value
	Emitter.RainTopDown.LightEmission = value
	
	for _,v in pairs(rainAttachments) do
		v.RainStraight.LightEmission = value
		v.RainTopDown.LightEmission = value
	end
	for _,v in pairs(splashAttachments) do
		v.RainSplash.LightEmission = value
	end
	
end)

local LightInfluence = makeProperty("NumberValue", RAIN_DEFAULT_LIGHTINFLUENCE, function(value)
	
	Emitter.RainStraight.LightInfluence = value
	Emitter.RainTopDown.LightInfluence = value
	
	for _,v in pairs(rainAttachments) do
		v.RainStraight.LightInfluence = value
		v.RainTopDown.LightInfluence = value
	end
	for _,v in pairs(splashAttachments) do
		v.RainSplash.LightInfluence = value
	end
	
end)

local RainDirection = makeProperty("Vector3Value", RAIN_DEFAULT_DIRECTION, function(value)
	if value.magnitude > 0.001 then
		rainDirection = value.unit
	end
end)


-- Exposed API:

local Rain = {}

Rain.CollisionMode = CollisionMode

function Rain:Enable(tweenInfo)
	
	if tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #1 to 'Enable' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	disconnectLoop() -- Just in case :Enable(..) is called multiple times on accident
	
	Emitter.RainStraight.Enabled = true
	Emitter.RainTopDown.Enabled = true
	Emitter.Parent = workspace.CurrentCamera
	
	for i = 1, RAIN_SPLASH_NUM do
		splashAttachments[i].Parent = workspace.Terrain
		rainAttachments[i].Parent = workspace.Terrain
	end
	
	if RunService:IsRunning() then -- don't need sound in studio preview, it won't work anyway
		SoundGroup.Parent = game:GetService("SoundService")
	end
	
	connectLoop()
	
	if tweenInfo then
		TweenService:Create(GlobalModifier, tweenInfo, {Value = 0}):Play()
	else
		GlobalModifier.Value = 0
	end
	
	if not Sound.Playing then
		Sound:Play()
		Sound.TimePosition = math.random()*Sound.TimeLength
	end
	
	disabled = false
	
end

function Rain:Disable(tweenInfo)
	
	if tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #1 to 'Disable' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	if tweenInfo then
		local tween = TweenService:Create(GlobalModifier, tweenInfo, {Value = 1})
		tween.Completed:connect(function(state)
			if state == Enum.PlaybackState.Completed then
				-- Only disable the rain completely once the visual effects are faded out
				disable()
			end
			tween:Destroy()
		end)
		tween:Play()
		-- Start tweening out sound now as well
		disableSound(tweenInfo)
	else
		GlobalModifier.Value = 1
		disable()
	end
	
	disabled = true
	
end

function Rain:SetColor(value, tweenInfo)
		
	if typeof(value) ~= "Color3" then
		error("bad argument #1 to 'SetColor' (Color3 expected, got " .. typeof(value) .. ")", 2)
	elseif tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #2 to 'SetColor' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	if tweenInfo then
		TweenService:Create(Color, tweenInfo, {Value = value}):Play()
	else
		Color.Value = value
	end
	
end

local function makeRatioSetter(methodName, valueObject)
	-- Shorthand because most of the remaining property setters are very similar
	return function(_, value, tweenInfo)
		
		if typeof(value) ~= "number" then
			error("bad argument #1 to '" .. methodName .. "' (number expected, got " .. typeof(value) .. ")", 2)
		elseif tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
			error("bad argument #2 to '" .. methodName .. "' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
		end
		
		value = math.clamp(value, 0, 1)
		
		if tweenInfo then
			TweenService:Create(valueObject, tweenInfo, {Value = value}):Play()
		else
			valueObject.Value = value
		end
		
	end
end

Rain.SetTransparency = makeRatioSetter("SetTransparency", Transparency)
Rain.SetSpeedRatio = makeRatioSetter("SetSpeedRatio", SpeedRatio)
Rain.SetIntensityRatio = makeRatioSetter("SetIntensityRatio", IntensityRatio)
Rain.SetLightEmission = makeRatioSetter("SetLightEmission", LightEmission)
Rain.SetLightInfluence = makeRatioSetter("SetLightInfluence", LightInfluence)

function Rain:SetVolume(volume, tweenInfo)
	
	if typeof(volume) ~= "number" then
		error("bad argument #1 to 'SetVolume' (number expected, got " .. typeof(volume) .. ")", 2)
	elseif tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #2 to 'SetVolume' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	if tweenInfo then
		TweenService:Create(SoundGroup, tweenInfo, {Volume = volume}):Play()
	else
		SoundGroup.Volume = volume
	end
	
end

function Rain:SetDirection(direction, tweenInfo)
	
	if typeof(direction) ~= "Vector3" then
		error("bad argument #1 to 'SetDirection' (Vector3 expected, got " .. typeof(direction) .. ")", 2)
	elseif tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #2 to 'SetDirection' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	if not (direction.unit.magnitude > 0) then -- intentional statement formatting since NaN comparison
		warn("Attempt to set rain direction to a zero-length vector, falling back on default direction = (" .. tostring(RAIN_DEFAULT_DIRECTION) .. ")")
		direction = RAIN_DEFAULT_DIRECTION
	end
	
	if tweenInfo then
		TweenService:Create(RainDirection, tweenInfo, {Value = direction}):Play()
	else
		RainDirection.Value = direction
	end
	
end

function Rain:SetCeiling(ceiling)
	
	if ceiling ~= nil and typeof(ceiling) ~= "number" then
		error("bad argument #1 to 'SetCeiling' (number expected, got " .. typeof(ceiling) .. ")", 2)
	end
	
	currentCeiling = ceiling
	
end

function Rain:SetStraightTexture(asset)
	
	if typeof(asset) ~= "string" then
		error("bad argument #1 to 'SetStraightTexture' (string expected, got " .. typeof(asset) .. ")", 2)
	end
	
	Emitter.RainStraight.Texture = asset
	
	for _,v in pairs(rainAttachments) do
		v.RainStraight.Texture = asset
	end
	
end

function Rain:SetTopDownTexture(asset)
	
	if typeof(asset) ~= "string" then
		error("bad argument #1 to 'SetStraightTexture' (string expected, got " .. typeof(asset) .. ")", 2)
	end
	
	Emitter.RainTopDown.Texture = asset
	
	for _,v in pairs(rainAttachments) do
		v.RainTopDown.Texture = asset
	end
	
end

function Rain:SetSplashTexture(asset)
	
	if typeof(asset) ~= "string" then
		error("bad argument #1 to 'SetStraightTexture' (string expected, got " .. typeof(asset) .. ")", 2)
	end
	
	for _,v in pairs(splashAttachments) do
		v.RainSplash.Texture = asset
	end
	
end

function Rain:SetSoundId(asset)
	
	if typeof(asset) ~= "string" then
		error("bad argument #1 to 'SetSoundId' (string expected, got " .. typeof(asset) .. ")", 2)
	end
	
	Sound.SoundId = asset
	
end

function Rain:SetCollisionMode(mode, param)
	
	if mode == CollisionMode.None then
		
		-- Regular mode needs no white/blacklist or test function
		collisionList = nil
		collisionFunc = nil
		
	elseif mode == CollisionMode.Blacklist then
		
		if typeof(param) == "Instance" then
			-- Add Emitter anyway, since users will probably not expect collisions with emitter block regardless
			collisionList = {param, Emitter}
		elseif typeof(param) == "table" then
			for i = 1, #param do
				if typeof(param[i]) ~= "Instance" then
					error("bad argument #2 to 'SetCollisionMode' (blacklist contained a " .. typeof(param[i]) .. " on index " .. tostring(i) .. " which is not an Instance)", 2)
				end
			end
			collisionList = {Emitter} -- see above
			for i = 1, #param do
				table.insert(collisionList, param[i])
			end
		else
			error("bad argument #2 to 'SetCollisionMode (Instance or array of Instance expected, got " .. typeof(param) .. ")'", 2)
		end
		
		-- Blacklist does not need a test function
		collisionFunc = nil
		
	elseif mode == CollisionMode.Whitelist then
		
		if typeof(param) == "Instance" then
			collisionList = {param}
		elseif typeof(param) == "table" then
			for i = 1, #param do
				if typeof(param[i]) ~= "Instance" then
					error("bad argument #2 to 'SetCollisionMode' (whitelist contained a " .. typeof(param[i])  .. " on index " .. tostring(i) .. " which is not an Instance)", 2)
				end
			end
			collisionList = {}
			for i = 1, #param do
				table.insert(collisionList, param[i])
			end
		else
			error("bad argument #2 to 'SetCollisionMode (Instance or array of Instance expected, got " .. typeof(param) .. ")'", 2)
		end
		
		-- Whitelist does not need a test function
		collisionFunc = nil
		
	elseif mode == CollisionMode.Function then
		
		if typeof(param) ~= "function" then
			error("bad argument #2 to 'SetCollisionMode' (function expected, got " .. typeof(param) .. ")", 2)
		end
		
		-- Test function does not need a list
		collisionList = nil
		
		collisionFunc = param
		
	else
		error("bad argument #1 to 'SetCollisionMode (Rain.CollisionMode expected, got " .. typeof(param) .. ")'", 2)
	end
	
	collisionMode = mode
	raycast = raycastFunctions[mode]
	
end

return Rain


------------------------------------------------------------
-- PATH: StarterPlayer.StarterCharacterScripts.PowerBar UI + Throwing Handler
-- TYPE: LocalScript
------------------------------------------------------------
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for RemoteEvent
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local throwMemeEvent = remoteEvents:WaitForChild("ThrowMemeEvent")

-- Create UI
local screenGui = playerGui:WaitForChild("ThrowingUI")

-- Power bar background (vertical)
local powerBarBg = screenGui:WaitForChild("PowerBarBackground")

local gradientFrame = powerBarBg.Frame
local gradientCorner = gradientFrame.UICorner
local gradient = gradientFrame.UIGradient

-- Moving indicator
local indicator = powerBarBg.Indicator

-- ---------------------------------------------------------
-- LOGIC
-- ---------------------------------------------------------

local isLoopActive = false
local currentPower = 0
local powerDirection = 1
local POWER_SPEED = 0.02

local function updatePowerBar()
	while isLoopActive and screenGui.Enabled do
		task.wait()
		currentPower = currentPower + (POWER_SPEED * powerDirection)
		if currentPower >= 1 then
			currentPower = 1
			powerDirection = -1
		elseif currentPower <= 0.01 then
			currentPower = 0.01
			powerDirection = 1
		end
		indicator.Position = UDim2.new(0, 0, currentPower, -4)
	end
end

local function getPowerPercentage()
	local distanceFromCenter = math.abs(currentPower - 0.5)
	local powerPercent = 1 - (distanceFromCenter * 2) 
	return math.max(0.01, powerPercent) 
end

local function getCurrentColor()
	local power = currentPower
	if power < 0.25 then
		local t = power / 0.25
		return Color3.fromRGB(220, 50 + (150 * t), 50)
	elseif power < 0.5 then
		local t = (power - 0.25) / 0.25
		return Color3.fromRGB(240 - (190 * t), 200 + (20 * t), 50 + (170 * t))
	elseif power < 0.75 then
		local t = (power - 0.5) / 0.25
		return Color3.fromRGB(50 + (190 * t), 220 - (20 * t), 220 - (170 * t))
	else
		local t = (power - 0.75) / 0.25
		return Color3.fromRGB(240 - (20 * t), 200 - (150 * t), 50)
	end
end

local function throwMeme(targetPosition)
	if not screenGui.Enabled or not isLoopActive then return end

	isLoopActive = false
	local powerPercent = getPowerPercentage()

	-- Visual feedback
	local lockColor = getCurrentColor()
	indicator.BackgroundColor3 = lockColor

	-- Handle default target if none provided (e.g. Spacebar)
	if not targetPosition then
		if player.Character and player.Character.PrimaryPart then
			targetPosition = player.Character.PrimaryPart.Position + (player.Character.PrimaryPart.CFrame.LookVector * 100)
		else
			targetPosition = Vector3.new(0, 0, 0)
		end
	end

	-- Send Power AND Position to server
	throwMemeEvent:FireServer(powerPercent, targetPosition)

	task.wait(0.5)

	if screenGui.Enabled then
		indicator.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		isLoopActive = true
		task.spawn(updatePowerBar)
	end
end

-- ---------------------------------------------------------
-- INPUT HANDLING (Click Anywhere Logic)
-- ---------------------------------------------------------

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	-- 1. If tool is not equipped, ignore everything
	if not screenGui.Enabled then return end

	-- 2. If user clicked a UI element (like chat), ignore
	if gameProcessed then return end

	-- 3. Check for Click (PC) or Touch (Mobile)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or
		input.UserInputType == Enum.UserInputType.Touch then

		-- Use the mouse 3D position
		if mouse.Hit then
			throwMeme(mouse.Hit.Position)
		end
	end
end)

-- ---------------------------------------------------------
-- EQUIP / UNEQUIP HANDLING
-- ---------------------------------------------------------
local THROW_TOOL_NAME = "Tool" -- change to your actual tool name

local function bindTool(tool)
	if tool.Name ~= THROW_TOOL_NAME then return end

	tool.Equipped:Connect(function()
		screenGui.Enabled = true
		isLoopActive = true
		currentPower = 0.01
		indicator.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		task.spawn(updatePowerBar)
	end)

	tool.Unequipped:Connect(function()
		screenGui.Enabled = false
		isLoopActive = false
	end)
end

local function setupCharacter(character)
	-- Bind already-equipped tools
	for _, child in ipairs(character:GetChildren()) do
		if child:IsA("Tool") then
			bindTool(child)
		end
	end

	-- Bind future tools
	character.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			bindTool(child)
		end
	end)
end

if player.Character then
	setupCharacter(player.Character)
end

player.CharacterAdded:Connect(setupCharacter)



------------------------------------------------------------
-- PATH: StarterPlayer.StarterCharacterScripts.BrainrotHold
-- TYPE: LocalScript
------------------------------------------------------------
-- Put this in StarterPlayer > StarterCharacterScripts
-- This will automatically position ANY tool with a Rarity attribute above the player's head
local brainrotevent = game.ReplicatedStorage.RemoteEvents.pickupbrainrot
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = script.Parent
local humanoid = character:WaitForChild("Humanoid")
local dropgui = player.PlayerGui:WaitForChild("DropBrainrotGui")
-- Wait for necessary body parts
local head = character:WaitForChild("Head")
local rootPart = character:WaitForChild("HumanoidRootPart")
local leftShoulder = character:WaitForChild("LeftUpperArm", 5)
local rightShoulder = character:WaitForChild("RightUpperArm", 5)

-- Track current brainrot tool
local currentBrainrotTool = nil
local customWeld = nil
local leftArmWeld = nil
local rightArmWeld = nil
local originalCollisionStates = {}

-- Arm raising animation setup
local function raiseArms()
	if not leftShoulder or not rightShoulder then return end

	if not leftArmWeld then
		leftArmWeld = Instance.new("Weld")
		leftArmWeld.Name = "LeftArmRaise"
		leftArmWeld.Part0 = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
		leftArmWeld.Part1 = leftShoulder
		leftArmWeld.C0 = CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(180), 0, 0)
		leftArmWeld.Parent = leftArmWeld.Part0
	end

	if not rightArmWeld then
		rightArmWeld = Instance.new("Weld")
		rightArmWeld.Name = "RightArmRaise"
		rightArmWeld.Part0 = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
		rightArmWeld.Part1 = rightShoulder
		rightArmWeld.C0 = CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(180), 0, 0)
		rightArmWeld.Parent = rightArmWeld.Part0
	end
end

local function lowerArms()
	if leftArmWeld then
		leftArmWeld:Destroy()
		leftArmWeld = nil
	end
	if rightArmWeld then
		rightArmWeld:Destroy()
		rightArmWeld = nil
	end
end

-- Clean up physics objects that interfere with movement
local function cleanupPhysicsObjects(tool)
	local removedCount = 0

	for _, descendant in pairs(tool:GetDescendants()) do
		-- Remove BodyVelocity, BodyGyro, and other physics movers
		if descendant:IsA("BodyVelocity") or 
			descendant:IsA("BodyGyro") or 
			descendant:IsA("BodyPosition") or
			descendant:IsA("BodyForce") or
			descendant:IsA("BodyThrust") or
			descendant:IsA("BodyAngularVelocity") then
			descendant:Destroy()
			removedCount = removedCount + 1
		end
	end

	if removedCount > 0 then
		print("ðŸ§¹ Removed", removedCount, "physics objects")
	end
end

-- Disable collision on all brainrot parts
local function disableBrainrotCollision(tool)
	originalCollisionStates = {}
	local partsFound = 0

	for _, descendant in pairs(tool:GetDescendants()) do
		if descendant:IsA("BasePart") then
			partsFound = partsFound + 1
			originalCollisionStates[descendant] = descendant.CanCollide
			descendant.CanCollide = false
		end
	end

	print("ðŸ”§ Disabled collision on", partsFound, "parts")
end

-- Restore collision on all brainrot parts
local function restoreBrainrotCollision(tool)
	for part, originalState in pairs(originalCollisionStates) do
		if part and part.Parent then
			part.CanCollide = originalState
		end
	end

	originalCollisionStates = {}
end

local function positionBrainrotAboveHead(tool)
	local handle = tool:FindFirstChild("Handle")
	if not handle then 
		print("âŒ No Handle found!")
		return 
	end

	-- Destroy the default RightGrip
	local rightGrip = character:FindFirstChild("RightGrip")
	if rightGrip then
		rightGrip:Destroy()
	end

	-- CRITICAL: Remove physics objects that cause movement issues
	cleanupPhysicsObjects(tool)

	-- Disable collision
	disableBrainrotCollision(tool)

	-- Create custom weld to position above head
	customWeld = Instance.new("Weld")
	customWeld.Name = "BrainrotWeld"
	customWeld.Part0 = head
	customWeld.Part1 = handle
	customWeld.C0 = CFrame.new(0, 6, 0) * CFrame.Angles(0, 0, 0)
	customWeld.Parent = handle

	-- Raise arms
	raiseArms()

	print("ðŸŽ’ Positioned brainrot above head:", tool.Name)
end

local function onToolEquipped(tool)
	if tool:GetAttribute("Rarity") then
		currentBrainrotTool = tool

		task.wait(0.05)

		positionBrainrotAboveHead(tool)
		dropgui.Enabled = true
	end
	
end

local function onToolUnequipped(tool)
	if tool == currentBrainrotTool then
		restoreBrainrotCollision(tool)

		if customWeld then
			customWeld:Destroy()
			customWeld = nil
		end

		lowerArms()

		currentBrainrotTool = nil
		dropgui.Enabled = false

	end
end


character.ChildAdded:Connect(function(child)
	if child:IsA("Tool") then
		onToolEquipped(child)
	end
end)

character.ChildRemoved:Connect(function(child)
	if child:IsA("Tool") then
		onToolUnequipped(child)
	end
end)

local equippedTool = character:FindFirstChildOfClass("Tool")
if equippedTool then
	onToolEquipped(equippedTool)
end
brainrotevent.OnClientEvent:Connect(function(brainrot)
	print(brainrot.Name)
end)
print("âœ… Brainrot Overhead Positioning loaded!")


------------------------------------------------------------
-- PATH: StarterGui.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

-- ðŸ› ï¸ Developer check
local function isDeveloper(p)
	if RunService:IsStudio() then return true end
	return p.UserId == game.CreatorId or p.UserId == 10378926133
end

if not isDeveloper(player) then return end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- ðŸ—‚ï¸ Register your debug panels here
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local DEBUG_PANELS = {
	{ guiName = "WeatherDebugUI",  frameName = "WeatherFrame",  label = "ðŸŒ¦ Weather"  },
	{ guiName = "DebugUI", frameName = "Frame",  label = "ðŸ§  Brainrot" },
	{ guiName = "MainUI", frameName = "Panel", label = "ðŸŽ² Random"},
	{guiName = "DevMoneyButton", frameName = "Frame", label = "ðŸ’¸ Money"}
}

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Build the container UI from scratch
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local PlayerGui = player:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "DebugContainerUI"
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 999
screenGui.Parent = PlayerGui

-- Outer frame
local frame = Instance.new("Frame")
frame.Name = "ContainerFrame"
frame.Size = UDim2.new(0, 200, 0, 40) -- starts minimized, expands below
frame.Position = UDim2.new(0, 10, 0, 10)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
frame.BorderSizePixel = 0
frame.Active = true
frame.Parent = screenGui

local frameCorner = Instance.new("UICorner")
frameCorner.CornerRadius = UDim.new(0, 6)
frameCorner.Parent = frame

-- Title bar
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 36)
titleBar.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
titleBar.BorderSizePixel = 0
titleBar.Active = true
titleBar.Parent = frame

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 6)
titleCorner.Parent = titleBar

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, -40, 1, 0)
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "ðŸ›  Debug Panel"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 13
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleBar

local minimizeBtn = Instance.new("TextButton")
minimizeBtn.Size = UDim2.new(0, 30, 0, 30)
minimizeBtn.Position = UDim2.new(1, -34, 0, 3)
minimizeBtn.BackgroundColor3 = Color3.fromRGB(90, 90, 110)
minimizeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextSize = 16
minimizeBtn.Text = "âˆ’"
minimizeBtn.Parent = titleBar

local minCorner = Instance.new("UICorner")
minCorner.CornerRadius = UDim.new(0, 4)
minCorner.Parent = minimizeBtn

-- Panel list (vertical, below title bar)
local panelList = Instance.new("Frame")
panelList.Name = "PanelList"
panelList.Position = UDim2.new(0, 0, 0, 36)
panelList.Size = UDim2.new(1, 0, 0, 0) -- height driven by AutomaticSize
panelList.AutomaticSize = Enum.AutomaticSize.Y
panelList.BackgroundTransparency = 1
panelList.Parent = frame

local listLayout = Instance.new("UIListLayout")
listLayout.FillDirection = Enum.FillDirection.Vertical
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Padding = UDim.new(0, 4)
listLayout.Parent = panelList

local listPadding = Instance.new("UIPadding")
listPadding.PaddingTop = UDim.new(0, 6)
listPadding.PaddingBottom = UDim.new(0, 6)
listPadding.PaddingLeft = UDim.new(0, 6)
listPadding.PaddingRight = UDim.new(0, 6)
listPadding.Parent = panelList

-- Auto-resize outer frame to fit list
local function updateFrameHeight()
	frame.Size = UDim2.new(0, 200, 0, 36 + panelList.AbsoluteSize.Y)
end
panelList:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateFrameHeight)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Register panels
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for _, panel in ipairs(DEBUG_PANELS) do
	local debugGui = PlayerGui:WaitForChild(panel.guiName, 10)
	if not debugGui then
		warn("âŒ DebugContainer: Could not find '" .. panel.guiName .. "'")
		continue
	end
	local debugFrame = debugGui:WaitForChild(panel.frameName, 10)
	if not debugFrame then
		warn("âŒ DebugContainer: Could not find frame '" .. panel.frameName .. "'")
		continue
	end

	debugFrame.Visible = false

	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(1, 0, 0, 34)
	btn.BackgroundColor3 = Color3.fromRGB(50, 50, 65)
	btn.TextColor3 = Color3.fromRGB(220, 220, 255)
	btn.Font = Enum.Font.GothamMedium
	btn.TextSize = 13
	btn.Text = panel.label .. "  â—" -- â— = hidden
	btn.Parent = panelList

	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 4)
	btnCorner.Parent = btn

	print("âœ… DebugContainer: Registered '" .. panel.label .. "'")

	btn.MouseButton1Click:Connect(function()
		debugFrame.Visible = not debugFrame.Visible
		btn.Text = panel.label .. (debugFrame.Visible and "  â—‰" or "  â—")
		print("ðŸ” Toggled", panel.label, "â†’", debugFrame.Visible)
	end)
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Minimize / expand
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local expanded = true

minimizeBtn.MouseButton1Click:Connect(function()
	expanded = not expanded
	panelList.Visible = expanded
	minimizeBtn.Text = expanded and "âˆ’" or "+"
	if expanded then
		updateFrameHeight()
	else
		frame.Size = UDim2.new(0, 200, 0, 36)
	end
end)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Draggable
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local dragging, dragStart, startPos

titleBar.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = frame.Position
	end
end)

titleBar.InputChanged:Connect(function(input)
	if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(
			startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y
		)
	end
end)

titleBar.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = false
	end
end)


------------------------------------------------------------
-- PATH: StarterGui.ThrowingUI.ThrowBackground.UIStroke.UIGradient.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
if not game:IsLoaded() then game.Loaded:Wait() end

local grad = script.Parent
while true do
	grad.Rotation +=5
	wait()
end


------------------------------------------------------------
-- PATH: StarterGui.MainUI.Panel.TextButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local event = game.ReplicatedStorage.RemoteEvents.randombrainrot

local button = script.Parent
-- Find the RemoteFunction that the Server created
local getPassesFunc = ReplicatedStorage:WaitForChild("GetPasses")

local player = Players.LocalPlayer
local isDebounce = false -- Prevents spamming the button

-- ðŸ› ï¸ Helper: Check Developer Status
local function isDeveloper(player)
	-- Always allow in Studio
	if RunService:IsStudio() then
		return true
	end

	-- Allow if you are the owner OR if your ID matches
	return player.UserId == game.CreatorId or player.UserId == 1037892613 or player.UserId == 8834525880 -- Put your ID here
end

-- Hide button from non-developers
if not isDeveloper(player) then
	script.Parent.Visible = false
	return
end

button.MouseButton1Click:Connect(function()
	event:FireServer()
	if isDebounce then return end
	isDebounce = true

	print("ðŸ–±ï¸ CLIENT: Button Clicked! Calling Server...")
	button.Text = "Loading..."

	-- This sends the signal to 'BoothServer' script
	local items = getPassesFunc:InvokeServer()

	print("ðŸ–±ï¸ CLIENT: Server replied with " .. #items .. " items.")

	-- RESET THE BUTTON
	button.Text = "Refresh"
	isDebounce = false

	-- TODO: This is where you would update your scrolling frame
	-- For now, we just print the names to prove it works
	for _, item in ipairs(items) do
		print("   > Item: " .. item.name .. " - " .. item.price .. " R$")
	end
end)


------------------------------------------------------------
-- PATH: StarterGui.DebugUI.Spawn
-- TYPE: LocalScript
------------------------------------------------------------
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local brainrotsFolder = ReplicatedStorage:WaitForChild("Brainrot pack1")
local spawnEvent = ReplicatedStorage.RemoteEvents.SpawnSpecificBrainrot
--local spawnButton = script.Parent:WaitForChild("SpawnButton")

-- ðŸ› ï¸ Helper: Check Developer Status
local function isDeveloper(player)
	-- Always allow in Studio
	if RunService:IsStudio() then
		return true
	end

	-- Allow if you are the owner OR if your ID matches
	return player.UserId == game.CreatorId or player.UserId == 10378926133 -- Put your ID here
end

if not isDeveloper(player) then
	script.Parent.Enabled = false
	return
end

local gui = script.Parent
local frame = gui:WaitForChild("Frame")

local dropdownButton = frame:WaitForChild("DropdownButton")

local dropdown = frame:WaitForChild("Dropdown")
local template = dropdown:WaitForChild("Template")

-- Initial Setup
local selectedBrainrot = nil
dropdown.Visible = false
template.Visible = false -- Keep template hidden
dropdown.AutomaticSize = Enum.AutomaticSize.Y -- Force the frame to grow

-- ðŸ§  Populate dropdown
for _, brainrot in ipairs(brainrotsFolder:GetChildren()) do
	if brainrot:IsA("Model") or brainrot:IsA("BasePart") then
		local button = template:Clone()
		button.Visible = true
		button.Text = brainrot.Name
		button.Parent = dropdown

		button.MouseButton1Click:Connect(function()
			-- 1. TRACK START: See if the button even registers the click
			print("--- Dropdown Clicked: " .. brainrot.Name .. " ---")

			selectedBrainrot = brainrot.Name
			dropdownButton.Text = "Selected: " .. brainrot.Name
			dropdown.Visible = false

			-- 2. CHECK REMOTE: Verify the RemoteEvent actually exists
			if spawnEvent then
				spawnEvent:FireServer(brainrot.Name)
				-- 3. TRACK END: Confirm the instruction was sent to the server
				print("âœ… LocalScript: Sent spawn request for " .. brainrot.Name)
			else
				warn("âŒ LocalScript Error: spawnEvent is missing!")
			end
		end)
	end
end

-- Toggle dropdown
dropdownButton.MouseButton1Click:Connect(function()
	dropdown.Visible = not dropdown.Visible
	print("Dropdown is now:", dropdown.Visible)
end)

-- Spawn selected brainrot
--[[spawnButton.MouseButton1Click:Connect(function()
	if selectedBrainrot then
		spawnEvent:FireServer(selectedBrainrot)
	else
		warn("Select something first!")
	end
end)]]




------------------------------------------------------------
-- PATH: StarterGui.RebirthOpen.RebirthOpenButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

local openButton = script.Parent
local mainFrame = openButton.Parent.Parent.Rebirth.MainRebirthFrame
local badge = openButton:WaitForChild("Badge")

local player = Players.LocalPlayer
local leaderstats = player:WaitForChild("leaderstats")
local rebirths = leaderstats:WaitForChild("Rebirths")
local moneyRaw = player:WaitForChild("MoneyRaw")

-- Configuration (must match server)
local BASE_REBIRTH_COST = 100000
local COST_MULTIPLIER = 1.5

local function calculateCost(rebirthCount)
	return math.floor(BASE_REBIRTH_COST * (COST_MULTIPLIER ^ rebirthCount))
end

-- Update badge visibility (show red dot only when rebirth is affordable)
local function updateBadge()
	local currentCost = calculateCost(rebirths.Value)

	if moneyRaw.Value >= currentCost then
		badge.Visible = true -- Show red dot when can afford rebirth
	else
		badge.Visible = false -- Hide dot when can't afford
	end
end

moneyRaw.Changed:Connect(updateBadge)
rebirths.Changed:Connect(updateBadge)
updateBadge()

-- Open button click
openButton.MouseButton1Click:Connect(function()
	-- Hide open button
	local hideTween = TweenService:Create(openButton, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0)
	})
	hideTween:Play()
	hideTween.Completed:Wait()
	openButton.Visible = false

	-- Show main frame
	mainFrame.Visible = true
	mainFrame.Size = UDim2.new(0, 0, 0, 0)
	mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)

	local openTween = TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 380, 0, 480),
		Position = UDim2.new(0.5, -190, 0.5, -240)
	})
	openTween:Play()
end)

-- Hover effects
openButton.MouseEnter:Connect(function()
	local hoverTween = TweenService:Create(openButton, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 75, 0, 75),
		BackgroundColor3 = Color3.fromRGB(40, 40, 55)
	})
	hoverTween:Play()


end)

openButton.MouseLeave:Connect(function()
	local leaveTween = TweenService:Create(openButton, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 70, 0, 70),
		BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	})
	leaveTween:Play()

	
end)

-- Start with main frame hidden and open button visible
mainFrame.Visible = false
openButton.Visible = true


------------------------------------------------------------
-- PATH: StarterGui.Rebirth.MainRebirthFrame.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
script.Parent.Parent.Enabled= true

script.Parent.Visible = false
local player = Players.LocalPlayer
local leaderstats = player:WaitForChild("leaderstats")
local moneyRaw = player:WaitForChild("MoneyRaw")
local rebirths = leaderstats:WaitForChild("Rebirths")

local NumberFormat = require(ReplicatedStorage:WaitForChild("NumberFormat"))

local frame = script.Parent
local rebirthButton = frame:WaitForChild("RebirthButton")
local costLabel = frame:WaitForChild("CostContainer"):WaitForChild("CostLabel")
local progressBar = frame:WaitForChild("ProgressBarFrame")
local fillBar = progressBar:WaitForChild("FillBar")
local progressText = progressBar:WaitForChild("ProgressText")
local statusLabel = frame:WaitForChild("StatusLabel")
local currentRebirthsLabel = frame:WaitForChild("CurrentRebirthsLabel")
local rewardLabel = frame:WaitForChild("RewardContainer"):WaitForChild("RewardLabel")

-- Configuration (must match server)
local BASE_REBIRTH_COST = 100000
local COST_MULTIPLIER = 1.5

local function calculateCost(rebirthCount)
	return math.floor(BASE_REBIRTH_COST * (COST_MULTIPLIER ^ rebirthCount))
end



local function updateUI()
	local currentCost = calculateCost(rebirths.Value)
	local nextRebirthBonus = rebirths.Value + 1

	-- Update cost label
	costLabel.Text = "ðŸ’° Cost: $" .. NumberFormat.format(currentCost)

	-- Update current rebirths
	currentRebirthsLabel.Text = "Current Rebirths: " .. rebirths.Value

	-- Update reward label
	rewardLabel.Text = "ðŸŽ Next Rebirth Bonus\n+" .. nextRebirthBonus .. "x Multiplier"

	-- Update benefit label in confirmation

	-- Update progress bar
	local progress = math.min(moneyRaw.Value / currentCost, 1)
	progressText.Text = "$" .. NumberFormat.format(moneyRaw.Value) .. " / $" .. NumberFormat.format(currentCost)

	-- Animate fill bar
	local targetSize = UDim2.new(progress, 0, 1, 0)
	local fillTween = TweenService:Create(fillBar, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = targetSize
	})
	fillTween:Play()

	-- Update button state
	if moneyRaw.Value >= currentCost then
		-- Can afford rebirth - enable button
		rebirthButton.BackgroundColor3 = Color3.fromRGB(255, 170, 0)
		rebirthButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		local buttonStroke = rebirthButton:FindFirstChild("UIStroke")
		if buttonStroke then
			buttonStroke.Color = Color3.fromRGB(255, 200, 0)
		end
		local buttonGradient = rebirthButton:FindFirstChild("UIGradient")
		if buttonGradient then
			buttonGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 190, 50)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 140, 0))
			}
		end

		statusLabel.Text = "âœ… Ready to rebirth!"
		statusLabel.TextColor3 = Color3.fromRGB(100, 255, 150)

		-- Change fill bar color to green
		fillBar.BackgroundColor3 = Color3.fromRGB(100, 255, 150)
		local fillGradient = fillBar:FindFirstChild("UIGradient")
		if fillGradient then
			fillGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(120, 255, 170)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(80, 220, 130))
			}
		end
	else
		-- Cannot afford - disable button
		rebirthButton.BackgroundColor3 = Color3.fromRGB(120, 120, 130)
		rebirthButton.TextColor3 = Color3.fromRGB(180, 180, 190)
		local buttonStroke = rebirthButton:FindFirstChild("UIStroke")
		if buttonStroke then
			buttonStroke.Color = Color3.fromRGB(100, 100, 110)
		end
		local buttonGradient = rebirthButton:FindFirstChild("UIGradient")
		if buttonGradient then
			buttonGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(140, 140, 150)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 100, 110))
			}
		end

		local needed = currentCost - moneyRaw.Value
		statusLabel.Text = "âŒ Need $" .. NumberFormat.format(needed) .. " more"
		statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)

		-- Keep fill bar blue
		fillBar.BackgroundColor3 = Color3.fromRGB(80, 200, 255)
		local fillGradient = fillBar:FindFirstChild("UIGradient")
		if fillGradient then
			fillGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 220, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 160, 255))
			}
		end
	end
end

-- Update UI when values change
moneyRaw.Changed:Connect(updateUI)
rebirths.Changed:Connect(updateUI)

-- Initial update
updateUI()


------------------------------------------------------------
-- PATH: StarterGui.Rebirth.MainRebirthFrame.RebirthButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local rebirthevent = ReplicatedStorage.RemoteEvents:WaitForChild("rebirthevent")
local rebirthButton = script.Parent

-- Button click - rebirth immediately (no confirmation)
rebirthButton.MouseButton1Click:Connect(function()
	print("Rebirth button clicked!") -- Debug

	-- Check if button is enabled using attribute (set by the UI update script)
	if rebirthButton:GetAttribute("Disabled") == true then
		print("Button is disabled") -- Debug
		return
	end

	print("Firing rebirth event to server") -- Debug

	-- Fire rebirth event immediately
	rebirthevent:FireServer()
end)

-- Listen for server response
rebirthevent.OnClientEvent:Connect(function(success, data)
	if success then
		print("Successfully rebirthed! New rebirth count: " .. data)
		-- Optional: Play success sound, effects, etc.
	else
		print("Rebirth failed! Need: $" .. data)
		-- Optional: Play error sound
	end
end)


------------------------------------------------------------
-- PATH: StarterGui.Rebirth.MainRebirthFrame.CloseButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local TweenService = game:GetService("TweenService")

local closeButton = script.Parent
local mainFrame = closeButton.Parent
local openButton = mainFrame.Parent.Parent.RebirthOpen:WaitForChild("RebirthOpenButton")

closeButton.MouseButton1Click:Connect(function()
	-- Hide confirmation frame if it's open
	

	-- Animate main frame closing
	local closeTween = TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0)
	})
	closeTween:Play()
	closeTween.Completed:Wait()
	mainFrame.Visible = false

	-- Show open button
	openButton.Visible = true
	openButton.Size = UDim2.new(0, 0, 0, 0)
	local openTween = TweenService:Create(openButton, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 70, 0, 70)
	})
	openTween:Play()

	-- Button press animation
	closeButton.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
	wait(0.1)
	closeButton.BackgroundColor3 = Color3.fromRGB(220, 70, 70)
end)

-- Hover effects
closeButton.MouseEnter:Connect(function()
	local hoverTween = TweenService:Create(closeButton, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 45, 0, 45),
		BackgroundColor3 = Color3.fromRGB(255, 100, 100)
	})
	hoverTween:Play()
end)

closeButton.MouseLeave:Connect(function()
	local leaveTween = TweenService:Create(closeButton, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 40, 0, 40),
		BackgroundColor3 = Color3.fromRGB(220, 70, 70)
	})
	leaveTween:Play()
end)


------------------------------------------------------------
-- PATH: StarterGui.DropBrainrotGui.DropBrainrotButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local but = script.Parent
local usr = game:GetService("UserInputService")
local player = game.Players.LocalPlayer
local character = player.Character
local brainrots = game.ReplicatedStorage["Brainrot pack1"]

but.MouseButton1Click:Connect(function()
	if but.Parent.Enabled == true then
		local items = character:GetChildren()
		for i, item in pairs(items) do
			if item:IsA("Tool") then
				item:Destroy()
			
			end
		end
		but.Enabled = false
		wait(1)
	end
end)


------------------------------------------------------------
-- PATH: StarterGui.Items Shop.openShop
-- TYPE: LocalScript
------------------------------------------------------------
local ProximityPrompt = workspace:WaitForChild("WeaponsUpgradesShop"):WaitForChild("WeaponsStation"):WaitForChild("ProximityPrompt")
local screenGui = script.Parent
local closeButton = screenGui:WaitForChild("MainFrame").TitleBar:WaitForChild("CloseButton") -- Adjust paths

-- Handle Opening
ProximityPrompt.Triggered:Connect(function()
	screenGui.Enabled = true
end)

-- Handle Closing
closeButton.MouseButton1Click:Connect(function()
	screenGui.Enabled = false
end)


------------------------------------------------------------
-- PATH: StarterGui.Items Shop.MainFrame.TitleBar.CloseButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local usr = game:GetService('UserInputService')
local gui = script.Parent.Parent.Parent.Parent
script.Parent.MouseButton1Click:Connect(function()
	gui.Enabled = false
end)


------------------------------------------------------------
-- PATH: StarterGui.Items Shop.MainFrame.ItemsContainer.Speed Coil.BuyButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")

-- DATA
local event = ReplicatedStorage.RemoteEvents.Purchasecoil -- Make sure this matches the specific coil for each script!
local button = script.Parent
local player = Players.LocalPlayer
local moneyRaw = player:WaitForChild("MoneyRaw")

-- GUI SETUP
local purchaseGui = player:WaitForChild("PlayerGui"):WaitForChild("PurchaseGui")

-- [[ FIX 1: FORCE GUI TO FRONT ]] --
-- This ensures this GUI always sits on top of your Shop GUI
purchaseGui.DisplayOrder = 100 

local fundsFrame = purchaseGui:WaitForChild("funds")
local ownershipFrame = purchaseGui:WaitForChild("ownership")

-- Set frames to start at top middle (centered and hidden)
fundsFrame.AnchorPoint = Vector2.new(0.5, 0)
fundsFrame.Position = UDim2.new(0.5, 0, -0.3, 0) -- Moved higher up so it doesn't peek
fundsFrame.Visible = false

ownershipFrame.AnchorPoint = Vector2.new(0.5, 0)
ownershipFrame.Position = UDim2.new(0.5, 0, -0.3, 0)
ownershipFrame.Visible = false

-- VARIABLES
local haspurchased = false
local currentTween = nil
local hideTask = nil

local function showNotification(frame)
	-- 1. CANCEL OLD TIMERS
	if hideTask then
		task.cancel(hideTask)
		hideTask = nil
	end

	-- 2. STOP CURRENT MOTION
	if currentTween then
		currentTween:Cancel()
	end

	-- 3. RESET (Make sure it's visible and on top)
	frame.Visible = true
	frame.ZIndex = 100 -- Extra safety

	-- If frame is currently hidden (off screen), reset it to start position
	if frame.Position.Y.Scale < 0 then
		frame.Position = UDim2.new(0.5, 0, -0.3, 0)
	end

	-- [[ FIX 2: SLOWER ANIMATION ]] --
	-- Changed from 0.8 to 1.2 for a slower, floatier drop
	local dropInfo = TweenInfo.new(
		1.2, 
		Enum.EasingStyle.Elastic, 
		Enum.EasingDirection.Out
	)

	currentTween = TweenService:Create(frame, dropInfo, {
		Position = UDim2.new(0.5, 0, 0.15, 0)
	})
	currentTween:Play()

	-- 4. WAIT & HIDE
	hideTask = task.spawn(function()
		task.wait(2.0) -- Increased wait time so you can read it (was 1.2)

		local upInfo = TweenInfo.new(
			0.6, -- Slower exit (was 0.4)
			Enum.EasingStyle.Back,
			Enum.EasingDirection.In
		)

		currentTween = TweenService:Create(frame, upInfo, {
			Position = UDim2.new(0.5, 0, -0.3, 0)
		})
		currentTween:Play()
		currentTween.Completed:Wait()

		frame.Visible = false -- Hide it completely after it goes up
		hideTask = nil
		currentTween = nil
	end)
end

-- BUTTON CLICK
button.MouseButton1Click:Connect(function()
	-- CHANGE THE PRICE HERE PER SCRIPT (e.g. 500 or 800)
	local PRICE = 800 
	local ITEM_NAME = "SpeedCoil" -- Change to "SpeedCoil" for the other script

	if moneyRaw.Value >= PRICE and not haspurchased then
		event:FireServer(ITEM_NAME)
		haspurchased = true
		button.Text = "OWNED"
		button.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
	elseif haspurchased then
		showNotification(ownershipFrame)
	elseif moneyRaw.Value < PRICE then
		showNotification(fundsFrame)
	end
end)


------------------------------------------------------------
-- PATH: StarterGui.Items Shop.MainFrame.ItemsContainer.SuperSpeed Coil.BuyButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")

-- DATA
local event = ReplicatedStorage.RemoteEvents.Purchasecoil -- Make sure this matches the specific coil for each script!
local button = script.Parent
local player = Players.LocalPlayer
local moneyRaw = player:WaitForChild("MoneyRaw")

-- GUI SETUP
local purchaseGui = player:WaitForChild("PlayerGui"):WaitForChild("PurchaseGui")

-- [[ FIX 1: FORCE GUI TO FRONT ]] --
-- This ensures this GUI always sits on top of your Shop GUI
purchaseGui.DisplayOrder = 100 

local fundsFrame = purchaseGui:WaitForChild("funds")
local ownershipFrame = purchaseGui:WaitForChild("ownership")

-- Set frames to start at top middle (centered and hidden)
fundsFrame.AnchorPoint = Vector2.new(0.5, 0)
fundsFrame.Position = UDim2.new(0.5, 0, -0.3, 0) -- Moved higher up so it doesn't peek
fundsFrame.Visible = false

ownershipFrame.AnchorPoint = Vector2.new(0.5, 0)
ownershipFrame.Position = UDim2.new(0.5, 0, -0.3, 0)
ownershipFrame.Visible = false

-- VARIABLES
local haspurchased = false
local currentTween = nil
local hideTask = nil

local function showNotification(frame)
	-- 1. CANCEL OLD TIMERS
	if hideTask then
		task.cancel(hideTask)
		hideTask = nil
	end

	-- 2. STOP CURRENT MOTION
	if currentTween then
		currentTween:Cancel()
	end

	-- 3. RESET (Make sure it's visible and on top)
	frame.Visible = true
	frame.ZIndex = 100 -- Extra safety

	-- If frame is currently hidden (off screen), reset it to start position
	if frame.Position.Y.Scale < 0 then
		frame.Position = UDim2.new(0.5, 0, -0.3, 0)
	end

	-- [[ FIX 2: SLOWER ANIMATION ]] --
	-- Changed from 0.8 to 1.2 for a slower, floatier drop
	local dropInfo = TweenInfo.new(
		1.2, 
		Enum.EasingStyle.Elastic, 
		Enum.EasingDirection.Out
	)

	currentTween = TweenService:Create(frame, dropInfo, {
		Position = UDim2.new(0.5, 0, 0.15, 0)
	})
	currentTween:Play()

	-- 4. WAIT & HIDE
	hideTask = task.spawn(function()
		task.wait(2.0) -- Increased wait time so you can read it (was 1.2)

		local upInfo = TweenInfo.new(
			0.6, -- Slower exit (was 0.4)
			Enum.EasingStyle.Back,
			Enum.EasingDirection.In
		)

		currentTween = TweenService:Create(frame, upInfo, {
			Position = UDim2.new(0.5, 0, -0.3, 0)
		})
		currentTween:Play()
		currentTween.Completed:Wait()

		frame.Visible = false -- Hide it completely after it goes up
		hideTask = nil
		currentTween = nil
	end)
end

-- BUTTON CLICK
button.MouseButton1Click:Connect(function()
	-- CHANGE THE PRICE HERE PER SCRIPT (e.g. 500 or 800)
	local PRICE = 800 
	local ITEM_NAME = "SuperSpeedCoil" -- Change to "SpeedCoil" for the other script

	if moneyRaw.Value >= PRICE and not haspurchased then
		event:FireServer(ITEM_NAME)
		haspurchased = true
		button.Text = "OWNED"
		button.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
	elseif haspurchased then
		showNotification(ownershipFrame)
	elseif moneyRaw.Value < PRICE then
		showNotification(fundsFrame)
	end
end)


------------------------------------------------------------
-- PATH: StarterGui.WeatherDebugUI.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local forceWeatherEvent = ReplicatedStorage.RemoteEvents.ForceWeather

-- ðŸ› ï¸ Developer check (matches your existing script)
local function isDeveloper(p)
	if RunService:IsStudio() then return true end
	return p.UserId == game.CreatorId or p.UserId == 10378926133
end

if not isDeveloper(player) then
	script.Parent.Enabled = false
	return
end

local gui = script.Parent  -- this is now DebugUI
local frame = gui:WaitForChild("WeatherFrame")  -- name your new Frame whatever you like
local dropdownButton = frame:WaitForChild("DropdownButton")
local dropdown = frame:WaitForChild("Dropdown")
local template = dropdown:WaitForChild("Template")

-- Weather types (must match WeatherSystem module keys exactly)
local WEATHER_OPTIONS = {
	"Clear",
	"Bloodstorm",
	"Candyland",
	"Volcanic",
	"Galactic",
	"YinYang",
	"Radioactive", "Rain",
}

-- Initial setup
dropdown.Visible = false
template.Visible = false
dropdown.AutomaticSize = Enum.AutomaticSize.Y

-- Populate dropdown with weather options
for _, weatherName in ipairs(WEATHER_OPTIONS) do
	local button = template:Clone()
	button.Visible = true
	button.Text = weatherName
	button.Parent = dropdown

	button.MouseButton1Click:Connect(function()
		print("--- Weather Selected: " .. weatherName .. " ---")
		dropdownButton.Text = "Weather: " .. weatherName
		dropdown.Visible = false

		if forceWeatherEvent then
			forceWeatherEvent:FireServer(weatherName)
			print("âœ… LocalScript: Sent force weather request for " .. weatherName)
		else
			warn("âŒ LocalScript Error: forceWeatherEvent is missing!")
		end
	end)
end

-- Toggle dropdown
dropdownButton.MouseButton1Click:Connect(function()
	dropdown.Visible = not dropdown.Visible
	print("Weather dropdown is now:", dropdown.Visible)
end)

-- Toggle main frame (open button is the parent of this script)



------------------------------------------------------------
-- PATH: StarterGui.Base Surface.SurfaceGui.TextButton.Script
-- TYPE: Script
------------------------------------------------------------
local button = script.Parent
local runService = game:GetService("RunService")

local time = 0
local speed = 1
local buttonGradient = button.UIGradient
runService.Heartbeat:Connect(function(dt)
	time = time + dt * speed

	-- Animated diagonal movement (45 degrees = 0.785 radians)

	buttonGradient.Rotation = 45
	buttonGradient.Offset = Vector2.new(math.sin(time), math.cos(time))
end)


------------------------------------------------------------
-- PATH: StarterGui.Base Surface.SurfaceGui.TextButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local usr = game:GetService("UserInputService")
local parent = script.Parent
local event = game.ReplicatedStorage.RemoteEvents.UpgradeBase
parent.MouseButton1Click:Connect(function()
	print("SEOIFJSOIEJF")
	event:FireServer()
end)


------------------------------------------------------------
-- PATH: StarterGui.Base Surface.SurfaceGui_Base2.TextButton.Script
-- TYPE: Script
------------------------------------------------------------
local button = script.Parent
local runService = game:GetService("RunService")

local time = 0
local speed = 1
local buttonGradient = button.UIGradient
runService.Heartbeat:Connect(function(dt)
	time = time + dt * speed

	-- Animated diagonal movement (45 degrees = 0.785 radians)

	buttonGradient.Rotation = 45
	buttonGradient.Offset = Vector2.new(math.sin(time), math.cos(time))
end)


------------------------------------------------------------
-- PATH: StarterGui.Base Surface.SurfaceGui_Base2.TextButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local usr = game:GetService("UserInputService")
local parent = script.Parent
local event = game.ReplicatedStorage.RemoteEvents.UpgradeBase
parent.MouseButton1Click:Connect(function()
	print("SEOIFJSOIEJF")
	event:FireServer()
end)


------------------------------------------------------------
-- PATH: StarterGui.Base Surface.SurfaceGui_Base3.TextButton.Script
-- TYPE: Script
------------------------------------------------------------
local button = script.Parent
local runService = game:GetService("RunService")

local time = 0
local speed = 1
local buttonGradient = button.UIGradient
runService.Heartbeat:Connect(function(dt)
	time = time + dt * speed

	-- Animated diagonal movement (45 degrees = 0.785 radians)

	buttonGradient.Rotation = 45
	buttonGradient.Offset = Vector2.new(math.sin(time), math.cos(time))
end)


------------------------------------------------------------
-- PATH: StarterGui.Base Surface.SurfaceGui_Base3.TextButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local usr = game:GetService("UserInputService")
local parent = script.Parent
local event = game.ReplicatedStorage.RemoteEvents.UpgradeBase
parent.MouseButton1Click:Connect(function()
	print("SEOIFJSOIEJF")
	event:FireServer()
end)


------------------------------------------------------------
-- PATH: StarterGui.Base Surface.SurfaceGui_Base4.TextButton.Script
-- TYPE: Script
------------------------------------------------------------
local button = script.Parent
local runService = game:GetService("RunService")

local time = 0
local speed = 1
local buttonGradient = button.UIGradient
runService.Heartbeat:Connect(function(dt)
	time = time + dt * speed

	-- Animated diagonal movement (45 degrees = 0.785 radians)

	buttonGradient.Rotation = 45
	buttonGradient.Offset = Vector2.new(math.sin(time), math.cos(time))
end)


------------------------------------------------------------
-- PATH: StarterGui.Base Surface.SurfaceGui_Base4.TextButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local usr = game:GetService("UserInputService")
local parent = script.Parent
local event = game.ReplicatedStorage.RemoteEvents.UpgradeBase
parent.MouseButton1Click:Connect(function()
	print("SEOIFJSOIEJF")
	event:FireServer()
end)


------------------------------------------------------------
-- PATH: StarterGui.Base Surface.SurfaceGui_Base5.TextButton.Script
-- TYPE: Script
------------------------------------------------------------
local button = script.Parent
local runService = game:GetService("RunService")

local time = 0
local speed = 1
local buttonGradient = button.UIGradient
runService.Heartbeat:Connect(function(dt)
	time = time + dt * speed

	-- Animated diagonal movement (45 degrees = 0.785 radians)

	buttonGradient.Rotation = 45
	buttonGradient.Offset = Vector2.new(math.sin(time), math.cos(time))
end)


------------------------------------------------------------
-- PATH: StarterGui.Base Surface.SurfaceGui_Base5.TextButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local usr = game:GetService("UserInputService")
local parent = script.Parent
local event = game.ReplicatedStorage.RemoteEvents.UpgradeBase
parent.MouseButton1Click:Connect(function()
	print("SEOIFJSOIEJF")
	event:FireServer()
end)


------------------------------------------------------------
-- PATH: StarterGui.Base Surface.SurfaceGui_Base6.TextButton.Script
-- TYPE: Script
------------------------------------------------------------
local button = script.Parent
local runService = game:GetService("RunService")

local time = 0
local speed = 1
local buttonGradient = button.UIGradient
runService.Heartbeat:Connect(function(dt)
	time = time + dt * speed

	-- Animated diagonal movement (45 degrees = 0.785 radians)

	buttonGradient.Rotation = 45
	buttonGradient.Offset = Vector2.new(math.sin(time), math.cos(time))
end)


------------------------------------------------------------
-- PATH: StarterGui.Base Surface.SurfaceGui_Base6.TextButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local usr = game:GetService("UserInputService")
local parent = script.Parent
local event = game.ReplicatedStorage.RemoteEvents.UpgradeBase
parent.MouseButton1Click:Connect(function()
	print("SEOIFJSOIEJF")
	event:FireServer()
end)


------------------------------------------------------------
-- PATH: StarterGui.DevMoneyButton.Frame.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local addMoneyEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("AddMoneyRequest")

local frame = script.Parent
local textBox = frame:WaitForChild("TextBox")
local addButton = frame:WaitForChild("AddButton")

-- Add money
local function onAddButtonClicked()
	local amount = tonumber(textBox.Text)

	if not amount or amount <= 0 then
		warn("Invalid amount:", textBox.Text)
		return
	end

	addMoneyEvent:FireServer(amount)
	textBox.Text = ""
end

addButton.MouseButton1Click:Connect(onAddButtonClicked)



------------------------------------------------------------
-- PATH: ServerStorage.GetCodeDumps(does not run, commented)
-- TYPE: Script
------------------------------------------------------------
if false then
	local services = {
		game:GetService("ServerScriptService"),
		game:GetService("ReplicatedStorage"),
		game:GetService("StarterPlayer"),
		game:GetService("StarterGui"),
		game:GetService("StarterPack"),
		game:GetService("ServerStorage")
	}

	local dumpTable = {}
	for _, service in ipairs(services) do
		for _, obj in ipairs(service:GetDescendants()) do
			if obj:IsA("LuaSourceContainer") and obj.Name ~= "CODE_DUMP_V2" and obj.Name ~= "ALL_MY_CODE_DUMP" then
				local success, source = pcall(function() return obj.Source end)
				if success and source and source ~= "" then
					table.insert(dumpTable, string.rep("-", 60))
					table.insert(dumpTable, "-- PATH: " .. obj:GetFullName())
					table.insert(dumpTable, "-- TYPE: " .. obj.ClassName)
					table.insert(dumpTable, string.rep("-", 60))
					table.insert(dumpTable, source .. "\n\n")
				end
			end
		end
	end

	local finalSource = table.concat(dumpTable, "\n")
	local chunkSize = 150000 -- Well under the 200k limit
	local folder = Instance.new("Folder")
	folder.Name = "CodeDump_Parts"
	folder.Parent = game:GetService("ServerStorage")

	for i = 1, #finalSource, chunkSize do
		local chunk = string.sub(finalSource, i, i + chunkSize - 1)
		local scriptPart = Instance.new("Script")
		scriptPart.Name = "Part_" .. math.ceil(i/chunkSize)
		scriptPart.Source = "-- [[ CHUNK START ]] --\n" .. chunk
		scriptPart.Parent = folder
	end

	print("âœ… DONE! Created " .. math.ceil(#finalSource/chunkSize) .. " parts in ServerStorage > CodeDump_Parts")
end



------------------------------------------------------------
-- PATH: ServerStorage.SpeedCoil.SpeedUp
-- TYPE: Script
------------------------------------------------------------
--!strict
-- simplified speed coil by s_snaker

local BOOST = 16

local tool = script.Parent
local oldSpeed -- speed before equipping is saved in functions
local humanoid -- has to be a global so it can be used in onUnequip()
local sound = game.ReplicatedStorage.Sounds["Flash Step"]
function onEquip()
	sound.PlaybackSpeed = 1
	sound.Volume = 1

	humanoid = tool.Parent:FindFirstChild("Humanoid")
	if (humanoid ~= nil) then
		sound:Play()

		oldSpeed = humanoid.WalkSpeed
		humanoid.WalkSpeed = oldSpeed + BOOST
	end
end

function onUnequip()
	humanoid.WalkSpeed = oldSpeed
end

tool.Equipped:Connect(onEquip)
tool.Unequipped:Connect(onUnequip)


------------------------------------------------------------
-- PATH: ServerStorage.SuperSpeedCoil.Script
-- TYPE: Script
------------------------------------------------------------
--!strict
-- simplified speed coil by s_snaker

local BOOST = 320


local tool = script.Parent
local oldSpeed -- speed before equipping is saved in functions
local humanoid -- has to be a global so it can be used in onUnequip()
local sound = game.ReplicatedStorage.Sounds["Flash Step"]
function onEquip()
	humanoid = tool.Parent:FindFirstChild("Humanoid")
	sound.PlaybackSpeed = 1.25
	sound.Volume = 4

	if (humanoid ~= nil) then

		sound:Play()

		oldSpeed = humanoid.WalkSpeed
		humanoid.WalkSpeed = oldSpeed + BOOST
	end
end

function onUnequip()
	humanoid.WalkSpeed = oldSpeed
end

tool.Equipped:Connect(onEquip)
tool.Unequipped:Connect(onUnequip)


------------------------------------------------------------
-- PATH: ServerStorage.SuperSpeedCoil.Handle.Script
-- TYPE: Script
------------------------------------------------------------
function shiftColor(p)
	--coroutine.resume(coroutine.create(function(p)
		function u(n,i)
			if math.abs(n) < i then
				return n
			end
			return (Vector3.new(n,0,0).unit.x)*i
		end
		local new = Vector3.new(10/math.random(10,100),10/math.random(10,100),10/math.random(10,100))
		local dif = new - p.Mesh.VertexColor
		repeat
			local d = Vector3.new(u(dif.x,0.01),u(dif.y,0.01),u(dif.z,0.01))
			p.Mesh.VertexColor = p.Mesh.VertexColor + d
			dif = dif - d
			wait()
		until math.abs(dif.x) <= 0.03 and math.abs(dif.y) <= 0.03 and math.abs(dif.z) <= 0.03
	--end),p)
end

while true do
	wait()
	shiftColor(script.Parent)
end



------------------------------------------------------------
-- PATH: ServerStorage.SuperSpeedCoil.Handle.Sparkles.Script
-- TYPE: Script
------------------------------------------------------------
while true do 
i = 0
for n=1,0,-0.05 do 
i = i + 0.05
script.Parent.SparkleColor = Color3.new(i, 0, n)
wait() 
end  
i = 0
for n=1,0,-0.05 do 
i = i + 0.05
script.Parent.SparkleColor = Color3.new(n, i, 0)
wait()
end   
i = 0
for n=1,0,-0.05 do 
i = i + 0.05
script.Parent.SparkleColor = Color3.new(0, n, i)
wait() 
end 
end 


------------------------------------------------------------
-- PATH: ServerStorage.Rebirth.MainRebirthFrame.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
script.Parent.Visible = false
local player = Players.LocalPlayer
local leaderstats = player:WaitForChild("leaderstats")
local money = leaderstats.Parent:WaitForChild("MoneyRaw")
local rebirths = leaderstats:WaitForChild("Rebirths")

local frame = script.Parent
local rebirthButton = frame:WaitForChild("RebirthButton")
local costLabel = frame:WaitForChild("CostContainer"):WaitForChild("CostLabel")
local progressBar = frame:WaitForChild("ProgressBarFrame")
local fillBar = progressBar:WaitForChild("FillBar")
local progressText = progressBar:WaitForChild("ProgressText")
local statusLabel = frame:WaitForChild("StatusLabel")
local currentRebirthsLabel = frame:WaitForChild("CurrentRebirthsLabel")
local rewardLabel = frame:WaitForChild("RewardContainer"):WaitForChild("RewardLabel")

-- Configuration (must match server)
local BASE_REBIRTH_COST = 100000
local COST_MULTIPLIER = 1.5

local function calculateCost(rebirthCount)
	return math.floor(BASE_REBIRTH_COST * (COST_MULTIPLIER ^ rebirthCount))
end

local function formatNumber(num)
	if num >= 1000000000 then
		return string.format("%.2fB", num / 1000000000)
	elseif num >= 1000000 then
		return string.format("%.2fM", num / 1000000)
	elseif num >= 1000 then
		return string.format("%.2fK", num / 1000)
	else
		return tostring(num)
	end
end

local function updateUI()
	local currentCost = calculateCost(rebirths.Value)
	local nextRebirthBonus = rebirths.Value + 1

	-- Update cost label
	costLabel.Text = "ðŸ’° Cost: $" .. formatNumber(currentCost)

	-- Update current rebirths
	currentRebirthsLabel.Text = "Current Rebirths: " .. rebirths.Value

	-- Update reward label
	rewardLabel.Text = "ðŸŽ Next Rebirth Bonus\n+" .. nextRebirthBonus .. "x Multiplier"

	-- Update benefit label in confirmation

	-- Update progress bar
	local progress = math.min(money.Value / currentCost, 1)
	progressText.Text = "$" .. formatNumber(money.Value) .. " / $" .. formatNumber(currentCost)

	-- Animate fill bar
	local targetSize = UDim2.new(progress, 0, 1, 0)
	local fillTween = TweenService:Create(fillBar, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = targetSize
	})
	fillTween:Play()

	-- Update button state
	if money.Value >= currentCost then
		-- Can afford rebirth - enable button
		rebirthButton.BackgroundColor3 = Color3.fromRGB(255, 170, 0)
		rebirthButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		local buttonStroke = rebirthButton:FindFirstChild("UIStroke")
		if buttonStroke then
			buttonStroke.Color = Color3.fromRGB(255, 200, 0)
		end
		local buttonGradient = rebirthButton:FindFirstChild("UIGradient")
		if buttonGradient then
			buttonGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 190, 50)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 140, 0))
			}
		end

		statusLabel.Text = "âœ… Ready to rebirth!"
		statusLabel.TextColor3 = Color3.fromRGB(100, 255, 150)

		-- Change fill bar color to green
		fillBar.BackgroundColor3 = Color3.fromRGB(100, 255, 150)
		local fillGradient = fillBar:FindFirstChild("UIGradient")
		if fillGradient then
			fillGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(120, 255, 170)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(80, 220, 130))
			}
		end
	else
		-- Cannot afford - disable button
		rebirthButton.BackgroundColor3 = Color3.fromRGB(120, 120, 130)
		rebirthButton.TextColor3 = Color3.fromRGB(180, 180, 190)
		local buttonStroke = rebirthButton:FindFirstChild("UIStroke")
		if buttonStroke then
			buttonStroke.Color = Color3.fromRGB(100, 100, 110)
		end
		local buttonGradient = rebirthButton:FindFirstChild("UIGradient")
		if buttonGradient then
			buttonGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(140, 140, 150)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 100, 110))
			}
		end

		local needed = currentCost - money.Value
		statusLabel.Text = "âŒ Need $" .. formatNumber(needed) .. " more"
		statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)

		-- Keep fill bar blue
		fillBar.BackgroundColor3 = Color3.fromRGB(80, 200, 255)
		local fillGradient = fillBar:FindFirstChild("UIGradient")
		if fillGradient then
			fillGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 220, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 160, 255))
			}
		end
	end
end

-- Update UI when values change
money.Changed:Connect(updateUI)
rebirths.Changed:Connect(updateUI)

-- Initial update
updateUI()


------------------------------------------------------------
-- PATH: ServerStorage.Rebirth.MainRebirthFrame.RebirthButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local rebirthevent = ReplicatedStorage.RemoteEvents:WaitForChild("rebirthevent")
local rebirthButton = script.Parent

-- Button click - rebirth immediately (no confirmation)
rebirthButton.MouseButton1Click:Connect(function()
	print("Rebirth button clicked!") -- Debug

	-- Check if button is enabled using attribute (set by the UI update script)
	if rebirthButton:GetAttribute("Disabled") == true then
		print("Button is disabled") -- Debug
		return
	end

	print("Firing rebirth event to server") -- Debug

	-- Fire rebirth event immediately
	rebirthevent:FireServer()
end)

-- Listen for server response
rebirthevent.OnClientEvent:Connect(function(success, data)
	if success then
		print("Successfully rebirthed! New rebirth count: " .. data)
		-- Optional: Play success sound, effects, etc.
	else
		print("Rebirth failed! Need: $" .. data)
		-- Optional: Play error sound
	end
end)


------------------------------------------------------------
-- PATH: ServerStorage.Rebirth.MainRebirthFrame.CloseButton.LocalScript
-- TYPE: LocalScript
------------------------------------------------------------
local TweenService = game:GetService("TweenService")

local closeButton = script.Parent
local mainFrame = closeButton.Parent
local openButton = mainFrame.Parent.Parent.RebirthOpen:WaitForChild("RebirthOpenButton")

closeButton.MouseButton1Click:Connect(function()
	-- Hide confirmation frame if it's open
	

	-- Animate main frame closing
	local closeTween = TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0)
	})
	closeTween:Play()
	closeTween.Completed:Wait()
	mainFrame.Visible = false

	-- Show open button
	openButton.Visible = true
	openButton.Size = UDim2.new(0, 0, 0, 0)
	local openTween = TweenService:Create(openButton, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 70, 0, 70)
	})
	openTween:Play()

	-- Button press animation
	closeButton.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
	wait(0.1)
	closeButton.BackgroundColor3 = Color3.fromRGB(220, 70, 70)
end)

-- Hover effects
closeButton.MouseEnter:Connect(function()
	local hoverTween = TweenService:Create(closeButton, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 45, 0, 45),
		BackgroundColor3 = Color3.fromRGB(255, 100, 100)
	})
	hoverTween:Play()
end)

closeButton.MouseLeave:Connect(function()
	local leaveTween = TweenService:Create(closeButton, TweenInfo.new(0.2), {
		Size = UDim2.new(0, 40, 0, 40),
		BackgroundColor3 = Color3.fromRGB(220, 70, 70)
	})
	leaveTween:Play()
end)


F|S|Concentrator System(Path in Serverscriptservice)
-- ================================================================
--  WeatherConcentratorSystem  (ServerScriptService)
--
--  Players approach the WeatherConcentrator and trigger the
--  ProximityPrompt while holding a Brainrot tool.  It fuses the
--  currently active weather mutation onto that brainrot, stacking
--  infinitely.  Gemini blends all accumulated mutation names into
--  one creative label.  The first player globally to reach any
--  specific mutation combo earns a discovery bonus that scales
--  with how many mutations deep the combo is.
--
--  SETUP CHECKLIST
--  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--  1. Enable HttpService        (Game Settings â†’ Security)
--  2. Enable DataStoreService   (Game Settings â†’ Security)
--  3. Place a Model called "WeatherConcentrator" in Workspace
--       â””â”€ PrimaryPart  (BasePart â€” the glowing pedestal)
--          â””â”€ ProximityPrompt  (direct child of PrimaryPart)
--             If absent, one is created automatically.
--  4. Paste your Gemini API key into CONFIG.GEMINI_API_KEY.
--     For production: store it in a private ModuleScript under
--     ServerScriptService so it is never replicated to clients.
--  5. RECOMMENDED: Move BRAINROT_INCOME into a shared ModuleScript
--     (ReplicatedStorage/BrainrotIncomeData) and require it here
--     AND in BrainrotSlotSystem â€” keeps the two in sync.
-- ================================================================

local Players           = game:GetService("Players")
local HttpService       = game:GetService("HttpService")
local DataStoreService  = game:GetService("DataStoreService")
local TweenService      = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local WeatherSystem = require(ReplicatedStorage:WaitForChild("WeatherSystem"))

-- ================================================================
--  CONFIG
-- ================================================================
local CONFIG = {
	-- â”€â”€ Gemini â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	GEMINI_API_KEY  = "AIzaSyCizTajdzKJzX613YWD3HlV6FdtfAF-v-Y",
	GEMINI_MODEL    = "gemini-3-flash",

	-- â”€â”€ Craft cost â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	COST_SECONDS    = 45,
	MIN_COST        = 500,

	-- â”€â”€ Discovery rewards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	-- depth 1 â†’ 5,000   depth 2 â†’ 15,000   depth 3 â†’ 45,000  etc.
	BASE_DISCOVERY_REWARD = 5000,
	DEPTH_MULTIPLIER      = 3.0,

	-- â”€â”€ Misc â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	PLAYER_COOLDOWN          = 8,
	CONCENTRATOR_MODEL_NAME  = "WeatherConcentrator",
	DS_DISCOVERIES           = "ConcentratorDiscoveries_v2",
}

-- ================================================================
--  INCOME TABLE
-- ================================================================
local BRAINROT_INCOME = {
	["Noobini Pizzanini"]=1,["Lirili Larila"]=3,["Tim Cheese"]=5,
	["FluriFlura"]=7,["Talpa Di Fero"]=9,["Svinina Bombardino"]=10,
	["Noobini Santanini"]=11,["Racooni Jandelini"]=12,["Pipi Kiwi"]=13,
	["Tartaragno"]=13,["Pipi Corni"]=14,["Trippi Troppi"]=15,
	["Gangster Footera"]=30,["Bandito Bobritto"]=35,["Boneca Ambalabu"]=40,
	["Cacto Hipopotamo"]=50,["Ta Ta Ta Ta Sahur"]=55,["Tric Trac Baraboom"]=65,
	["Frogo Elfo"]=67,["Pipi Avocado"]=70,["Pinealotto Fruttarino"]=75,
	["Cappuccino Assassino"]=75,["Bandito Axolito"]=90,["Brr Brr Patapim"]=100,
	["Avocadini Antilopini"]=115,["Trulimero Trulicina"]=125,["Bambini Crostini"]=135,
	["Malame Amarele"]=140,["Bananita Dolphinita"]=150,["Perochello Lemonchello"]=160,
	["Brri Brri Bicus Dicus Bombicus"]=175,["Avocadini Guffo"]=225,
	["Ti Ti Ti Sahur"]=225,["Mangolini Parrocini"]=235,["Frogatto Piratto"]=240,
	["Salamino Penguino"]=250,["Doi Doi Do"]=260,["Penguin Tree"]=270,
	["Wombo Rollo"]=275,["Penguino Cocosino"]=300,["Mummio Rappito"]=325,
	["Chimpanzini Bananini"]=300,["Tirilikalika Tirilikalako"]=450,
	["Ballerina Cappuccina"]=500,["Burbaloni Loliloli"]=600,
	["Chef Crabracadabra"]=600,["Lionel Cactuseli"]=650,
	["Glorbo Fruttodrillo"]=750,["Quivoli Ameleoni"]=900,
	["Blueberrini Octopusini"]=1000,["Caramello Filtrello"]=1000,
	["Pipi Potato"]=1100,["Strawberrelli Flamingelli"]=1100,
	["Cocosini Mama"]=1200,["Pandaccini Bananini"]=1250,["Quackula"]=1200,
	["Pi Pi Watermelon"]=1300,["Signore Carapace"]=1300,["Sigma Boy"]=1350,
	["Chocco Bunny"]=1400,["Puffaball"]=1500,["Sigma Girl"]=1800,
	["Buho de Fuego"]=1800,["Frigo Camelo"]=1900,
	["Orangutini Ananassini"]=2000,["Rhino Toasterino"]=2100,
	["Bombardiro Crocodilo"]=2500,["Spioniro Golubiro"]=3500,
	["Bangangini Gusini"]=5000,["Zibra Zubra Zibralini"]=6000,
	["Tigrilini Watermelini"]=6500,["Avocadorilla"]=7000,
	["Cavallo Virtuoso"]=7500,["Gorillo Subwoofero"]=7700,
	["Gorillo Watermelondrillo"]=8000,["Stoppo Luminino"]=8000,
	["Ganganzelli Trulala"]=9000,["Lerulerulerule"]=8700,
	["Tob Tobi Tobi"]=8500,["Te Te Te Sahur"]=9500,
	["Rhino Helicopterino"]=11000,["Magi Ribbitini"]=11500,
	["Tracoducotulu Delapeladustuz"]=12000,["Jingle Jingle Sahur"]=12200,
	["Los Noobinis"]=12500,["Cachorrito Melonito"]=13000,["Carloo"]=13500,
	["Elefanto Frigo"]=14000,["Carrotini Brainini"]=15000,
	["Centrucci Nuclucci"]=15500,["Jacko Spaventosa"]=16200,
	["Toiletto Focaccino"]=16000,["Bananito Bandito"]=16500,
	["Tree Tree Tree Sahur"]=17000,["Cocofanto Elefanto"]=17500,
	["Antonio"]=18500,["Girafa Celestre"]=20000,
	["Gattatino Neonino"]=35000,["Gattatino Nyanino"]=35000,
	["Chihuanini Taconini"]=45000,["Matteo"]=50000,
	["Tralalero Tralala"]=50000,["Los Crocodillitos"]=55000,
	["Tigroligre Frutonni"]=60000,["Espresso Signora"]=70000,
	["Odin Din Din Dun"]=75000,["Statutino Libertino"]=75000,
	["Tipi Topi Taco"]=75000,["Alessio"]=85000,
	["Tralalita Tralala"]=100000,["Tukanno Bananno"]=100000,
	["Orcalero Orcala"]=100000,["Extinct Ballerina"]=125000,
	["Trenostruzzo Turbo 3000"]=150000,["Urubini Flamenguini"]=150000,
	["Capi Taco"]=155000,["Gattito Tacoto"]=160000,
	["Trippi Troppi Troppa Trippa"]=175000,["Ballerino Lololo"]=200000,
	["Bulbito Bandito Traktorito"]=205000,["Los Tungtungtungcitos"]=210000,
	["Ballerina Peppermintina"]=215000,["Pakrahmatmamat"]=215000,
	["Los Bombinitos"]=220000,["Bombardini Tortinii"]=225000,
	["Piccione Macchina"]=225000,["Brr es Teh Patipum"]=225000,
	["Tractoro Dinosauro"]=230000,["Los Orcalitos"]=235000,
	["Corn Corn Corn Sahur"]=250000,["Squalanana"]=250000,
	["Dug Dug Dug"]=255000,["Yeti Claus"]=257500,["Ginger Globo"]=257500,
	["Los Tipi Tacos"]=260000,["Frio Ninja"]=265000,
	["Ginger Cisterna"]=293500,["Pop Pop Sahur"]=295000,
	["La Vacca Saturno Saturnita"]=300000,["Los Matteos"]=300000,
	["Bisonte Giuppitere"]=300000,["Jackorilla"]=315000,
	["Sammyni Spyderini"]=325000,["Chimpanzini Spiderini"]=325000,
	["Torrtuginni Dragonfrutini"]=350000,["Unclito Samito"]=350000,
	["Dul Dul Dul"]=375000,["Blackhole Goat"]=400000,["Chachechi"]=400000,
	["Guerriro Digitale"]=425000,["Agarrini la Palini"]=425000,
	["Extinct Tralalero"]=450000,["Fragola La La La"]=450000,
	["Los Spyderinis"]=450000,["La Cucaracha"]=475000,["Los Tortus"]=500000,
	["Los Tralaleritos"]=750000,["Extinct Matteo"]=500000,
	["Vulturino Skeletono"]=500000,["Boatito Auratito"]=525000,
	["Karkerkar Kurkur"]=550000,["Orcalita Orcala"]=575000,
	["Piccionetta Macchina"]=600000,["Las Tralaleritas"]=650000,
	["Job Job Job Sahur"]=700000,["Las Vaquitas Saturnitas"]=750000,
	["Los Combinasionas"]=800000,["Trenzostruzzo Turbo 4000"]=850000,
	["La Grande Combinasion"]=10000000,["Graipuss Medussi"]=1000000,
	["Anpali Babel"]=1200000,["Mastodontico Telepiedone"]=1200000,
	["Noo My Hotspot"]=1500000,["La Sahur Combinasion"]=2000000,
	["Nooo My Hotspot"]=2000000,["La Karkerkar Combinasion"]=17500000,
	["Pot Hotspot"]=2500000,["Esok Sekolah"]=3000000,
	["Chicleteira Bicicleteira"]=3500000,["67"]=7500000,
	["Los Nooo My Hotspotsitos"]=5500000,["Nuclearo Dinossauro"]=15000000,
	["Las Sis"]=17500000,["Celularcini Viciosini"]=22500000,
	["Los Bros"]=24000000,["Tralaledon"]=27500000,
	["La Esok Sekolah"]=30000000,["Tang Tang Kelentang"]=33500000,
	["Ketupat Kepat"]=35000000,["Tictac Sahur"]=37500000,
	["La Secret Combinasion"]=125000000,["Ketchuru and Musturu"]=42500000,
	["Garama and Madundung"]=50000000,["Spaghetti Tualetti"]=60000000,
	["Los Orcaleritos"]=235000000,["Dragon Cannelloni"]=200000000,
	["Strawberry Elephant"]=350000000,
}

-- ================================================================
--  MUTATION MULTIPLIERS  (additive: Lava 8 + Candy 4 = 12x total)
-- ================================================================
local MUTATION_MULTIPLIERS = {
	["Gold"]=1.25, ["Diamond"]=1.50, ["Rainbow"]=10.0,
	["Bloodrot"]=2.0, ["Candy"]=4.0, ["Lava"]=6.0,
	["Galaxy"]=7.0, ["Yin-Yang"]=7.5, ["Radioactive"]=8.5, ["Wet"]=1.5,
}

-- Additive sum so Lava(6) + Candy(4) = 10x, not 24x.
-- A brainrot with no mutations has 1x base; we add the mutation bonuses on top.
local function getTotalMultiplier(mutList)
	local bonus = 0
	for _, name in ipairs(mutList) do
		bonus = bonus + (MUTATION_MULTIPLIERS[name] or 0)
	end
	return 1 + bonus  -- base 1x + all stacked bonuses
end

-- ================================================================
--  REMOTE EVENTS
-- ================================================================
local Remotes = ReplicatedStorage:WaitForChild("RemoteEvents")

local function getOrCreate(name, class)
	local r = Remotes:FindFirstChild(name)
	if not r then
		r = Instance.new(class or "RemoteEvent")
		r.Name   = name
		r.Parent = Remotes
	end
	return r
end

local ConcentratorResult    = getOrCreate("ConcentratorResult")
local ConcentratorBroadcast = getOrCreate("ConcentratorBroadcast")
local ConcentratorInfo      = getOrCreate("ConcentratorInfo", "RemoteFunction")

-- ================================================================
--  DATASTORE
-- ================================================================
local discoveryStore = DataStoreService:GetDataStore(CONFIG.DS_DISCOVERIES)
local discoveryCache = {}

local function recipeKey(mutList)
	local s = table.clone(mutList)
	table.sort(s)
	return table.concat(s, "|")
end

local function checkDiscovery(mutList)
	local key = recipeKey(mutList)
	if discoveryCache[key] then
		return true, discoveryCache[key].discoverer, discoveryCache[key].blendedName
	end
	local ok, data = pcall(discoveryStore.GetAsync, discoveryStore, key)
	if ok and data then
		discoveryCache[key] = data
		return true, data.discoverer, data.blendedName
	end
	return false, nil, nil
end

local function recordDiscovery(mutList, playerName, blendedName)
	local key  = recipeKey(mutList)
	local data = {
		discoverer  = playerName,
		depth       = #mutList,
		blendedName = blendedName,
		timestamp   = os.time(),
	}
	local ok, err = pcall(discoveryStore.SetAsync, discoveryStore, key, data)
	if ok then
		discoveryCache[key] = data
	else
		warn("âŒ DataStore write failed for key " .. key .. ": " .. tostring(err))
	end
	return ok
end

local function calcDiscoveryBonus(depth)
	return math.floor(CONFIG.BASE_DISCOVERY_REWARD * (CONFIG.DEPTH_MULTIPLIER ^ (depth - 1)))
end

-- ================================================================
--  GEMINI â€” blend mutation names into a creative label
-- ================================================================
local GEMINI_URL
local blendCache = {}

local function buildGeminiURL()
	return string.format(
		"https://generativelanguage.googleapis.com/v1beta/models/%s:generateContent?key=%s",
		CONFIG.GEMINI_MODEL,
		CONFIG.GEMINI_API_KEY
	)
end

--  Whole-word boundary check using Lua's %f frontier pattern.
--  Prevents "Lava" matching inside "Lavender", "Candy" inside "Candescent", etc.
--  Returns true only when more than half the input mutations
--  have a word from their name appear as a standalone word in the output.
local function isLazyOutput(output, mutList)
	local lower = output:lower()
	local matchCount = 0

	for _, m in ipairs(mutList) do
		for word in m:gmatch("%a+") do
			if #word > 3 then
				-- %f[%a] = transition from non-alpha to alpha (word start)
				-- %f[%A] = transition from alpha to non-alpha (word end)
				if lower:match("%f[%a]" .. word:lower() .. "%f[%A]") then
					warn(string.format(
						"   [LazyCheck] Forbidden word '%s' (from '%s') found in '%s'",
						word, m, output
						))
					matchCount += 1
					break  -- one match per mutation is enough
				end
			end
		end
	end

	local threshold = math.floor(#mutList / 2)
	local lazy = matchCount > threshold
	if lazy then
		warn(string.format(
			"   [LazyCheck] REJECTED '%s' â€” %d/%d mutations matched (threshold >%d)",
			output, matchCount, #mutList, threshold
			))
	end
	return lazy
end

--  Single Gemini call.  Pass rejectedAnswer on retries so the model
--  can see exactly what it did wrong.
local function callGemini(basePrompt, rejectedAnswer)
	GEMINI_URL = GEMINI_URL or buildGeminiURL()

	local fullPrompt = basePrompt
	if rejectedAnswer then
		fullPrompt = basePrompt
			.. "\n\nâš ï¸ Your previous answer was REJECTED because it contained one or more of the input words verbatim."
			.. "\nRejected answer: \"" .. rejectedAnswer .. "\""
			.. "\nYou MUST produce something completely different that shares NO words with the inputs."
	end

	local payload = HttpService:JSONEncode({
		systemInstruction = {
			parts = { {
				text = "You are a creative mutation name generator for a silly Italian meme game. "
					.. "Output ONLY the invented name â€” no explanation, no punctuation at the end, nothing else. "
					.. "Never use the input words or their direct translations in any language."
			} }
		},
		contents = { { parts = { { text = fullPrompt } } } },
		generationConfig = { maxOutputTokens = 30, temperature = 1.1 },
	})

	local httpOk, raw = pcall(
		HttpService.PostAsync, HttpService,
		GEMINI_URL, payload, Enum.HttpContentType.ApplicationJson, false
	)

	if not httpOk then
		warn("âš ï¸ Gemini HTTP error: " .. tostring(raw))
		return nil
	end

	-- Always log the raw response so failures are diagnosable in the output window
	print("   [Gemini RAW] " .. tostring(raw):sub(1, 500))

	local parseOk, parsed = pcall(HttpService.JSONDecode, HttpService, raw)

	if not parseOk or not parsed then
		warn("âš ï¸ Gemini JSON parse failed")
		return nil
	end

	-- Surface API-level errors (e.g. invalid key, quota exceeded)
	if parsed.error then
		warn(string.format("âš ï¸ Gemini API error %s: %s",
			tostring(parsed.error.code), tostring(parsed.error.message)))
		return nil
	end

	local cand = parsed.candidates and parsed.candidates[1]
	if not cand then
		warn("âš ï¸ Gemini returned no candidates")
		-- Log promptFeedback if present (e.g. safety block)
		if parsed.promptFeedback then
			warn("   promptFeedback: " .. HttpService:JSONEncode(parsed.promptFeedback))
		end
		return nil
	end

	-- Log finish reason for any non-STOP result
	if cand.finishReason and cand.finishReason ~= "STOP" then
		warn("âš ï¸ Gemini finishReason: " .. tostring(cand.finishReason))
	end

	local part = cand.content and cand.content.parts and cand.content.parts[1]
	if not part then
		warn("âš ï¸ Gemini candidate has no content parts")
		return nil
	end

	local text = (part.text or ""):gsub("[\n\r]", ""):match("^%s*(.-)%s*$")
	if not text or text == "" then
		warn("âš ï¸ Gemini returned empty text")
		return nil
	end

	return text
end

local function blendMutationNames(mutList)
	local key = recipeKey(mutList)
	if blendCache[key] then return blendCache[key] end

	-- Single mutation â€” no blending needed
	if #mutList == 1 then
		blendCache[key] = mutList[1]
		return mutList[1]
	end

	local listed = table.concat(mutList, " + ")

	local prompt = string.format(
		[[Fuse these mutation concepts into ONE invented name: %s

Rules:
- 1 to 4 words. Italian or Latin phonetics are encouraged where natural.
- Must feel like a brand-new standalone mutation name â€” evocative, not a description.
- You are completely banned from using any input words or their direct translations.

Good fusion examples:
"Lava" + "Radioactive"           â†’ "Toxic Inferno"
"Gold" + "Rainbow"               â†’ "Gilded Prism"
"Galaxy" + "Wet"                 â†’ "Nebula Tide"
"Bloodrot" + "Candy" + "Lava"    â†’ "Sugared Hellfire"
"Diamond" + "Yin-Yang"           â†’ "Crystallo Equilibrio"
"Radioactive" + "Wet"            â†’ "Irradiated Torrente"
"Galaxy" + "Yin-Yang" + "Wet"    â†’ "Cosmic Tidal Balance"]],
		listed
	)

	local MAX_ATTEMPTS = 3
	local result       = nil
	local lastBad      = nil

	for attempt = 1, MAX_ATTEMPTS do
		print(string.format("   [Gemini] Attempt %d/3 for [%s]", attempt, listed))

		local output = callGemini(prompt, attempt > 1 and lastBad or nil)

		if output then
			if isLazyOutput(output, mutList) then
				warn(string.format(
					"âš ï¸ Gemini attempt %d rejected (lazy): '%s'", attempt, output
					))
				lastBad = output
				task.wait(0.5)
			else
				result = output
				print(string.format(
					"âœ¨ Gemini blended [%s] â†’ '%s' (attempt %d)", listed, result, attempt
					))
				break
			end
		else
			warn("âš ï¸ Gemini attempt " .. attempt .. " returned nil â€” check RAW log above")
			task.wait(0.5)
		end
	end

	-- Fallback: depth-flavoured Italian phrase that doesn't expose raw mutation names
	if not result then
		warn("âš ï¸ All Gemini attempts exhausted for [" .. listed .. "] â€” using fallback")
		local depthLabel = ({
			[2] = "Duplice",
			[3] = "Triplice",
			[4] = "Quadruplice",
			[5] = "Quintuplice",
		})[#mutList] or "Multiplo"
		result = depthLabel .. " Fusione"
	end

	blendCache[key] = result
	return result
end

-- ================================================================
--  MUTATION ATTRIBUTE HELPERS
-- ================================================================
local function getMutations(tool)
	local raw = tool:GetAttribute("Mutations") or ""
	if raw == "" then
		local legacy = tool:GetAttribute("Mutation") or ""
		if legacy ~= "" then return { legacy } end
		return {}
	end
	local list = {}
	for m in raw:gmatch("[^,]+") do
		list[#list + 1] = m:match("^%s*(.-)%s*$")
	end
	return list
end

local function saveMutations(tool, mutList)
	tool:SetAttribute("Mutations", table.concat(mutList, ","))
end

-- ================================================================
--  VISUAL HELPERS
-- ================================================================
local ANIM_PRIORITY = {
	"Rainbow","Radioactive","Galaxy","Yin-Yang",
	"Lava","Candy","Wet","Bloodrot","Diamond","Gold",
}

local STATIC_VISUAL = {
	["Gold"]     = { col = Color3.fromRGB(255,215,0),   mat = Enum.Material.SmoothPlastic, ref = nil },
	["Diamond"]  = { col = Color3.fromRGB(185,242,255), mat = Enum.Material.SmoothPlastic, ref = 0.3 },
	["Bloodrot"] = { col = Color3.fromRGB(100,0,0),     mat = Enum.Material.SmoothPlastic, ref = nil },
	["Candy"]    = { col = Color3.fromRGB(255,105,180), mat = Enum.Material.SmoothPlastic, ref = 0.1 },
	["Lava"]     = { col = Color3.fromRGB(255,80,0),    mat = Enum.Material.Neon,          ref = nil },
	["Wet"]      = { col = Color3.fromRGB(84,130,255),  mat = Enum.Material.Neon,          ref = nil },
}

local LABEL_COLORS = {
	["Gold"]        = Color3.fromRGB(255,215,0),
	["Diamond"]     = Color3.fromRGB(185,242,255),
	["Bloodrot"]    = Color3.fromRGB(100,0,0),
	["Candy"]       = Color3.fromRGB(255,105,180),
	["Lava"]        = Color3.fromRGB(255,80,0),
	["Galaxy"]      = Color3.fromRGB(138,43,226),
	["Radioactive"] = Color3.fromRGB(0,255,50),
	["Wet"]         = Color3.fromRGB(84,130,255),
}

local function inList(val, list)
	for _, v in ipairs(list) do if v == val then return true end end
	return false
end

local function stripAppearances(model)
	for _, d in pairs(model:GetDescendants()) do
		if d:IsA("BasePart") or d:IsA("MeshPart") then
			local sa = d:FindFirstChildOfClass("SurfaceAppearance")
			if sa then sa:Destroy() end
		elseif d:IsA("SpecialMesh") then
			d.TextureId = ""
		end
	end
end

local function applyStackedVisuals(model, mutList)
	stripAppearances(model)

	local parts = {}
	for _, d in pairs(model:GetDescendants()) do
		if d:IsA("BasePart") then parts[#parts + 1] = d end
	end

	local chosen = nil
	for _, anim in ipairs(ANIM_PRIORITY) do
		if inList(anim, mutList) then chosen = anim; break end
	end

	if chosen == "Rainbow" then
		task.spawn(function()
			local hue = 0
			while model and model.Parent do
				hue = (hue + 0.01) % 1
				local c = Color3.fromHSV(hue, 1, 1)
				for _, p in ipairs(parts) do if p and p.Parent then p.Color = c end end
				task.wait(0.05)
			end
		end)

	elseif chosen == "Radioactive" then
		task.spawn(function()
			local t = 0
			while model and model.Parent do
				t += 0.08
				local g = math.floor(150 + 105 * (0.5 + 0.5 * math.sin(t)))
				local c = Color3.fromRGB(0, g, 0)
				for _, p in ipairs(parts) do
					if p and p.Parent then p.Color = c; p.Material = Enum.Material.Neon end
				end
				task.wait(0.05)
			end
		end)

	elseif chosen == "Galaxy" then
		task.spawn(function()
			local t = 0
			while model and model.Parent do
				t += 0.02
				local b = 0.5 + 0.5 * math.sin(t)
				local c = Color3.fromRGB(math.floor(75 + 63 * b), 0, math.floor(130 + 100 * b))
				for _, p in ipairs(parts) do
					if p and p.Parent then p.Color = c; p.Material = Enum.Material.Neon end
				end
				task.wait(0.05)
			end
		end)

	elseif chosen == "Yin-Yang" then
		task.spawn(function()
			local flip = false
			while model and model.Parent do
				flip = not flip
				local c = flip and Color3.new(1,1,1) or Color3.new(0,0,0)
				for _, p in ipairs(parts) do if p and p.Parent then p.Color = c end end
				task.wait(0.5)
			end
		end)

	else
		local v = chosen and STATIC_VISUAL[chosen]
		if v then
			for _, p in ipairs(parts) do
				if p and p.Parent then
					p.Color    = v.col
					p.Material = v.mat
					if v.ref then p.Reflectance = v.ref end
				end
			end
		end
	end
end

-- ================================================================
--  BILLBOARD UPDATE
-- ================================================================
local function animateRainbowLabel(lbl)
	task.spawn(function()
		local hue = 0
		while lbl and lbl.Parent do
			hue = (hue + 0.01) % 1
			lbl.TextColor3 = Color3.fromHSV(hue, 1, 1)
			task.wait(0.05)
		end
	end)
end

local function updateMutationBillboard(brainrotModel, blendedLabel, mutList)
	local statsGUI = brainrotModel:FindFirstChild("StatsGUI")
	if not statsGUI then return end

	local old = statsGUI:FindFirstChild("MutationLabel")
	if old then old:Destroy() end

	local labelColor = Color3.new(1,1,1)
	local doRainbow  = false
	local doYinYang  = false

	for _, anim in ipairs(ANIM_PRIORITY) do
		if inList(anim, mutList) then
			if   anim == "Rainbow"  then doRainbow = true
			elseif anim == "Yin-Yang" then doYinYang = true
			else
				local c = LABEL_COLORS[anim]
				if c then labelColor = c end
			end
			break
		end
	end

	local lbl = Instance.new("TextLabel")
	lbl.Name                   = "MutationLabel"
	lbl.Size                   = UDim2.new(1, 0, 0.2, 0)
	lbl.BackgroundTransparency = 1
	lbl.Font                   = Enum.Font.SourceSansBold
	lbl.TextScaled             = true
	lbl.Text                   = "â­ " .. blendedLabel .. " â­"
	lbl.TextColor3             = labelColor
	lbl.TextStrokeColor3       = Color3.new(0,0,0)
	lbl.TextStrokeTransparency = 0
	lbl.LayoutOrder            = 2

	local c = Instance.new("UITextSizeConstraint")
	c.MaxTextSize = 35
	c.MinTextSize = 2
	c.Parent      = lbl

	lbl.Parent = statsGUI

	if doRainbow then
		animateRainbowLabel(lbl)
	elseif doYinYang then
		task.spawn(function()
			local flip = false
			while lbl and lbl.Parent do
				flip = not flip
				lbl.TextColor3 = flip and Color3.new(1,1,1) or Color3.new(0,0,0)
				task.wait(0.5)
			end
		end)
	end
end

-- ================================================================
--  CONCENTRATOR MODEL
-- ================================================================
local concentratorModel = workspace:FindFirstChild(CONFIG.CONCENTRATOR_MODEL_NAME, true)
if not concentratorModel then
	warn("âš ï¸ WeatherConcentrator model not found in Workspace! System inactive.")
	warn("   Make sure a Model named '" .. CONFIG.CONCENTRATOR_MODEL_NAME .. "' exists in Workspace.")
	return
end
print("âœ“ Found concentrator model: " .. concentratorModel:GetFullName())

local pedestal = concentratorModel.PrimaryPart
if not pedestal then
	pedestal = concentratorModel:FindFirstChildWhichIsA("BasePart", true)
	if pedestal then
		warn("âš ï¸ WeatherConcentrator has no PrimaryPart set â€” falling back to '"
			.. pedestal.Name .. "'. Set PrimaryPart in Studio for best results.")
	else
		warn("âš ï¸ WeatherConcentrator has no BasePart at all! System inactive.")
		return
	end
end
print("âœ“ Using pedestal part: " .. pedestal:GetFullName())

local pedesLight = pedestal:FindFirstChildOfClass("PointLight")
if not pedesLight then
	pedesLight = Instance.new("PointLight")
	pedesLight.Brightness = 5
	pedesLight.Range      = 20
	pedesLight.Parent     = pedestal
end

local function refreshConcentratorGlow()
	local data = WeatherSystem.WEATHER_TYPES[WeatherSystem.getCurrentWeather()]
	local col  = (data and data.color) or Color3.fromRGB(200, 200, 255)
	TweenService:Create(pedesLight, TweenInfo.new(1.5), { Color = col }):Play()
	TweenService:Create(pedestal,   TweenInfo.new(1.5), { Color = col }):Play()
end
refreshConcentratorGlow()

task.spawn(function()
	while pedestal and pedestal.Parent do
		TweenService:Create(pedesLight,
			TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
			{ Brightness = 8 }):Play()
		task.wait(1)
		TweenService:Create(pedesLight,
			TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
			{ Brightness = 3 }):Play()
		task.wait(1)
	end
end)

-- ================================================================
--  PLAYER COOLDOWN
-- ================================================================
local cooldownMap = {}

local function isOnCooldown(player)
	local last = cooldownMap[player.UserId] or 0
	return (tick() - last) < CONFIG.PLAYER_COOLDOWN
end

local function getCooldownRemaining(player)
	local last = cooldownMap[player.UserId] or 0
	return math.max(0, math.ceil(CONFIG.PLAYER_COOLDOWN - (tick() - last)))
end

-- ================================================================
--  MAIN CRAFT FUNCTION
-- ================================================================
local function tryConcentrate(player)
	-- 1. Cooldown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	if isOnCooldown(player) then
		ConcentratorResult:FireClient(player, false,
			"â³ Wait " .. getCooldownRemaining(player) .. "s before using again.", nil)
		return
	end

	-- 2. Active weather mutation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	local currentWeather  = WeatherSystem.getCurrentWeather()
	local weatherData     = WeatherSystem.WEATHER_TYPES[currentWeather]
	local activeMutation  = weatherData and weatherData.mutation

	print(string.format("ðŸŒ¦ï¸ [Concentrator] %s triggered | weather: %s | mutation: %s",
		player.Name, tostring(currentWeather), tostring(activeMutation)))

	if currentWeather == "Clear" or not activeMutation then
		ConcentratorResult:FireClient(player, false,
			"â˜€ï¸ No weather event active! Wait for a storm.", nil)
		return
	end

	-- 3. Player has a brainrot equipped â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	local character = player.Character
	if not character then
		ConcentratorResult:FireClient(player, false, "âŒ No character found.", nil)
		return
	end

	local tool = character:FindFirstChildOfClass("Tool")
	local pack = ReplicatedStorage:FindFirstChild("Brainrot pack1")

	if not tool or not pack then
		ConcentratorResult:FireClient(player, false, "ðŸŽ’ Equip a Brainrot first!", nil)
		return
	end

	local validBrainrot = false
	for _, item in pairs(pack:GetChildren()) do
		if item.Name == tool.Name then validBrainrot = true; break end
	end
	if not validBrainrot then
		ConcentratorResult:FireClient(player, false,
			"ðŸŽ’ Equip a valid Brainrot from your inventory!", nil)
		return
	end

	-- 4. Duplicate mutation guard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	local currentMutations = getMutations(tool)
	for _, m in ipairs(currentMutations) do
		if m == activeMutation then
			ConcentratorResult:FireClient(player, false,
				"âš ï¸ This brainrot already has the " .. activeMutation .. " mutation!", nil)
			return
		end
	end

	-- 5. Cost calculation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	local baseIncome = BRAINROT_INCOME[tool.Name] or 1
	local cost       = math.max(CONFIG.MIN_COST, baseIncome * CONFIG.COST_SECONDS)

	local leaderstats = player:FindFirstChild("leaderstats")
	local moneyValue  =
		(leaderstats and leaderstats.Parent:FindFirstChild("MoneyRaw")) or
		(leaderstats and leaderstats:FindFirstChild("Cash"))             or
		(leaderstats and leaderstats:FindFirstChild("Coins"))

	if not moneyValue then
		ConcentratorResult:FireClient(player, false,
			"âŒ Money stat not found â€” contact an admin.", nil)
		return
	end

	if moneyValue.Value < cost then
		ConcentratorResult:FireClient(player, false,
			string.format("ðŸ’¸ Need $%d (you have $%d).", cost, moneyValue.Value), nil)
		return
	end

	-- 6. Stamp cooldown immediately to prevent double-fire â”€â”€â”€â”€â”€â”€â”€â”€â”€
	cooldownMap[player.UserId] = tick()

	-- 7. Deduct cost â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	moneyValue.Value -= cost

	-- 8. All remaining work is async (Gemini + DataStore) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	task.spawn(function()
		local newMutations = table.clone(currentMutations)
		table.insert(newMutations, activeMutation)

		-- Reuse stored name for known combos; only call Gemini for new ones
		local alreadyFound, _, storedName = checkDiscovery(newMutations)

		local blendedLabel
		if alreadyFound and storedName and storedName ~= "" then
			blendedLabel = storedName
			blendCache[recipeKey(newMutations)] = storedName
			print(string.format("ðŸ“– Reused stored name [%s] â†’ '%s'",
				table.concat(newMutations, "+"), blendedLabel))
		else
			blendedLabel = blendMutationNames(newMutations)
		end

		-- Persist onto tool
		saveMutations(tool, newMutations)
		tool:SetAttribute("Mutation",     blendedLabel)
		tool:SetAttribute("MutationMult", getTotalMultiplier(newMutations))

		-- Update visuals
		applyStackedVisuals(tool, newMutations)
		updateMutationBillboard(tool, blendedLabel, newMutations)

		-- Record first discovery
		local discoveryBonus = nil
		if not alreadyFound then
			local depth    = #newMutations
			discoveryBonus = calcDiscoveryBonus(depth)
			recordDiscovery(newMutations, player.Name, blendedLabel)
			moneyValue.Value += discoveryBonus

			ConcentratorBroadcast:FireAllClients(
				player.Name,
				blendedLabel,
				tool.Name,
				discoveryBonus,
				depth
			)

			print(string.format(
				"ðŸ† FIRST DISCOVERY: '%s' by %s  depth=%d  bonus=$%d",
				blendedLabel, player.Name, depth, discoveryBonus
				))
		end

		-- Fire result to crafter
		local totalMult = getTotalMultiplier(newMutations)
		local msg
		if discoveryBonus then
			msg = string.format(
				"ðŸŒŸ FIRST DISCOVERY! '%s' â€” You earned $%s bonus!",
				blendedLabel, string.format("%d", discoveryBonus)
			)
		else
			msg = string.format(
				"âœ¨ Fused! Mutation is now: '%s'  (%.2fx income total)",
				blendedLabel, totalMult
			)
		end

		ConcentratorResult:FireClient(player, true, msg, discoveryBonus)

		-- Flash the pedestal
		task.spawn(function()
			for _ = 1, 5 do
				TweenService:Create(pedesLight, TweenInfo.new(0.1), { Brightness = 15 }):Play()
				task.wait(0.15)
				TweenService:Create(pedesLight, TweenInfo.new(0.1), { Brightness = 5 }):Play()
				task.wait(0.15)
			end
		end)

		print(string.format(
			"âš¡ %s | %s | fused: %s | cost: $%d | mult: %.2fx | depth: %d",
			player.Name, tool.Name, table.concat(newMutations, "+"),
			cost, totalMult, #newMutations
			))
	end)
end

-- ================================================================
--  PROXIMITY PROMPT
-- ================================================================
local prompt = concentratorModel:FindFirstChildWhichIsA("ProximityPrompt", true)
if not prompt then
	prompt = Instance.new("ProximityPrompt")
	prompt.ActionText            = "Concentrate"
	prompt.HoldDuration          = 0.5
	prompt.MaxActivationDistance = 10
	prompt.Parent                = pedestal
	print("â„¹ï¸ Auto-created ProximityPrompt on " .. pedestal:GetFullName())
else
	print("âœ“ Found existing ProximityPrompt: " .. prompt:GetFullName())
end

local function refreshPromptLabel()
	local weather = WeatherSystem.getCurrentWeather()
	local data    = WeatherSystem.WEATHER_TYPES[weather]
	if weather == "Clear" or not (data and data.mutation) then
		prompt.ObjectText = "Weather Concentrator  (waiting for stormâ€¦)"
	else
		prompt.ObjectText = string.format("Weather Concentrator  [%s]", data.mutation)
	end
end
refreshPromptLabel()

prompt.Triggered:Connect(function(player)
	tryConcentrate(player)
end)

-- ================================================================
--  REMOTE FUNCTION  â€” client cost preview
-- ================================================================
ConcentratorInfo.OnServerInvoke = function(player)
	local weather  = WeatherSystem.getCurrentWeather()
	local data     = WeatherSystem.WEATHER_TYPES[weather]
	local mutation = data and data.mutation
	local char     = player.Character
	local tool     = char and char:FindFirstChildOfClass("Tool")
	local base     = (tool and BRAINROT_INCOME[tool.Name]) or 0
	local cost     = math.max(CONFIG.MIN_COST, base * CONFIG.COST_SECONDS)
	local mutList  = tool and getMutations(tool) or {}
	local preview  = table.clone(mutList)
	if mutation then table.insert(preview, mutation) end
	return {
		cost           = cost,
		activeMutation = mutation,
		weatherDisplay = (data and data.displayName) or "Clear",
		previewMult    = getTotalMultiplier(preview),
		currentDepth   = #mutList,
		discoveryBonus = calcDiscoveryBonus(#preview),
	}
end

-- ================================================================
--  WEATHER CHANGE WATCHER
-- ================================================================
task.spawn(function()
	local last = WeatherSystem.getCurrentWeather()
	while true do
		task.wait(2)
		local cur = WeatherSystem.getCurrentWeather()
		if cur ~= last then
			last = cur
			refreshPromptLabel()
			refreshConcentratorGlow()
		end
	end
end)

-- ================================================================
--  CLEANUP
-- ================================================================
Players.PlayerRemoving:Connect(function(p)
	cooldownMap[p.UserId] = nil
end)

print("âœ… WeatherConcentratorSystem loaded!")
print("   Concentrator: " .. concentratorModel:GetFullName())
